<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Linux 基础 - 7. 访问控制 - LINOTES</title>
<meta name="description" content="用简洁清晰的语言讨论技术">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Linux 基础 - 7. 访问控制">
<meta property="og:url" content="https://liloli.github.io/linux/linux.accontrol/">


  <meta property="og:description" content="用简洁清晰的语言讨论技术">



  <meta property="og:image" content="https://liloli.github.io/assets/images/header/linux.jpg">



  <meta name="twitter:site" content="@liloli">
  <meta name="twitter:title" content="Linux 基础 - 7. 访问控制">
  <meta name="twitter:description" content="用简洁清晰的语言讨论技术">
  <meta name="twitter:url" content="https://liloli.github.io/linux/linux.accontrol/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://liloli.github.io/assets/images/header/linux.jpg">
  

  



  <meta property="article:published_time" content="2015-01-07T00:00:00+08:00">





  

  


<link rel="canonical" href="https://liloli.github.io/linux/linux.accontrol/">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "Hawk Zhang",
      "url": "https://liloli.github.io",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="https://liloli.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://liloli.github.io/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- <link rel="stylesheet" href="/assets/css/vim.css"> -->



  









<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://liloli.github.io/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/app/rsync/" >Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/server/vsftpd/" >Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/kernel/filedescriptor/" >文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/tools/tools.datastream/" >数据流处理</a>
            </li>
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://liloli.github.io/assets/images/header/linux.jpg');"
>
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Linux 基础 - 7. 访问控制

        
      </h1>
      
        <p class="page__lead">
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://liloli.github.io/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:liloli@gmail.com">
            <meta itemprop="email" content="liloli@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Linux 基础 - 7. 访问控制">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="January 07, 2015">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-copy"></i> 7. 访问控制</h4></header>
              <ul class="toc__menu">
  <li><a href="#71-linux-文件">7.1 Linux 文件</a>
    <ul>
      <li><a href="#711-linux-文件类型">7.1.1 Linux 文件类型</a></li>
      <li><a href="#712-linux-文件扩展名">7.1.2 Linux 文件扩展名</a></li>
      <li><a href="#713-linux-文件名">7.1.3 Linux 文件名</a></li>
    </ul>
  </li>
  <li><a href="#72-linux-文件权限">7.2 Linux 文件权限</a>
    <ul>
      <li><a href="#721-权限位">7.2.1 权限位</a></li>
      <li><a href="#722-查看文件权限">7.2.2 查看文件权限</a></li>
      <li><a href="#723-权限表示方法">7.2.3 权限表示方法</a></li>
      <li><a href="#724-umask">7.2.4 UMASK</a></li>
      <li><a href="#725-修改文件权限">7.2.5 修改文件权限</a></li>
    </ul>
  </li>
  <li><a href="#73-文件权限-vs-目录权限">7.3 文件权限 vs 目录权限</a>
    <ul>
      <li><a href="#731-文件的权限">7.3.1 文件的权限</a></li>
      <li><a href="#732-目录的权限">7.3.2 目录的权限</a></li>
      <li><a href="#733-文件权限与目录权限对比">7.3.3 文件权限与目录权限对比</a></li>
    </ul>
  </li>
  <li><a href="#74-文件的属性">7.4 文件的属性</a>
    <ul>
      <li><a href="#741-chattr">7.4.1 CHATTR</a></li>
      <li><a href="#742-扩展属性">7.4.2 扩展属性</a></li>
    </ul>
  </li>
  <li><a href="#75-acl-权限控制">7.5 ACL 权限控制</a>
    <ul>
      <li><a href="#751-acl-简介">7.5.1 ACL 简介</a></li>
      <li><a href="#752-acl-的查看">7.5.2 ACL 的查看</a></li>
      <li><a href="#733-acl-的设置">7.3.3 ACL 的设置</a></li>
    </ul>
  </li>
  <li><a href="#76-切换用户">7.6 切换用户</a>
    <ul>
      <li><a href="#761-帐号与系统安全">7.6.1 帐号与系统安全</a></li>
      <li><a href="#762-su">7.6.2 SU</a></li>
      <li><a href="#763-sudo">7.6.3 sudo</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <h2 id="71-linux-文件">7.1 Linux 文件</h2>

<h3 id="711-linux-文件类型">7.1.1 Linux 文件类型</h3>

<p>文件类型是文件元数据之一，在 Inode 中 占 <strong>4 位</strong>。</p>

<p>普通文件、块设备、字符设备、管道、硬链接、套接字、目录文件，用不同符号表示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">文件类型</th>
      <th style="text-align: left">符</th>
      <th style="text-align: left">说明</th>
      <th style="text-align: left">创建</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">普通文件</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">文本文件、二进制文件、图片、压缩包</td>
      <td style="text-align: left">touch,vi,重定向符号</td>
    </tr>
    <tr>
      <td style="text-align: left">块文件</td>
      <td style="text-align: left">b</td>
      <td style="text-align: left">硬件文件，多在/dev</td>
      <td style="text-align: left">fdisk 或建虚拟分区</td>
    </tr>
    <tr>
      <td style="text-align: left">字符设备文件</td>
      <td style="text-align: left">c</td>
      <td style="text-align: left">提供输入输出的串流，键盘、鼠标</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">管道文件</td>
      <td style="text-align: left">p</td>
      <td style="text-align: left">FIFO: First In, First Out</td>
      <td style="text-align: left">mkfifo</td>
    </tr>
    <tr>
      <td style="text-align: left">链接文件</td>
      <td style="text-align: left">l</td>
      <td style="text-align: left">* -&gt; ****</td>
      <td style="text-align: left">ln -s</td>
    </tr>
    <tr>
      <td style="text-align: left">套接字文件</td>
      <td style="text-align: left">s</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">目录文件</td>
      <td style="text-align: left">d</td>
      <td style="text-align: left">硬链接数≥2</td>
      <td style="text-align: left">mkdir</td>
    </tr>
  </tbody>
</table>

<p class="notice--primary"><code class="highlighter-rouge">符</code> 是指 <code class="highlighter-rouge">ls -l</code> 返回结果第一列的符号，用于表示文件类型。</p>

<p>文件名之前有英文句号 <code class="highlighter-rouge">.</code>，表示 <strong>隐藏文件</strong>，可以使用 <code class="highlighter-rouge">ls -a</code> 来显示。</p>

<ul>
  <li>普通文件</li>
</ul>

<p>纯文本文件，二进制文件，数据文件</p>

<ul>
  <li>目录文件</li>
</ul>

<p>目录是一种特殊文件。</p>

<ul>
  <li>链接文件</li>
</ul>

<p>硬链接、软链接。</p>

<ul>
  <li>设备文件</li>
</ul>

<p>通常集中在 <code class="highlighter-rouge">/dev</code> 目录。</p>

<p>块设备文件 ：提供系统随机存取的周边设备。</p>

<p>字符设备文件：键盘、鼠标，这些设备的信息传输是串流的。</p>

<ul>
  <li>套接字文件</li>
</ul>

<p>SOCKET，可以启动一个程序来监听用户端的访问，用户端就可以通过这个 SOCKET 来进行数据的通讯了。</p>

<ul>
  <li>管道文件</li>
</ul>

<p>PIPE，又名 FIFO（first-in-first-out）文件。目的在解决多个程序同时存取一个文件所造成的错误问题。</p>

<h3 id="712-linux-文件扩展名">7.1.2 Linux 文件扩展名</h3>

<p>Linux 的文件是没有扩展名的，仅为了使用方便才加的。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">.sh</code> 脚本或批处理文件，用 shell 写成</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">.Z</code>, <code class="highlighter-rouge">.tar</code>, <code class="highlighter-rouge">.tar.gz</code>, <code class="highlighter-rouge">.zip</code>, <code class="highlighter-rouge">.tgz</code> 压缩包</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">.html</code>, <code class="highlighter-rouge">.php</code>  网页文件</p>
  </li>
</ul>

<p>文件真正的执行与否需要权限的规范，与扩展名无关。</p>

<h3 id="713-linux-文件名">7.1.3 Linux 文件名</h3>

<h4 id="文件名长度限制">文件名长度限制</h4>

<p>在 Linux 中，对于 EXT2、EXT3、EXT4 以及 XFS 文件系统，针对文件的文件名长度限制为：</p>

<p>单一文件或目录的文件名最长为 255 字节，即 255 个英文字符，或 128 个中文字符。</p>

<h4 id="文件名字符限制">文件名字符限制</h4>

<p>文件名避免特殊字符：<code class="highlighter-rouge">? &gt; &lt; ; &amp; ! [ ] | \ ' " </code> ` <code class="highlighter-rouge">（ ） { }</code></p>

<h2 id="72-linux-文件权限">7.2 Linux 文件权限</h2>

<p>Linux 文件的权限控制，一方面为了数据安全，另一方面便于文件共享。</p>

<h3 id="721-权限位">7.2.1 权限位</h3>

<p>权限也是文件元数据之一，在 Inode 中占 <strong>12 位</strong>，其中：</p>

<p><strong>普通权限</strong> 占 9 位</p>

<p><strong>特殊权限</strong> 占 3 位</p>

<h4 id="普通权限">普通权限</h4>

<h5 id="普通权限类型">普通权限类型</h5>

<p>普通权限分 <strong>读、写、执行</strong> 三种，各占 1 位。</p>

<ul>
  <li>
    <p>读：Read，用户有权读取文件内容</p>
  </li>
  <li>
    <p>写：Write，用户有权写入或修改文件内容</p>
  </li>
  <li>
    <p>执行：eXcecute，用户有权执行文件，或浏览目录中文件列表</p>
  </li>
</ul>

<figure class="">
  <img src="https://liloli.github.io/assets/images/5.2.rwx.png" alt="文件权限" />
  
</figure>

<h5 id="普通权限组">普通权限组</h5>

<p>共有三组普通权限，共 9 位，根据访问对象的不同，分别为：</p>

<ul>
  <li>
    <p>所有者：Owner，文件的所有者</p>
  </li>
  <li>
    <p>组：Group，文件的属组</p>
  </li>
  <li>
    <p>其他人：All other s，所有其他人</p>
  </li>
</ul>

<p>每个权限组都有三个完整的权限位，读、写、执行。</p>

<h4 id="特殊权限">特殊权限</h4>

<p>文件特殊权限： SUID, SGID, SBIT，各占 1 位。</p>

<h5 id="suid">SUID</h5>

<p>SUID，Set  ID，文件所有者的 <code class="highlighter-rouge">x</code> 位变成 <code class="highlighter-rouge">s</code>。</p>

<p>[ 作用 ]：</p>

<p>使普通用户可以 <strong>临时</strong> 借助程序来间接地 <strong>修改其无权访问的文件</strong>。</p>

<p>[ SUID 规则 ]：</p>

<ul>
  <li>SUID 权限仅对 <strong>二进制程序</strong> 有效</li>
  <li>用户对该程序必须有可执行权限</li>
  <li>本权限仅在程序运行 <strong>过程中</strong> 临时有效</li>
  <li>程序运行期间，执行者具有程序 <strong>所有者权限</strong></li>
</ul>

<p><strong>主要用于文件</strong>。可以为目录设置 SUID，但 linux 系统会忽略此标签。</p>

<p>查找所有 SUID/SGID 的程序</p>

<p><code class="highlighter-rouge">find / -perm /6000</code></p>

<h5 id="sgid">SGID</h5>

<p>SGID，Set Group ID，属组的 <code class="highlighter-rouge">x</code> 位变成 <code class="highlighter-rouge">s</code>。</p>

<p>SGID 可以针对 <strong>文件</strong> 或 <strong>目录</strong> 来设置，作用各不相同。</p>

<p><strong>对可执行文件</strong></p>

<p>SGID 仅对 <strong>二进制程序</strong> 有效。用户可以不属于程序属组，但对程序必须有 <code class="highlighter-rouge">x</code> 权限。</p>

<p>[ 作用 ]：</p>

<p>执行者在程序运行过程中临时获得该程序 <strong>属组的权限</strong></p>

<p><strong>对目录</strong></p>

<p>用户有权访问目录，即具有 <code class="highlighter-rouge">r x</code> 权限</p>

<p>[ 作用 ]：</p>

<p>在该目录内新建的文件或目录，均 <strong>继承其GID</strong>，而非用户的 GID。</p>

<p>在该目录新建的文件或目录，均继承其 <strong>SGID</strong>。</p>

<p>SGID 适用 <strong>多人合作同一个项目</strong>。</p>

<h5 id="sbit">SBIT</h5>

<p>Sticky Bit，其他人的 <code class="highlighter-rouge">x</code> 位变为 <code class="highlighter-rouge">t</code>。</p>

<p>SBIT 只对 <strong>目录</strong> 有效，对文件无效。</p>

<p>用户需对此目录有 <strong><code class="highlighter-rouge">w, x</code></strong> 权限</p>

<p>[ 作用 ]：</p>

<p>用户在该目录新建的文件或目录，只有 <strong>自己</strong> 与 <strong>root</strong> 有权删除</p>

<h5 id="suidsgidsbit-权限设置">SUID/SGID/SBIT 权限设置</h5>

<p>这三个特殊权限各自占用一个模式位，位于普通权限之前。</p>

<p>数字表示：</p>

<ul>
  <li>
    <p>SUID = 4</p>
  </li>
  <li>
    <p>SGID = 2</p>
  </li>
  <li>
    <p>SBIT = 1</p>
  </li>
</ul>

<p>如 4700 表示该文件权限为 SUID、u=rwx、go= 。</p>

<h3 id="722-查看文件权限">7.2.2 查看文件权限</h3>

<p><code class="highlighter-rouge">ls -l</code> 命令以详细格式列出当前目录中的所有文件。</p>

<figure class="">
  <img src="https://liloli.github.io/assets/images/5.2.ls.png" alt="文件属性" />
  
</figure>

<h3 id="723-权限表示方法">7.2.3 权限表示方法</h3>

<h4 id="用数字表示">用数字表示</h4>

<p>这是一种更接近真实文件系统结构的表示方式。</p>

<p>普通权限共 9 位，因此，实际上保存的是 9 位二进制：</p>

<p><code class="highlighter-rouge">111</code> <code class="highlighter-rouge">100</code> <code class="highlighter-rouge">100</code></p>

<p>如果把每个权限组的三位二进制数字用一个八进制数字来表示的话，一共只需 3 位数字即可，更简洁：</p>

<p><code class="highlighter-rouge">744</code></p>

<table>
  <thead>
    <tr>
      <th>八进制</th>
      <th>二进制</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>000</td>
      <td>无权限</td>
    </tr>
    <tr>
      <td>1</td>
      <td>001</td>
      <td>x</td>
    </tr>
    <tr>
      <td>2</td>
      <td>010</td>
      <td>w</td>
    </tr>
    <tr>
      <td>3</td>
      <td>011</td>
      <td>wx</td>
    </tr>
    <tr>
      <td>4</td>
      <td>100</td>
      <td>r</td>
    </tr>
    <tr>
      <td>5</td>
      <td>101</td>
      <td>rx</td>
    </tr>
    <tr>
      <td>6</td>
      <td>110</td>
      <td>rw</td>
    </tr>
    <tr>
      <td>7</td>
      <td>111</td>
      <td>rwx</td>
    </tr>
  </tbody>
</table>

<h4 id="用符号表示">用符号表示</h4>

<p>用符号表示是为了以使用者容易理解的方式，更快捷地使用。</p>

<p>如：<code class="highlighter-rouge">a+x</code>，<code class="highlighter-rouge">u+w</code>，<code class="highlighter-rouge">o-wx</code>，<code class="highlighter-rouge">u=rwx</code>，<code class="highlighter-rouge">o=</code>，<code class="highlighter-rouge">u=rwx,g=rx,o=rx</code> 等</p>

<h5 id="权限对象">权限对象</h5>

<p>在权限组的基础上，增加了一个 “所有人”。因此平时为方便，用 <code class="highlighter-rouge">ugo</code> 表示权限组。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">u</code> = ，所有者</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">g</code> = group，组</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">o</code> = others，其他人</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">a</code> = all，所有人</p>
  </li>
</ul>

<p>权限对象做为参数，如果被省略，默认为 <code class="highlighter-rouge">a</code>，即对所有人生效。</p>

<h5 id="操作符号">操作符号</h5>

<ul>
  <li>
    <p><code class="highlighter-rouge">+</code>  赋予权限</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">-</code>  去掉权限</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">=</code>  指定权限</p>
  </li>
</ul>

<h5 id="权限">权限</h5>

<p>做为参数指定时，可以是 <strong><code class="highlighter-rouge">rwxXst</code></strong> 的任意组合，也可为空。可同时指定 <strong>多个权限</strong>，用 <strong>逗号</strong> 分隔。</p>

<p class="notice--success">这里除了三种普通权限、三种特殊权限之外，又多了一个 <code class="highlighter-rouge">X</code>，但实际上它算不上一种权限，只是一个方便操作的参数。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">rwx</code> = rwx 基本权限</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">s</code> = SUID 或 SGID，替换所有者或组的 <code class="highlighter-rouge">x</code> 位</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">t</code> = SBit，替换其他人的 <code class="highlighter-rouge">x</code> 位</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">X</code></p>
  </li>
</ul>

<p><code class="highlighter-rouge">X</code> 本身并非代表权限，却可代替 <code class="highlighter-rouge">x</code> 来解决一个平时难以解决的问题：</p>

<p>为目录和可执行文件增加执行权限。</p>

<p class="notice--success">对于目录，不管其当前权限如何，<strong>为目录增加执行权限</strong>；对于文件，如果其 <code class="highlighter-rouge">ugo</code> 权限组至少有一个组有执行权限，则 <strong>为文件增加执行权限</strong>，具体生效的权限组由命令参数指定。而 <strong>本没有任何执行权限的文件会被排除</strong>，不会为其增加执行权限。</p>

<p>即，针对 <strong>大目录树</strong> 给 <strong>组或他人</strong> 设定 <strong>执行</strong> 权限，同时 <strong>避开普通文件</strong> 不设。</p>

<p>通常要加上 <strong><code class="highlighter-rouge">-R</code></strong> 参数，因为要遍历所有子目录及文件。</p>

<p>本来在这种情况下，通常会使用 <code class="highlighter-rouge">chmod -R a+rx .</code> 来实现，但这样一来，该目录及其所有文件均会被设定 <code class="highlighter-rouge">x</code>，带来了不必要的安全隐患。</p>

<p>于是可以用 <strong><code class="highlighter-rouge">chmod -R a+rX .</code></strong> 来替代。把 <code class="highlighter-rouge">x</code> 换成了 <code class="highlighter-rouge">X</code>，其效果就完全不同，本来没有任何执行权限的文件，会被排除在外。除此之外，该目录本身、其子目录、原来有可执行权限的文件，其 <code class="highlighter-rouge">ugo</code> 均会增加可执行权限。</p>

<h3 id="724-umask">7.2.4 UMASK</h3>

<h4 id="权限掩码的概念">权限掩码的概念</h4>

<p>file-creation mode mask，权限掩码，对应所有 <strong>12 个权限位</strong>。</p>

<p>当程序创建一个文件时，必须为文件设定初始的权限，权限掩码就是用来 <strong>设定初始权限</strong> 用的。</p>

<p>以数字表示时，在普通权限 3 位的基础上，最前边增加 1 位，共四位。第一位永远是 <code class="highlighter-rouge">0</code>，可以忽略，后三位代表 <code class="highlighter-rouge">ugo</code>。</p>

<p>如果掩码中有一位设定为 <strong><code class="highlighter-rouge">1</code></strong>，意味着对应的初始权限被 <strong>禁用</strong>。如果设定为 <strong><code class="highlighter-rouge">0</code></strong>，则意味着对应的权限会 <strong>由进程或系统来决定</strong>。</p>

<p>每个 <strong>进程</strong> 拥有自己的权限掩码，可以用函数调用来修改其设置。如果该进程是一个 shell，则用 <code class="highlighter-rouge">umask</code> 命令来设置。因此 <code class="highlighter-rouge">umask</code> 对权限掩码的修改往往是 <strong>临时性的</strong>。</p>

<p>如果需要 <strong>永久修改</strong> 权限掩码，则需要修改 <code class="highlighter-rouge">/etc/profile</code> 和 <code class="highlighter-rouge">/etc/bashrc</code> 中的 umask 设置。</p>

<p>子进程会 <strong>继承</strong> 父进程的权限掩码。</p>

<p>权限掩码仅影响 <strong>新建的文件</strong>，而不会影响现有的文件。</p>

<h4 id="掩码的计算">掩码的计算</h4>

<p>新建文件其权限位的最终值是使用 <strong>位操作</strong> 来计算的：</p>

<p><code class="highlighter-rouge">R: (D &amp; (~M))</code></p>

<p>即，<code class="highlighter-rouge">文件权限掩码 M 的按位非</code> 和 <code class="highlighter-rouge">默认权限 D</code> 进行按位与计算，得到结果 <code class="highlighter-rouge">最终权限 R</code>。</p>

<h5 id="默认掩码">默认掩码</h5>

<p>目录 默认权限 = 777</p>

<p>文件 默认权限 = 666</p>

<p>超级用户 默认掩码 = 022</p>

<p>普通用户 默认掩码 = 002</p>

<p>计算普通用户新建目录的权限：777 - 002 = 775</p>

<p>🍎 因此，各用户默认权限为：</p>

<ul>
  <li>
    <p>超级用户 新建目录 = <code class="highlighter-rouge">755</code></p>
  </li>
  <li>
    <p>超级用户 新建文件 = <code class="highlighter-rouge">644</code></p>
  </li>
  <li>
    <p>普通用户 新建目录 = <code class="highlighter-rouge">775</code></p>
  </li>
  <li>
    <p>普通用户 新建文件 = <code class="highlighter-rouge">664</code></p>
  </li>
</ul>

<h4 id="语法">语法</h4>

<p><code class="highlighter-rouge">umask</code> 程序用于控制 <strong>文件权限掩码</strong>，它决定了当前 <strong>进程</strong> 新建文件时 <strong>文件默认权限</strong>。</p>

<p><code class="highlighter-rouge">umask [ -S ] [ Mask ]</code></p>

<p><code class="highlighter-rouge">-S</code>	用符号表示当前权限掩码</p>

<p>如果不带参数运行，<code class="highlighter-rouge">umask</code> 命令直接显示当前掩码</p>

<h4 id="范例">范例</h4>

<p><code class="highlighter-rouge">umask a=rx,ug+w</code>	以符号方式设置</p>

<p><code class="highlighter-rouge">umask 002</code>	以数字方式设置</p>

<p><code class="highlighter-rouge">umask -S</code>	以符号方式显示当前设置</p>

<p><code class="highlighter-rouge">umask g-w</code>		组去掉修改权限</p>

<p><code class="highlighter-rouge">umask -- -w</code>	所有人去掉修改权限</p>

<h3 id="725-修改文件权限">7.2.5 修改文件权限</h3>

<ul>
  <li>
    <p>chgrp ：修改文件属组</p>
  </li>
  <li>
    <p>chown ：修改文件所有者</p>
  </li>
  <li>
    <p>chmod ：修改文件权限</p>
  </li>
</ul>

<h4 id="chgrp">CHGRP</h4>

<p>修改文件属组。</p>

<p><code class="highlighter-rouge">chgrp [参数] 组 文件</code></p>

<p><code class="highlighter-rouge">-R</code>	递归处理，将指定目录下的所有文件及子目录一并处理</p>

<p><code class="highlighter-rouge">-v</code>	显示命令执行过程</p>

<p><code class="highlighter-rouge">--reference=</code>	把指定文件或目录的所属群组全部改为和参考文件或目录的所属群组相同</p>

<ul>
  <li>范例</li>
</ul>

<p><code class="highlighter-rouge">chgrp -R newgroup file</code></p>

<h4 id="chgown">CHGOWN</h4>

<p>修改文件的所有者。</p>

<p><code class="highlighter-rouge">chown [参数] 用户 文件</code></p>

<p><code class="highlighter-rouge">-R</code>	递归处理，将指定目录下的所有文件及子目录一并处理</p>

<p><code class="highlighter-rouge">-v</code>	显示命令执行过程</p>

<p><code class="highlighter-rouge">--reference=</code>	把指定文件或目录的所属群组全部改为和参考文件或目录的所属群组相同</p>

<ul>
  <li>范例</li>
</ul>

<p><code class="highlighter-rouge">chown -R  file</code>  修改所有者</p>

<p><code class="highlighter-rouge">chown -R new:newgroup file</code>  修改所有者及属组</p>

<p><code class="highlighter-rouge">chown -R :newgroup file</code>  修改属组，同 chgrp</p>

<p class="notice--primary">把文件复制给其它组或人时，需要修改所有者及属组，以便对方有权访问。</p>

<h4 id="chmod">CHMOD</h4>

<p><code class="highlighter-rouge">chmod</code> 用于修改文件的权限位。</p>

<p><code class="highlighter-rouge">chmod [参数] 文件名</code></p>

<ul>
  <li>范例</li>
</ul>

<p><code class="highlighter-rouge">chmod -R 777 /path/</code> 递归修改目录中所有文件</p>

<p><code class="highlighter-rouge">chmod u=rwx,go=rx file</code></p>

<p><code class="highlighter-rouge">chmod a+w file</code></p>

<p><code class="highlighter-rouge">chmod a-x file</code></p>

<h2 id="73-文件权限-vs-目录权限">7.3 文件权限 vs 目录权限</h2>

<p>Linux 系统中，因为文件名与实际数据是分开保存的，于是，<strong>针对文件名的权限</strong> 与 <strong>针对文件数据的权限</strong> 被彻底 <strong>分开管理</strong>。</p>

<p class="notice--success">具体来说，文件名由 <strong>目录项</strong> 控制，文件数据由 <strong>文件 Inode</strong> 控制。</p>

<h3 id="731-文件的权限">7.3.1 文件的权限</h3>

<p>文件的权限影响的是对 <strong>文件数据</strong> 的操作。</p>

<ul>
  <li>
    <p>r = 可读取文件内容</p>
  </li>
  <li>
    <p>w = 可编辑、新增、修改（不含删除）；</p>
  </li>
  <li>
    <p>x = 可被执行</p>
  </li>
</ul>

<h3 id="732-目录的权限">7.3.2 目录的权限</h3>

<p>目录的权限影响的是对目录对象的 <strong>文件名</strong> 及 <strong>文件 Inode</strong> 的操作。</p>

<h4 id="目录文件">目录文件</h4>

<p>为了生成目录树，文件系统会把文件名保存在目录文件中。</p>

<h5 id="目录文件结构">目录文件结构</h5>

<p>同其他文件一样，每个 <strong>目录文件</strong> 也有一个自己的 <strong>Inode</strong>，其中保存了目录文件的所有 <strong>元数据</strong>，包括 “数据块指针，权限，所有者，修改时间” 等。</p>

<p><strong>目录文件的数据块</strong> 中保存的是其独特的文件内容：<strong>目录项</strong>，即 <code class="highlighter-rouge">文件名 - Inode 编号</code> 形式的数据，仅此而已。</p>

<p>而目录项中的文件名，其真实的文件属性，以及其数据块的指针都保存在它自己的 Inode 当中。</p>

<p>一个文件的文件名和其属性、数据就这样被分割开来，很大程度上保证了数据的安全。</p>

<h5 id="目录损坏">目录损坏</h5>

<p class="notice--success">目录文件中的 <strong>目录项</strong> 是系统中文件名和真实数据 <strong>唯一的连接</strong>。</p>

<p>如果目录文件的 Inode 或数据块被损坏，通常只是丢失了文件名，这些文件的真实数据及属性因为保存在其它的块中，很有可能没有丢失。此时，文件的 Inode 变成了孤儿，可以用 <code class="highlighter-rouge">fsck</code> 等工具来恢复这些文件数据。</p>

<h5 id="文件属性">文件属性</h5>

<p>读取目录文件，只能获得文件名和 Inode 编号，无法得知文件的属性（文件类型、所有者、权限、修改时间、大小等），要想了解这些信息，用户须有权访问该文件的 Inode。根据目录项中的 Inode 编号，找到该文件的 Inode，就可以查看其中保存的各个元数据。</p>

<p>正因为如此，查看文件的属性需要额外的操作，所以 <code class="highlighter-rouge">ls -i</code> 会比 <code class="highlighter-rouge">ls -l</code> 更快地返回结果，目录越复杂效果越明显。</p>

<h5 id="递归目录树">递归目录树</h5>

<p>系统如何通过一个绝对路径来查找文件的真实数据?</p>

<p>从根目录开始，根目录文件的 Inode 编号均为 2，如果对根目录有执行权限，则可以查看根目录的 Inode，通过其中的指针找到根目录文件数据块，查看文件内容（目录项列表），从中找到二级目录及其 Inode 编号；</p>

<p>如果有执行权限，则可查看二级目录 Inode，通过指针找到二级目录文件数据块，查看目录项列表，在目录项列表中继续查找下一级目录。</p>

<p>重复以上步骤，直到从目录项中找到文件名。</p>

<figure class="">
  <img src="https://liloli.github.io/assets/images/dir.recursive.png" alt="递归目录树" />
  
</figure>

<h4 id="目录文件的权限">目录文件的权限</h4>

<h5 id="读权限">读权限</h5>

<ul>
  <li>有权读取目录项</li>
</ul>

<p>如果对目录只有读取权限，则允许 <strong>读取该目录中的文件名</strong>，用 <code class="highlighter-rouge">ls -l</code> 能够查看目录中的文件列表，但所有的属性均无法显示，用 <code class="highlighter-rouge">?</code> 占位。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp]<span class="nv">$ </span>ll tt
<span class="nb">ls</span>: cannot access tt/a: Permission denied
<span class="nb">ls</span>: cannot access tt/c: Permission denied
total 0
-????????? ? ? ? ?            ? a
-????????? ? ? ? ?            ? c
</code></pre></div></div>

<p>无法显示文件属性的原因是：无权读取目录中所有文件的 Inode。</p>

<h5 id="写权限">写权限</h5>

<p>写权限要想生效，需要同时 <strong>有执行权限</strong>。如果没有执行权限，则单纯的写权限无任何意义。</p>

<p class="notice--warning">为什么必须有执行权限的配合，写权限才能生效？因为涉及到两个因素，一个是新建、移动、删除文件以后，需要对文件 Inode 中的链接数的更新；另一个是重命名文件时，<code class="highlighter-rouge">rename</code> 的系统调用需要前后两个路径名称（pathnames）做参数，路径名称的获得要靠执行权限通过对目录树的递归来获得。</p>

<ul>
  <li>有权修改目录文件属性及目录项</li>
</ul>

<p><strong>新建</strong> 文件：增加目录项</p>

<p><strong>重命名</strong> 已存在的文件：修改目录项</p>

<p><strong>删除</strong> 现有文件：删除目录项</p>

<p><strong>移动</strong> 目录中的文件：修改或删除目录项</p>

<h5 id="执行权限">执行权限</h5>

<ul>
  <li>有权访问目录项中的 <strong>Inode</strong>。</li>
</ul>

<p>最形象的描述：对目录的执行权限，允许 <strong>穿透该目录</strong>，或 <strong>进入该目录</strong>。</p>

<p>访问目录中文件或子目录文件的 Inode，可以查看文件属性、权限、修改日期、所有者等，同时还可以通过指针来查看文件的数据块的内容。如果是目录文件（子目录），就可以查看子目录中的文件列表，从而 <strong>递归目录树</strong>，最后，逐级找到目标文件的 Inode，因此执行权限也叫 <strong>搜索权限</strong>，。</p>

<p class="notice--warning">因此，结合上文的 “系统查找文件的流程”，用户要想访问某一个文件，其上层的每一级目录必须都对用户开放执行权限，否则文件系统就无法找到文件的 Inode。</p>

<p>允许 <strong>将目录做为工作目录</strong>，可以 <code class="highlighter-rouge">cd</code> 进入，并可以 <strong>访问文件</strong>。</p>

<p>该权限对于以下操作是必需的：</p>

<ul>
  <li>
    <p>访问其中的文件，包括读、写、执行。</p>
  </li>
  <li>
    <p>新建、重命名、删除文件</p>
  </li>
</ul>

<p class="notice--success">🌟 如果用户对 <strong>目录</strong> 有 <strong>写、执行</strong> 权限，即使他对目录中的文件没有任何权限，也能轻松地 <strong>删除文件</strong>。这种情况可以用 <strong>SBIT</strong> 来化解。</p>

<p class="notice--success">🌟 如果用户对 <strong>目录</strong> 只有 <strong>执行</strong> 权限，对 <strong>文件</strong> 有 <strong>写</strong> 权限，他 <strong>无法删除</strong> 文件，却可以往文件中 <strong>写入数据</strong>，如 <code class="highlighter-rouge">echo &gt; 'something new'</code> 或 <code class="highlighter-rouge">echo &gt;&gt; 'something newer'</code>。但无法用 <code class="highlighter-rouge">cat</code> 查看文件内容，如果对文件有了 <strong>读</strong> 权限，就可以查看内容，同时也可以用 <code class="highlighter-rouge">vi</code> 来直接编辑文件内容。</p>

<h5 id="sbit-1">SBIT</h5>

<p>该目录中的对象，除超级用户以外，<strong>只能由其所有者本人删除</strong>，其他人无权删除。</p>

<h3 id="733-文件权限与目录权限对比">7.3.3 文件权限与目录权限对比</h3>

<figure class="">
  <img src="https://liloli.github.io/assets/images/directory.perms.png" alt="目录文件权限的作用" />
  
    <figcaption>目录文件权限的作用
</figcaption>
  
</figure>

<p>文件操作所需权限：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">/dir1</th>
      <th style="text-align: left">/dir1/file1</th>
      <th style="text-align: left">/dir2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">查看 file1 内容</td>
      <td style="text-align: left">x</td>
      <td style="text-align: left">r</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: left">修改 file1 内容</td>
      <td style="text-align: left">x</td>
      <td style="text-align: left">rw</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: left">执行 file1</td>
      <td style="text-align: left">x</td>
      <td style="text-align: left">rx</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: left">删除 file1</td>
      <td style="text-align: left">wx</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: left">将 file1 复制到 /dir2</td>
      <td style="text-align: left">x</td>
      <td style="text-align: left">r</td>
      <td style="text-align: left">wx</td>
    </tr>
  </tbody>
</table>

<p class="notice--success">如果目录文件没有 <code class="highlighter-rouge">r</code> 权限，只是无法查看文件列表（文件名）而已。只要有 <code class="highlighter-rouge">wx</code>，并知道文件名，就可以进行文件的读取、修改、执行、删除、复制等操作。</p>

<h2 id="74-文件的属性">7.4 文件的属性</h2>

<h3 id="741-chattr">7.4.1 CHATTR</h3>

<p><code class="highlighter-rouge">chattr</code> 命令用于修改文件属性，是 EXT 时期的工具，在 XFS 中仅支持部份参数。</p>

<h5 id="语法-1">语法</h5>

<p><code class="highlighter-rouge">chattr [ -RVf ] [ -v version ] [ -p project ] [ mode ] files...</code></p>

<p><code class="highlighter-rouge">A</code>	<strong>锁定 atime</strong>，可减少 I/O。</p>

<p><code class="highlighter-rouge">a</code>	<strong>只能追加</strong> 内容，不能删除文件，不能修改，限 <strong>超级用户</strong> 使用</p>

<p><code class="highlighter-rouge">d</code>	不被 dump 备份</p>

<p><code class="highlighter-rouge">i</code>	禁止 <strong>删除、改名、链接、修改</strong>，限 <strong>超级用户</strong> 使用</p>

<p><code class="highlighter-rouge">S</code>	将文件的修改 <strong>同步</strong> 写入磁盘。</p>

<p class="notice--warning">EXT 文件系统支持所有参数，XFS 仅支持以上 <code class="highlighter-rouge">AadiS</code> 5 个参数。</p>

<p><code class="highlighter-rouge">c</code>	读之前自动解压，写之前先压缩</p>

<p><code class="highlighter-rouge">s</code>	如果删除文件，会被完全移除出硬盘空间，无法恢复</p>

<p><code class="highlighter-rouge">u</code>	删除文件后，数据仍存在磁盘，可以恢复</p>

<ul>
  <li>范例</li>
</ul>

<p><code class="highlighter-rouge">sudo chattr +i file</code>	锁定文件，禁止改名、修改、删除、链接</p>

<p><code class="highlighter-rouge">sudo chattr +a file</code>	文件只允许追加内容，不能删除、修改</p>

<p><code class="highlighter-rouge">chattr +d file</code>	不被 dump 备份</p>

<p><code class="highlighter-rouge">chattr +A file</code>	锁定 atime，减少 IO</p>

<p><code class="highlighter-rouge">chattr +S file</code>	有变化时 <strong>同步</strong> 写入磁盘</p>

<h4 id="lsattr">LSATTR</h4>

<p>查看文件属性</p>

<p><code class="highlighter-rouge">lsattr [-adR] 文件或目录</code></p>

<p><code class="highlighter-rouge">-a</code>	包括隐藏文件</p>

<p><code class="highlighter-rouge">-d</code>	仅列出目录本身的属性</p>

<p><code class="highlighter-rouge">-R</code>	包括子目录</p>

<h3 id="742-扩展属性">7.4.2 扩展属性</h3>

<h4 id="扩展属性概念">扩展属性概念</h4>

<p>扩展属性由 <strong><code class="highlighter-rouge">属性名：值</code></strong> 这样成对的信息组成，可以永久地关联到文件和目录上。可以定义一个属性，也可以取消定义。如果属性被定义，其值 <strong>允许为空</strong>。</p>

<p>普通的文件属性通常于系统中所有的 Inode 关联，扩展属性是普通属性的扩充。经常用来 <strong>为文件系统提供额外的功能</strong>。比如可以扩展 ACL 额外的安全特性。</p>

<p>对文件或目录有搜索权限的用户，可以查看其属性列表。</p>

<p>支持扩展属性的文件系统主要有 EXT，XFS，JFS 等。</p>

<p><code class="highlighter-rouge">cp</code>、<code class="highlighter-rouge">rsync</code> 等类似的命令，默认不会保留原文件的扩展属性，需要加特定的参数：</p>

<p><code class="highlighter-rouge">cp -a</code>，<code class="highlighter-rouge">rsync -X</code>。</p>

<h4 id="扩展属性的命名空间">扩展属性的命名空间</h4>

<p>属性名称是以非 0 字符结束的字符串，属性名称必须符合 <code class="highlighter-rouge">命名空间.属性</code> 的格式，如 <code class="highlighter-rouge">.mime_type</code>, <code class="highlighter-rouge">trusted.md5sum</code>, <code class="highlighter-rouge">system.posix_acl_access</code>, <code class="highlighter-rouge">security.selinux</code>。</p>

<p>命名空间的机制是为了定义不同类别的扩展属性，之所以要分类，是因为控制每一类命名空间的扩展属性，所需要的 <strong>权限</strong> 和带来的 <strong>功能</strong> 是不同的。</p>

<p>共有四类扩展属性：安全（security）、系统（system）、信任（trusted）、用户（）</p>

<h5 id="扩展安全属性">扩展安全属性</h5>

<p>扩展安全属性其命名空间由内核的安全模块使用，如 SELinux。对安全属性的读、写权限决定于安全模块对每个安全属性部署的策略。如果没有安全模块被加载，所有进程对扩展安全属性都有读取权限，有 <code class="highlighter-rouge">CAP_SYS_ADMIN</code> 能力（capability）的进程则有写的权限。</p>

<h5 id="扩展系统属性">扩展系统属性</h5>

<p>内核使用扩展系统属性来保存系统对象，如 ACL、Capabilities。读、写权限决定于文件系统在内核中，针对每一个系统属性所部署的策略。</p>

<h5 id="可信扩展属性">可信扩展属性</h5>

<p>只有具备 <code class="highlighter-rouge">CAP_SYS_ADMIN</code> 能力的进程才能看到，并可读取可信扩展属性，通常是超级用户才有这个能力。这类属性用于在用户空间部署机制，在扩展属性中保存的信息是普通的进程本来无法访问的。</p>

<h5 id="扩展用户属性">扩展用户属性</h5>

<p>扩展用户属性可以用来给文件和目录附加一些任意的信息，如 mime 类型、文件的字符集、文件的编码等。对于用户属性的访问权限由文件的权限位控制。</p>

<p>普通文件及目录其权限位所代表的意思，与特殊文件及符号链接其权限位所代表的意思有所不同：</p>

<p>对于 <strong>普通文件及目录</strong>，其权限位定义了对 <strong>文件内容</strong> 的访问；</p>

<p>对于 <strong>设备文件</strong>，其权限位定义的是对于其所描述的 <strong>设备</strong> 的访问；</p>

<p>对于 <strong>符号链接</strong>，其权限位在访问权限检查中 <strong>不起作用</strong>。</p>

<p>这些区别将允许用户消耗文件系统资源时，不受磁盘配额的控制。基于这个原因，扩展用户属性仅限于普通文件和目录使用，并且只有 <strong>所有者</strong> 或 <strong>SBIT</strong> 有权访问。</p>

<h4 id="文件系统应用区别">文件系统应用区别</h4>

<p>内核与文件系统会限制扩展属性的数量及大小。</p>

<p>EXT2、EXT3、REISERFS 这些文件系统在挂载时必须使用 <code class="highlighter-rouge">_xattr</code> 参数，扩展属性才能启用。</p>

<p>EXT 中，每个扩展属性不能超过一个块大小。</p>

<p>在 XFS、REISERFS 中，对扩展属性的数量和大小没有限制，而且用于保存扩展属性的磁盘空间可以随时调整。</p>

<h4 id="setfattr">SETFATTR</h4>

<p>使用 <code class="highlighter-rouge">setfattr</code> 来设置扩展属性</p>

<p><code class="highlighter-rouge">setfattr [-h] -n name [-v value] pathname...</code></p>

<p><code class="highlighter-rouge">-n</code>	指定属性名，用户扩展属性必须用前缀 <code class="highlighter-rouge">.</code> 来命名</p>

<p><code class="highlighter-rouge">-v</code>	指定属性的值</p>

<p><code class="highlighter-rouge">-x</code>	删除指定扩展属性，接属性名</p>

<ul>
  <li>范例</li>
</ul>

<p><code class="highlighter-rouge">setfattr -n .cell -v "13099999999" file</code></p>

<h2 id="75-acl-权限控制">7.5 ACL 权限控制</h2>

<p>Linux 传统的权限控制是针对文件的，而无法 <strong>针对某一个用户或某一个组</strong>。</p>

<h3 id="751-acl-简介">7.5.1 ACL 简介</h3>

<p>Access Control List</p>

<p>ACL 分两类：<code class="highlighter-rouge">访问 ACL</code> 和 <code class="highlighter-rouge">默认 ACL</code></p>

<p><strong>访问 ACL</strong> 用于控制特定文件或目录的访问权限。</p>

<p><strong>默认 ACL</strong> 是专门针对目录的，用于控制目录中新建的文件其默认的访问 ACL。</p>

<p>如果某文件没有访问 ACL，它会使用所在目录的默认 ACL。</p>

<p>默认 ACL 是可选的。</p>

<h4 id="acl-条目的结构">ACL 条目的结构</h4>

<p>ACL 是由一系列的访问条目（Access Entry）组成，而每个访问条目又由三部分组成：</p>

<p><code class="highlighter-rouge">Entry Tag Type</code> : <code class="highlighter-rouge">Qualifier</code> : <code class="highlighter-rouge">Permission</code></p>

<p class="notice--info"><code class="highlighter-rouge">条目标签类型</code> : <code class="highlighter-rouge">特定对象</code>（可选） : <code class="highlighter-rouge">权限</code></p>

<h5 id="条目标签类型">条目标签类型</h5>

<p><code class="highlighter-rouge">ACL_</code> 和 <code class="highlighter-rouge">ACL_GROUP</code> 开头的类型需指定具体的用户或组，其它类型则不用。
。</p>

<p><code class="highlighter-rouge">ACL__OBJ</code>：文件 <strong>所有者</strong></p>

<p><code class="highlighter-rouge">ACL_</code>：<strong>特定用户</strong></p>

<p><code class="highlighter-rouge">ACL_GROUP_OBJ</code>：文件 <strong>属组</strong></p>

<p><code class="highlighter-rouge">ACL_GROUP</code>：<strong>特定组</strong></p>

<p><code class="highlighter-rouge">ACL_MASK</code>：<strong>有效权限掩码</strong>，用于限制除所有者以外的，其他用户或组的 <strong>最大权限</strong></p>

<p><code class="highlighter-rouge">ACL_OTHER</code>：其他人的权限</p>

<h5 id="特定对象">特定对象</h5>

<p>指的就是要设定权限的具体的对象，即具体的用户或组，可以是用户名或组名，也可以是 UID 或 GID。</p>

<h5 id="权限-1">权限</h5>

<p>权限可以用符号表示，也可以用数字表示。</p>

<h4 id="条目的格式">条目的格式</h4>

<p><code class="highlighter-rouge">u:&lt;用户&gt;:&lt;权限&gt;</code>	为 <strong>用户</strong> 设置 ACL，可以指定用户名或 UID</p>

<p><code class="highlighter-rouge">g:&lt;组&gt;:&lt;权限&gt;</code> 为 <strong>组</strong> 设置 ACL，可以指定组名或 GID</p>

<p><code class="highlighter-rouge">m:&lt;权限&gt;</code> 设置 <strong>有效权限掩码</strong></p>

<p><code class="highlighter-rouge">o:&lt;权限&gt;</code> 为组以外的 <strong>其他人</strong> 设置 ACL。</p>

<p>如果有多个条目，可以用逗号分隔。</p>

<h4 id="acl-使用规范">ACL 使用规范</h4>

<ul>
  <li>
    <p>每个 ACL 至少包括三个条目，即所有者、属组、其他人的权限。</p>
  </li>
  <li>
    <p>针对特定用户的条目为可选</p>
  </li>
  <li>
    <p>如果指定了特定用户或组，则必须指定有效权限掩码的权限</p>
  </li>
  <li>
    <p>如果没有指定任何特定用户或组，则有效权限掩码为可选</p>
  </li>
  <li>
    <p>针对同一特定用户或组的条目不能超过一条</p>
  </li>
</ul>

<h4 id="acl-与权限位">ACL 与权限位</h4>

<p>由 ACL 定义的权限 是 文件权限位定义的权限 的 <strong>超集</strong>，即 ACL 权限 <strong>包括</strong> 文件普通权限。</p>

<p>在文件的所有者、属组和其他人的权限与特定的 ACL 权限之间有对应的关系：</p>

<ul>
  <li>
    <p>所有者权限 = <code class="highlighter-rouge">ACL__OBJ</code></p>
  </li>
  <li>
    <p>如果有 <code class="highlighter-rouge">ACL_MASK</code>，属组权限 = <code class="highlighter-rouge">ACL_MASK</code>；如果没有，属组权限 = <code class="highlighter-rouge">ACL_GROUP_OBJ</code></p>
  </li>
  <li>
    <p>其他人权限 = <code class="highlighter-rouge">ACL_OTHER_OBJ</code></p>
  </li>
</ul>

<p class="notice--warning"><code class="highlighter-rouge">ugo</code> 的权限 <strong>永远</strong> 与对应的 ACL 条目相 <strong>匹配</strong>。修改文件权限会导致对应的 ACL 条目的改变，修改 ACL 条目同样会导致文件权限的改变。</p>

<h4 id="acl-对象的建立与默认-acl">ACL 对象的建立与默认 ACL</h4>

<p>当运行 <code class="highlighter-rouge">creat()</code>、<code class="highlighter-rouge">mkdir()</code>、<code class="highlighter-rouge">mknod()</code>、<code class="highlighter-rouge">mkfifo()</code>、<code class="highlighter-rouge">open()</code> 等函数时，文件对象的访问 ACL 会被初始化。</p>

<ul>
  <li>
    <p>如果有默认 ACL 与目录关联，用来新建文件的函数所用的 <code class="highlighter-rouge">mode</code> 参数，以及目录的默认 ACL 被用来决定新建对象的 ACL：</p>

    <ol>
      <li>
        <p>新建对象会继承目录的默认 ACL，将其做为自己的访问 ACL</p>
      </li>
      <li>
        <p>访问 ACL 条目对应的文件权限位会被修改，以保证其权限符合 <code class="highlighter-rouge">mode</code> 参数的要求</p>
      </li>
    </ol>
  </li>
  <li>
    <p>如果没有默认 ACL 与目录关联，<code class="highlighter-rouge">mode</code> 参数和 <code class="highlighter-rouge">umask</code> 会被用来决定新建对象的 ACL：</p>

    <ol>
      <li>
        <p>新建对象被分配给一个访问 ACL，其中包括 <code class="highlighter-rouge">ACL__OBJ</code>, <code class="highlighter-rouge">ACL_GROUP_OBJ</code>, <code class="highlighter-rouge">ACL_OTHER</code> 这三种类型的条目，这些条目的权限根据 <code class="highlighter-rouge">umask</code> 来设定。</p>
      </li>
      <li>
        <p>对应文件权限位的 ACL 条目会被修改，以保证其权限符合 <code class="highlighter-rouge">mode</code> 参数的要求</p>
      </li>
    </ol>
  </li>
</ul>

<h4 id="访问权限检查机制">访问权限检查机制</h4>

<p>进程会针对由 ACL 保护的文件对象发起 <strong>读、写、执行、查找</strong> 的访问请求。访问检查机制会判断是否准许该请求。</p>

<figure class="">
  <img src="https://liloli.github.io/assets/images/acl.algorithm.png" alt="ACL 检查机制" />
  
</figure>

<h4 id="acl-对文件操作的影响">ACL 对文件操作的影响</h4>

<p>在支持 ACL 的系统中，<code class="highlighter-rouge">ls</code>，<code class="highlighter-rouge">cp</code>，<code class="highlighter-rouge">mv</code> 这些命令的行为会发生变化：</p>

<ul>
  <li>
    <p>如果文件含有默认 ACL，或其访问 ACL 包含三个基本条目以外的 <strong>额外条目</strong>，<code class="highlighter-rouge">ls -l</code> 命令会在权限后面 <strong>显示加号</strong> <code class="highlighter-rouge">+</code>。</p>
  </li>
  <li>
    <p>如果 <strong><code class="highlighter-rouge">cp</code></strong> 命令使用了 <strong><code class="highlighter-rouge">-p</code></strong> 参数，则会在复制时 <strong>保留 ACL</strong></p>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">mv</code></strong> 命令 <strong>始终会保留 ACL</strong></p>
  </li>
</ul>

<h3 id="752-acl-的查看">7.5.2 ACL 的查看</h3>

<h4 id="查看当前系统是否支持-acl">查看当前系统是否支持 ACL</h4>

<p><code class="highlighter-rouge">dmesg | grep -i acl</code></p>

<h4 id="getfacl">GETFACL</h4>

<p><code class="highlighter-rouge">getfacl</code>  用于查看文件的 ACL 条目</p>

<p><code class="highlighter-rouge">getfacl filename</code></p>

<h3 id="733-acl-的设置">7.3.3 ACL 的设置</h3>

<h4 id="acl-的启用">ACL 的启用</h4>

<ul>
  <li>对文件或目录应用 ACL 之前，相应的分区通常需要以支持 ACL 的方式挂载。</li>
</ul>

<p>可以在 <code class="highlighter-rouge">/etc/fstab</code> 中的条目中，加上 <code class="highlighter-rouge">acl</code> 参数。</p>

<p><code class="highlighter-rouge">LABEL=/work      /work       ext3    acl        1 2</code></p>

<ul>
  <li>当前的大部分发行版已经默认开启了 ACL</li>
</ul>

<p><code class="highlighter-rouge">dmesg | grep -i acl</code> 可以查看当前系统是否支持 ACL。</p>

<h4 id="setfacl-语法">SETFACL 语法</h4>

<p><code class="highlighter-rouge">setfacl</code> 用于设置、修改、删除普通文件和目录的访问控制列表。</p>

<p><code class="highlighter-rouge">setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名</code></p>

<p><code class="highlighter-rouge">setfacl -m &lt;条目&gt; &lt;文件&gt;</code></p>

<h5 id="选项">选项</h5>

<p><code class="highlighter-rouge">-m</code>  <strong>修改</strong> ACL 条目</p>

<p><code class="highlighter-rouge">-x</code>  <strong>删除</strong> ACL 条目</p>

<p><code class="highlighter-rouge">-b</code>  <strong>删除所有</strong> 的 ACL 设置</p>

<p><code class="highlighter-rouge">-R</code>  <strong>递归</strong> 设置 ACL</p>

<p><code class="highlighter-rouge">-d</code>  设置目录的 <strong>默认 ACL</strong></p>

<p><code class="highlighter-rouge">-k</code>  <strong>删除默认 ACL</strong></p>

<p><code class="highlighter-rouge">--set</code> 和 <code class="highlighter-rouge">--set-file</code> 用于设置文件或目录的 ACL 条目，先前的设定将被覆盖</p>

<p><code class="highlighter-rouge">-M</code> 修改 ACL 条目，<strong>从文件或 STDIN 读取</strong> ACL 条目</p>

<p><code class="highlighter-rouge">-X</code> 删除 ACL 条目，<strong>从文件或 STDIN 读取</strong> ACL 条目</p>

<p class="notice">当使用 <code class="highlighter-rouge">-M</code>，<code class="highlighter-rouge">-X</code> 选项从文件中读取规则时，<code class="highlighter-rouge">setfacl</code> 接受 <code class="highlighter-rouge">getfacl</code> 命令输出的格式。每行至少一条规则，以 <code class="highlighter-rouge">#</code> 开始的行将被视为注释。</p>

<h4 id="范例-1">范例</h4>

<ul>
  <li>为指定用户设定权限</li>
</ul>

<p><code class="highlighter-rouge">setfacl -m u:1:rx file</code></p>

<ul>
  <li>为文件所有者设定权限</li>
</ul>

<p><code class="highlighter-rouge">setfacl -m u::rwx file</code></p>

<p><code class="highlighter-rouge">u</code> 后面留空，表示针对文件 <strong>所有者</strong>。</p>

<ul>
  <li>为指定用户设定权限，空</li>
</ul>

<p><code class="highlighter-rouge">setfacl -m u:pro3:- /srv/projecta</code></p>

<p>设置用户对目录 <strong>无任何权限</strong>，权限字段用 <strong><code class="highlighter-rouge">-</code></strong>，不能留空。</p>

<ul>
  <li>为指定组设定权限</li>
</ul>

<p><code class="highlighter-rouge">setfacl -m g:mygroup1:rx file</code></p>

<ul>
  <li>设定有效权限掩码</li>
</ul>

<p><code class="highlighter-rouge">setfacl -m m:r file</code></p>

<p class="notice--success">借助 mask 来设定最大权限，可以避免权限误分配。</p>

<ul>
  <li>删除指定用户权限</li>
</ul>

<p><code class="highlighter-rouge">setfacl -x u:500 /project/somefile</code></p>

<ul>
  <li>为目录设定默认 ACL</li>
</ul>

<p>通过设置目录对于特定用户的默认权限，使这些用户在目录内新建的文件能够继承其 ACL。</p>

<p>只需在规则前加上 <code class="highlighter-rouge">d:</code></p>

<p><code class="highlighter-rouge">setfacl -m d:u:my1:rx /srv/projecta</code></p>

<h2 id="76-切换用户">7.6 切换用户</h2>

<h3 id="761-帐号与系统安全">7.6.1 帐号与系统安全</h3>

<p>养成良好的工作习惯，是保证系统安全的第一步。</p>

<ul>
  <li>
    <p>以普通用户进行日常工作，需要时才切换为超级用户</p>
  </li>
  <li>
    <p>用较低权限的系统帐号启动系统服务</p>
  </li>
  <li>
    <p>设置程序禁止用 root 登陆</p>
  </li>
</ul>

<h3 id="762-su">7.6.2 SU</h3>

<p><code class="highlighter-rouge">su</code> 在某个登陆会话中，变成其他用户。</p>

<p><code class="highlighter-rouge">su [options] [name]</code></p>

<p>如果不指定用户名，则会切换到 root。</p>

<p><code class="highlighter-rouge">-c command</code> 临时使用指定用户的 shell 运行命令</p>

<p><code class="highlighter-rouge">-</code>/<code class="highlighter-rouge">-l</code>  以 login shell 方式切换，提供该用户登陆后的环境。</p>

<p><code class="highlighter-rouge">-m</code>  保留当前的环境变量（$PATH, $IFS 除外）</p>

<h4 id="范例-2">范例</h4>

<p><code class="highlighter-rouge">su</code></p>

<p>以 non-login shell 方式切换 root，环境变量仍为原用户的</p>

<p><code class="highlighter-rouge">su -</code></p>

<p>用 login shell 切换 root，环境变量更新为 root 的</p>

<p><code class="highlighter-rouge">su - -c "head -n 3 /etc/shadow"</code></p>

<p>临时用 root 身份执行，命令完成之后仍是原身份</p>

<p><code class="highlighter-rouge">su -l user1</code></p>

<p>以 login shell 方式切换为其他用户，获得新用户环境变量</p>

<h3 id="763-sudo">7.6.3 <code class="highlighter-rouge">sudo</code></h3>

<p><code class="highlighter-rouge">sudo</code> 会根据现有安全策略，允许特定用户以他人身份执行命令。</p>

<p>系统会使用用户的真实 UID 来比对安全策略。</p>

<p><code class="highlighter-rouge">sudo</code> 支持插件，可以使用第三方插件无缝地使用自定义安全策略，并可记录 I/O 日志。</p>

<p>默认的安全策略保存在 <code class="highlighter-rouge">/etc/sudoers</code>。安全策略决定了用户可以享有的特权，并规定了用户如何验证身份，可以使用密码或其他验证机制，同时可设置超时退出。</p>

<p>可以在安全策略中设置证书缓存的时间，在此期间使用 <code class="highlighter-rouge">sudo</code> 无需再次输入密码，默认为 5 分钟。使用 <code class="highlighter-rouge">sudo -v</code> 可以更新证书缓存。</p>

<h4 id="语法-2">语法</h4>

<p><code class="highlighter-rouge">sudo [-b] [-u 新用户帐号]</code></p>

<p><code class="highlighter-rouge">-b</code>   把命令置于后台运行</p>

<p><code class="highlighter-rouge">-u</code>   指定切换的用户，省略则切换为 root</p>

<h4 id="范例-3">范例</h4>

<ul>
  <li>以其他身份创建文件</li>
</ul>

<p><code class="highlighter-rouge">sudo -u sshd touch /tmp/mysshd</code></p>

<ul>
  <li>以其他身份执行脚本</li>
</ul>

<p><code class="highlighter-rouge">sudo sh -c "cd /home ; du -s * | sort -rn &gt; USAGE"</code></p>

<h4 id="sudo-执行的流程"><code class="highlighter-rouge">sudo</code> 执行的流程</h4>

<ol>
  <li>
    <p>当用户执行 <code class="highlighter-rouge">sudo</code> 时，系统检查 <code class="highlighter-rouge">/etc/sudoers</code> 文件，以确定该用户有权限。</p>
  </li>
  <li>
    <p>确定用户权限后，如不是 root，要求用户输入用户自己的密码。</p>
  </li>
  <li>
    <p>若密码正确，开始执行 <code class="highlighter-rouge">sudo</code> 后面的命令。</p>
  </li>
  <li>
    <p>若切换的目标身份与执行者身份相同，无需密码。</p>
  </li>
</ol>

<h4 id="visudo"><code class="highlighter-rouge">visudo</code></h4>

<p><code class="highlighter-rouge">visudo</code> 用于以安全的方式编辑 <code class="highlighter-rouge">/etc/sudoers</code>。实际上是调用 vi 来修改 <code class="highlighter-rouge">/etc/sudoers</code> ，但退出之前会 <strong>自动检查语法</strong>。</p>

<h4 id="etcsudoers-的结构"><code class="highlighter-rouge">/etc/sudoers</code> 的结构</h4>

<p>典型的 <code class="highlighter-rouge">/etc/sudoers</code> 结构为：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Defaults        env_reset
Defaults        mail_badpass
Defaults        <span class="nv">secure_path</span><span class="o">=</span><span class="s2">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>

root    <span class="nv">ALL</span><span class="o">=(</span>ALL:ALL<span class="o">)</span> ALL

%admin <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span> ALL
%sudo   <span class="nv">ALL</span><span class="o">=(</span>ALL:ALL<span class="o">)</span> ALL

<span class="c">#includedir /etc/sudoers.d</span>
</code></pre></div></div>

<h5 id="系统默认设置">系统默认设置</h5>

<ul>
  <li><code class="highlighter-rouge">env_reset</code></li>
</ul>

<p>用于重置终端的环境变量，清除所有自定义变量。避免潜在的有危险的环境变量影响 <code class="highlighter-rouge">sudo</code> 的会话。</p>

<ul>
  <li><code class="highlighter-rouge">mail_badpass</code></li>
</ul>

<p>用于告诉系统，如果输错 <code class="highlighter-rouge">sudo</code> 密码，就给 root 发邮件。</p>

<ul>
  <li><code class="highlighter-rouge">secure_path</code></li>
</ul>

<p>指定 $PATH 变量的值。</p>

<h5 id="用户权限设置">用户权限设置</h5>

<p>格式为：</p>

<p><code class="highlighter-rouge">user1    ALL=(ALL:ALL)              ALL</code></p>

<p><code class="highlighter-rouge">用户名</code>  <code class="highlighter-rouge">适用主机名=（可切换成的用户名:可切换成的组名）</code>  <code class="highlighter-rouge">授权使用的命令</code></p>

<p>ALL 表示任意的。</p>

<h5 id="组权限设置">组权限设置</h5>

<p>与用户权限设置相似，只是以 <code class="highlighter-rouge">%</code> 开头，表示这是组的名字。</p>

<h5 id="引用目录">引用目录</h5>

<p>虽然以 <code class="highlighter-rouge">#</code> 开头，但不是注释，所引用的目录 <code class="highlighter-rouge">/etc/sudoers.d</code> 会被读取、应用。</p>

<p>该目录中的所有文件使用与 <code class="highlighter-rouge">/etc/sudoers</code> 同样的规范，只要目录中的文件名不以 <code class="highlighter-rouge">~</code> 结尾，不含有 <code class="highlighter-rouge">.</code>，就会被读取并做为配置文件应用给 <code class="highlighter-rouge">sudo</code>。</p>

<h4 id="范例-4">范例</h4>

<ul>
  <li>指定用户</li>
</ul>

<p><code class="highlighter-rouge">user1    ALL=（ALL）              ALL</code></p>

<ul>
  <li>群组</li>
</ul>

<p><code class="highlighter-rouge">%wheel     ALL=（ALL）    ALL</code></p>

<p>任何加入该群组的用户，均能使用 sudo 切换任何身份来操作任何命令。</p>

<p>📕 从 CentOS 7 开始，默认开放 %wheel 群组的权限。</p>

<ul>
  <li>群组无需密码</li>
</ul>

<p><code class="highlighter-rouge">%wheel     ALL=（ALL）   NOPASSWD: ALL</code></p>

<ul>
  <li>限定命令</li>
</ul>

<p><code class="highlighter-rouge">my1    ALL=（root）  !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</code></p>

<p>命令须用绝对路径描述，只能切换成 root 使用 passwd 这一个命令，无法修改 root 密码。</p>

<ul>
  <li>批量新建 sudoers</li>
</ul>

<p>要把 <strong>多个用户</strong> 加入 sudoers，可用 visudo 通过创建 <strong>用户别名</strong> 和 <strong>命令别名</strong> 来实现。</p>

<p><code class="highlighter-rouge">_Alias ADMPW = pro1, pro2, pro3, my1, my2</code></p>

<p>定义帐号别名</p>

<p><code class="highlighter-rouge">Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</code></p>

<p>定义命令别名</p>

<p><code class="highlighter-rouge">ADMPW   ALL=（root）  ADMPWCOM</code></p>

<p>别名必须 <strong>全部大写</strong>。</p>

<ul>
  <li>无需管理员密码切换成 root</li>
</ul>

<p><code class="highlighter-rouge">sudo</code> 结合 <code class="highlighter-rouge">su</code> 使用</p>

<p>在需要执行大量 root 的工作时：</p>

<p><code class="highlighter-rouge">_Alias  ADMINS = pro1, pro2, pro3, my1</code></p>

<p><code class="highlighter-rouge">ADMINS ALL=（root）  /bin/su -</code></p>

<p>用户使用 <code class="highlighter-rouge">sudo su -</code> 仅需自己的密码，就可以切换为 root。</p>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	<hr />
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/权限" class="page__taxonomy-item" rel="tag">权限</a><span class="sep">  </span>
    
		
      <a href="/tag/linux" class="page__taxonomy-item" rel="tag">linux</a><span class="sep">  </span>
    
		
      <a href="/tag/acl" class="page__taxonomy-item" rel="tag">acl</a><span class="sep">  </span>
    
		
      <a href="/tag/切换用户" class="page__taxonomy-item" rel="tag">切换用户</a><span class="sep">  </span>
    
		
      <a href="/tag/su" class="page__taxonomy-item" rel="tag">su</a><span class="sep">  </span>
    
		
      <a href="/tag/sudo" class="page__taxonomy-item" rel="tag">sudo</a>
    
    </span>
  </p>













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://liloli.github.io/categories/#linux" class="page__taxonomy-item" rel="tag">linux</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2015-01-07T00:00:00+08:00">January 07, 2015</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  <a href="https://twitter.com/intent/tweet?via=liloli&text=Linux+%E5%9F%BA%E7%A1%80+-+7.+%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%20https%3A%2F%2Fliloli.github.io%2Flinux%2Flinux.accontrol%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fliloli.github.io%2Flinux%2Flinux.accontrol%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=https%3A%2F%2Fliloli.github.io%2Flinux%2Flinux.accontrol%2F" class="btn btn--google-plus" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Google Plus"><i class="fab fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fliloli.github.io%2Flinux%2Flinux.accontrol%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="https://liloli.github.io/linux/linux.user/" class="pagination--pager" title="Linux 基础 - 6. 用户管理
">向前</a>
    
    
      <a href="https://liloli.github.io/linux/linux.bootstrap/" class="pagination--pager" title="Linux 基础 - 8. Linux 启动流程
">向后</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/time/" rel="permalink">Bash 脚本 - 时间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/storage/" rel="permalink">Bash 脚本 - 存储空间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/numbers/" rel="permalink">Bash 脚本 - 数字
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/input/" rel="permalink">Bash 脚本 - 输入
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap">
  <input type="text" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  <div id="results" class="results"></div>
</div>
      </div>
    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
      <li><a href="https://twitter.com/liloli"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
      <li><a href="https://www.facebook.com/lilolibj"><i class="fab fa-fw fa-facebook-square" aria-hidden="true"></i> Facebook</a></li>
    
    
      <li><a href="https://github.com/liloli"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    <li><a href="https://liloli.github.io/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://liloli.github.io/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>



  
  
  <script src="https://liloli.github.io/assets/js/lunr/lunr.min.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-store.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-en.js"></script>





    
  <script>
    var disqus_config = function () {
      this.page.url = "https://liloli.github.io/linux/linux.accontrol/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/linux/linux.accontrol"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://liloli.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  



  </body>
</html>
