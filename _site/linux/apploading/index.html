<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Linux 基础 - 17. 程序的加载 - LINOTES</title>
<meta name="description" content="用简洁清晰的语言讨论技术">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Linux 基础 - 17. 程序的加载">
<meta property="og:url" content="https://linotes.netlify.com/linux/apploading/">


  <meta property="og:description" content="用简洁清晰的语言讨论技术">



  <meta property="og:image" content="https://linotes.netlify.com/assets/images/header/linux.jpg">





  <meta property="article:published_time" content="2015-01-17T00:00:00+08:00">






<link rel="canonical" href="https://linotes.netlify.com/linux/apploading/">













<!-- end _includes/seo.html -->


<link href="https://linotes.netlify.com/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://linotes.netlify.com/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->






<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://linotes.netlify.com/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/app/rsync/" >Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/server/vsftpd/" >Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/kernel/filedescriptor/" >文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/tools/tools.datastream/" >数据流处理</a>
            </li>
          
        </ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://linotes.netlify.com/assets/images/header/linux.jpg');"
>
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Linux 基础 - 17. 程序的加载

        
      </h1>
      
        <p class="page__lead">
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://linotes.netlify.com/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:imhawkz@gmail.com">
            <meta itemprop="email" content="imhawkz@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Linux 基础 - 17. 程序的加载">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="January 17, 2015">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-code-branch"></i> 17. 程序的加载</h4></header>
              <ul class="toc__menu">
  <li><a href="#175-程序的加载">17.5 程序的加载</a>
    <ul>
      <li><a href="#1751-进程的虚拟地址空间">17.5.1 进程的虚拟地址空间</a></li>
      <li><a href="#1752-加载的方式">17.5.2 加载的方式</a></li>
      <li><a href="#1753-从操作系统角度看可执行文件的加载">17.5.3 从操作系统角度看可执行文件的加载</a></li>
      <li><a href="#1754-进程虚拟空间分布">17.5.4 进程虚拟空间分布</a></li>
    </ul>
  </li>
  <li><a href="#174-库">17.4 库</a>
    <ul>
      <li><a href="#1741-静态库">17.4.1 静态库</a></li>
      <li><a href="#1742-共享库">17.4.2 共享库</a></li>
      <li><a href="#1743-共享库的加载">17.4.3 共享库的加载</a></li>
      <li><a href="#1744-共享库高速缓存">17.4.4 共享库高速缓存</a></li>
      <li><a href="#1745-管理共享库">17.4.5 管理共享库</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <h2 id="175-程序的加载">17.5 程序的加载</h2>

<p>可执行文件只有加载到内存以后才能被 CPU 执行。早期的程序加载十分简陋，加载的基本过程就是把程序从外部存储器中读取到内存中的某个位置。随着硬件 MMU 的诞生，多进程、多用户、虚拟存储的操作系统出现以后，可执行文件的加载过程变得非常复杂。</p>

<h3 id="1751-进程的虚拟地址空间">17.5.1 进程的虚拟地址空间</h3>

<p>每个程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间的大小由计算机的硬件平台决定，具体地说是由 CPU 的位数决定的。</p>

<p>硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如 32 位的硬件平台决定了虚拟地址空间的地址为 4GB。</p>

<p>程序在运行的时候处于操作系统的监管下，操作系统为了达到监控程序运行等一系列目的，进程的虚拟空间都在操作系统的掌握之中。进程只能使用那些操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程。</p>

<p>对于 32 位平台，只能使用 4GB 的虚拟空间，其中操作系统本身用去了一部分，对于 Linux 来说，进程在执行的时候，可用的虚拟空间不超过 3GB。只有使用 64 位平台才能让进程使用更多的虚拟空间。</p>

<h3 id="1752-加载的方式">17.5.2 加载的方式</h3>

<p>程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的静态装入的办法。</p>

<p>为了让更多更大的程序得以运行而不停地增加内存是不实际的，最好在不添加内存的情况下让更多的程序运行起来，尽可能有效地利用内存。</p>

<p>根据程序运行时的 <strong>局部性原理</strong>，可以将程序最 <strong>常用</strong> 的部分 <strong>驻留</strong> 在内存中，而将一些 <strong>不太常用</strong> 的数据存放在 <strong>磁盘</strong> 里面，这就是 <strong>动态加载</strong> 的基本原理。</p>

<p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态加载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p>

<h4 id="覆盖加载">覆盖加载</h4>

<p>覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。</p>

<p>覆盖装入在没有发明虚拟存储之前使用比较广泛，现在已经几乎被 <strong>淘汰</strong> 了。</p>

<h4 id="页映射">页映射</h4>

<p>页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。</p>

<p>页映射也不是一下子就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令划分成若干个页，以后所有的加载和操作的单位就使用页。</p>

<p>假设加载由加载管理器来控制。当进程需要读取硬盘中的页，而没有可用虚拟空间时，加载管理器必须判断清除内存中的哪些页。如果选择清除最早分配的内存页，则称之为 FIFO；如果选择清除很少访问到的内存页，则为 LUR，最少使用算法。</p>

<p>实际上，这个所谓的加载管理器就是现代的操作系统的存储管理器。目前几乎所有主流操作系统都是按照该方式加载可执行文件的。</p>

<h3 id="1753-从操作系统角度看可执行文件的加载">17.5.3 从操作系统角度看可执行文件的加载</h3>

<p>可执行文件中的页可能被装入内存中的任意页，如果程序使用物理地址直接进行操作，那么每次页被装入时都需要进行重定位。而有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。</p>

<h4 id="进程的建立">进程的建立</h4>

<p>从操作系统的角度来看，一个进程最关键的特征是它拥有 <strong>独立的虚拟地址空间</strong>，这使得它有别于其他进程。</p>

<p>很多时候一个程序被执行同时都伴随着一个新的进程的创建：创建一个进程，加载可执行文件并执行。</p>

<p>在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p>

<ul>
  <li>创建一个独立的 <strong>虚拟地址空间</strong></li>
  <li>读取可执行文件头，并且建立虚拟空间与可执行文件的 <strong>映射</strong> 关系</li>
  <li>将 CPU 的指令 <strong>寄存器</strong> 设置成可执行文件的 <strong>入口地址</strong>，启动 <strong>运行</strong></li>
</ul>

<p class="notice--info">由于可执行文件在加载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做 <strong>映像文件</strong>（Image）。</p>

<p>可执行文件与其进程的虚拟空间的映射关系，只是保存在操作系统内部的一个数据结构。Linux 中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA, Virtual Memory Area）。操作系统在内部保存这种结构，为当程序执行发生段错误时，它可以通过查找这样的一个数据结构来定位错误页在可执行文件中的位置。</p>

<h4 id="页错误">页错误</h4>

<p>当 CPU 开始打算执行入口地址的指令时，如果发现该页面是个空页面，它就认为这是一个页错误（Page Fault）。</p>

<p>CPU 将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。此时，操作系统会查询代表映射关系的数据结构，找到空页面所在的 VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。</p>

<p>随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。有时进程所需要的内存会超过可用的内存数量，特别是在有多个进程同时执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚至有时候应将分配给进程的物理内存暂时收回。</p>

<h3 id="1754-进程虚拟空间分布">17.5.4 进程虚拟空间分布</h3>

<h4 id="elf-文件链接视图和执行视图">ELF 文件链接视图和执行视图</h4>

<p>在一个正常的进程中，可执行文件中包含的往往不止代码段，还有数据段、BSS 等，所以映射到进程虚拟空间的往往不止一个段。当段的数量增多时，就会产生 <strong>空间浪费</strong> 的问题。每个段在映射时的长度都是系统页长度的整数倍；如果不是，其多余部分也会占用一个页。</p>

<p>操作系统加载可执行文件时，并不关心可执行文件各个段所包含的实际内容，只关心与加载相关的问题，主要是段的权限（可读、可写、可执行）。</p>

<p>ELF 文件中，段的权限往往只有为数不多的几种组合，基本上是三种：</p>

<ul>
  <li>可读可执行的段：代码段</li>
  <li>可读可写的段：数据段和 BSS 段</li>
  <li>只读的段：只读数据段</li>
</ul>

<p>对于 <strong>相同权限的段</strong>，把它们 <strong>合并</strong> 到一起当作一个段进行映射。这样可以把原先的多个段当做一个整体进行映射，明显地减少页面内部碎片，节省内存空间。这个称为 <code class="highlighter-rouge">Segment</code>，它表示一个或多个属性类似的 <code class="highlighter-rouge">Section</code>，可以认为 Section 是链接时的概念，Segment 是加载时的概念。链接器会把属性相似的 Section 放在一起，然后系统会按照这些 Section 组成的 Segment 来映射，并加载可执行文件。</p>

<h4 id="栈和堆">栈和堆</h4>

<p>进程的虚拟地址空间中除了被用来映射可执行文件的各个 Segment 之外，还有包括栈（Stack）和堆（Heap）的空间，一个进程中的栈和堆在也是以虚拟内存区域（VMA, Virtual Memrory Area）的形式存在。操作系统通过给进程空间划分出一个个的 VMA 来管理进程的虚拟空间，基本原则是将相同权限属性的、有相同映像文件的映射成一个 VMA，一个进程基本可以分为如下几种 VMA 区域：</p>

<ul>
  <li>代码 VMA，权限只读，可执行，有映像文件。</li>
  <li>数据 VMA，权限可读写，可执行，有映像文件。</li>
  <li>堆 VMA，权限可读写，可执行，无映像文件，匿名，可向上扩展</li>
  <li>栈 VMA，权限可读写，不可执行，无映像文件，匿名，可向下扩展</li>
</ul>

<h2 id="174-库">17.4 库</h2>

<p>Library</p>

<p>库是编译好的代码，可以被程序复用。库简化了程序员的工作，它们提供可重用的函数、类、数据结构等，而这些是之前由其他程序员编写的，现在可以被其他程序员所使用。</p>

<p>例如，如果要构建的程序需要进行数学运算，你无需再编写数学函数，只需要使用库中现有的函数就可以了。</p>

<p>Linux 中常见的库有：</p>

<ul>
  <li><strong>libc</strong> ：标准的 C 程序库</li>
  <li><strong>glibc</strong>：GNU 版本的标准 C 程序库</li>
  <li><strong>libcurl</strong>：多协议文件传输库</li>
  <li><strong>libcrypt</strong>：用于加密、hash</li>
</ul>

<p>Linux 支持两类的库：</p>

<ul>
  <li><strong>静态库</strong>：编译期间被静态捆绑到程序中，扩展名为 <code class="highlighter-rouge">.a</code> 或 <code class="highlighter-rouge">.lib</code></li>
  <li><strong>动态库</strong>：程序启动时加载，在运行时绑定。扩展名为 <code class="highlighter-rouge">.so</code></li>
</ul>

<h3 id="1741-静态库">17.4.1 静态库</h3>

<ul>
  <li>文件名通常为 <code class="highlighter-rouge">libxxx.a </code></li>
  <li>静态函数库在编译时会 <strong>整合</strong> 到可执行程序中，因此最终文件比较大</li>
  <li>编译成功的可执行文件可以 <strong>独立运行</strong>，无需读取外部函数库</li>
  <li>如果函数库升级，整个可执行文件须重新编译</li>
</ul>

<h3 id="1742-共享库">17.4.2 共享库</h3>

<p>Linux 大多使用共享库。</p>

<ul>
  <li>文件名通常为 <code class="highlighter-rouge">libxxx.so</code></li>
  <li>共享库在编译时，仅在程序中保存一个指针，指向函数库。只有在可执行文件需要要使用函数库时，程序才去读取。文件比较小。</li>
  <li>共享库编译的程序不能独立运行，依赖固定路径下的函数库。</li>
  <li>函数库升级后，可执行文件无需重新编译。</li>
</ul>

<p>大多数操作系统把解析共享库作为程序加载过程的一部分。在这些系统上，可执行文件包含一个叫做 <code class="highlighter-rouge">import directory</code> 的表，该表的每一项包含一个库的名字。根据表中记录的名字，加载程序在硬盘上搜索需要的库，然后将其加载到内存中，之后，用库的地址来更新可执行程序。</p>

<p>可执行程序根据更新后的库信息，调用库中的函数或引用库中的数据。这种类型的动态加载称为加载时（load-time）加载，Windows 和 Linux 均采用这种方式。加载程序在加载应用软件时要完成的最复杂的工作之一就是加载时链接。</p>

<p>可以动态链接的函数库，在 Windows 上叫动态链接库 Dynamic Link Library（DLL），在 UNIX 或 Linux 上叫 <code class="highlighter-rouge">Shared Library</code>，共享库。</p>

<p>库文件是预先编译、链接好的可执行文件，存储在计算机的硬盘上。大多数情况下，同一时间多个应用可以使用一个库的同一个副本，操作系统不需要加载这个库的多个实例。</p>

<p>动态链接的最大 <strong>缺点</strong> 是：可执行程序的运行 <strong>依赖</strong> 于单独存储的库文件。如果库文件被删除、移动、重命名或者被替换为不兼容的版本，可执行程序就无法正常工作，即常说的 DLL-hell。</p>

<h4 id="共享库的命名">共享库的命名</h4>

<p>为了使用方便，共享库通常使用库名来命名，也叫 soname。实际上 soname 是指向其文件名的 <strong>绝对路径</strong> 的符号链接。</p>

<p>如 libc 的库名为 <code class="highlighter-rouge">libc.so.6</code>：</p>

<ul>
  <li><code class="highlighter-rouge">lib</code> 前缀</li>
  <li><code class="highlighter-rouge">c</code> C 程序</li>
  <li><code class="highlighter-rouge">so</code> 共享库</li>
  <li><code class="highlighter-rouge">6</code>  版本号</li>
</ul>

<p>该库的文件名为 <code class="highlighter-rouge">/lib64/libc.so.6</code>。</p>

<h3 id="1743-共享库的加载">17.4.3 共享库的加载</h3>

<p>共享库是由程序 <code class="highlighter-rouge">ld.so</code> 及 <code class="highlighter-rouge">ld-linux.so.x</code> 加载的，其中 x 代表版本号。在 Linux 中，<code class="highlighter-rouge">/lib/ld-linux.so.x</code> 会查找并加载程序所有的共享库。</p>

<p>程序可以使用其库名或文件名来加载共享库。共享库通常位于 <code class="highlighter-rouge">/usr/local/lib</code>，<code class="highlighter-rouge">/usr/local/lib64</code>，<code class="highlighter-rouge">/usr/lib</code>，<code class="highlighter-rouge">/usr/lib64</code> 目录中，系统启动需要的库位于 <code class="highlighter-rouge">/lib64/</code>，<code class="highlighter-rouge">/lib/</code> 目录中，内核的库位于 <code class="highlighter-rouge">/lib/modules/</code> 中。也允许程序把库安装到自定义的位置。</p>

<p>库的路径在配置文件 <code class="highlighter-rouge">/etc/ld.so.conf</code> 中定义，通常默认只有一条语句 <code class="highlighter-rouge">include ld.so.conf.d/*.conf</code>，因此内核会加载 <code class="highlighter-rouge">/etc/ld.so.conf.d/</code> 目录中的所有配置文件。</p>

<p>按照这个思路，软件包的维护者或程序员就会把他们的自定义库的路径加到搜索列表中：</p>

<p>在 <code class="highlighter-rouge">/etc/ld.so.conf.d/</code> 目录中新建一个自己的配置文件，如 <code class="highlighter-rouge">mariadb-x86_64.conf</code>，其内容为自定义库的路径 <code class="highlighter-rouge">/usr/lib64/mysql</code>。这样，mysql 的库路径就被加到系统库路径中了。</p>

<h3 id="1744-共享库高速缓存">17.4.4 共享库高速缓存</h3>

<p>把共享库载入高速缓存内存中，这样，程序在需要调用共享库时可以直接访问内存，提高效率。</p>

<p>在 <code class="highlighter-rouge">/etc/ld.so.conf</code> 中指定共享库所在的目录，由 <code class="highlighter-rouge">ldconfig</code> 程序把 <code class="highlighter-rouge">/etc/ld.so.conf</code> 中指定的目录中的共享库读入高速缓存。将共享库映射保存在 <code class="highlighter-rouge">/etc/ld.so.cache</code> 文件中。</p>

<blockquote>
  <p><code class="highlighter-rouge">/etc/ld.so.cache</code> 这个文件是个二进制文件，其作用为缓存一系列映射：<strong>共享库文件名</strong> 到其 <strong>完整路径</strong> 的映射。如 <code class="highlighter-rouge">libXt.so.6</code> – <code class="highlighter-rouge">/usr/lib/x86_64-linux-gnu/libXt.so.6</code> 这样的映射。有了这个映射表就可以快速找到程序所需的共享库。</p>

  <p>每次往 <code class="highlighter-rouge">/usr/lib/</code> 等系统目录安装新的共享库时，都需要运行 <code class="highlighter-rouge">ldconfig</code> 命令来更新该缓存文件。</p>
</blockquote>

<p>可以通过创建 <code class="highlighter-rouge">/etc/ld.so.conf.d/*.conf</code> 文件，使 ldconfig 在更新缓存时自动添加自定义配置文件中指定的目录中的共享库。</p>

<h4 id="ldconfig-语法"><code class="highlighter-rouge">ldconfig</code> 语法</h4>

<p><code class="highlighter-rouge">ldconfig [-f conf] [ -C cache]</code></p>

<p><code class="highlighter-rouge">ldconfig [-p]</code></p>

<p><code class="highlighter-rouge">-f conf</code> 手动指定配置文件 conf，从中读取共享库路径</p>

<p><code class="highlighter-rouge">-C cache</code> 手动指定缓存文件 cache</p>

<p><code class="highlighter-rouge">-p</code>    列出当前所有共享库 （即 <code class="highlighter-rouge">/etc/ld.so.cache</code> 的共享库）</p>

<p>范例：手动指定配置文件</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~]# vim /etc/ld.so.conf.d/neo.conf
/usr/lib64/mysql   

~]# ldconfig  
</code></pre></div></div>

<p>以上操作会把 Mariadb 的共享库读入高速缓存。</p>

<h3 id="1745-管理共享库">17.4.5 管理共享库</h3>

<p>使用 <code class="highlighter-rouge">ldd</code> 程序来分析可执行文件中含有哪些共享库。</p>

<p><code class="highlighter-rouge">ldd [-vdr] [filename]</code></p>

<p><code class="highlighter-rouge">-v</code> ：列出所有信息</p>

<p><code class="highlighter-rouge">-d</code> ：重新检查共享库，并列出丢失的</p>

<p><code class="highlighter-rouge">-r</code> ：列出 ELF 的错误内容</p>

<p>范例一：查看指定程序的共享库</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~]# ldd /usr/bin/passwd
	libpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007f5e683dd000)            # PAM
	libpam_misc.so.0 =&gt; /lib64/libpam_misc.so.0 (0x00007f5e681d8000)
	libaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f5e67fb1000)        # SELinux
	libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f5e67d8c000)    # SELinux
........
</code></pre></div></div>

<p>范例二：查看指定共享库的相关共享库</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~]# ldd -v /lib64/libc.so.6
/lib64/ld-linux-x86-64.so.2 (0x00007f7acc68f000)
linux-vdso.so.1 =&gt;  (0x00007fffa975b000)

Version information:  #  -v 选项会显示其他版本信息
/lib64/libc.so.6:
		ld-linux-x86-64.so.2 (GLIBC_2.3) =&gt; /lib64/ld-linux-x86-64.so.2
		ld-linux-x86-64.so.2 (GLIBC_PRIVATE) =&gt; /lib64/ld-linux-x86-64.so.2
</code></pre></div></div>

<p>升级安装 RPM 软件时，可以先用 <code class="highlighter-rouge">ldd</code> 来检查共享库之间的依赖关系。用 <code class="highlighter-rouge">-v</code> 参数可以了解该共享库来自于哪个软件。</p>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	<hr />
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/加载" class="page__taxonomy-item" rel="tag">加载</a><span class="sep">  </span>
    
		
      <a href="/tag/库" class="page__taxonomy-item" rel="tag">库</a><span class="sep">  </span>
    
		
      <a href="/tag/linux" class="page__taxonomy-item" rel="tag">linux</a>
    
    </span>
  </p>













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://linotes.netlify.com/categories/#linux" class="page__taxonomy-item" rel="tag">linux</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2015-01-17T00:00:00+08:00">January 17, 2015</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="https://linotes.netlify.com/linux/build/" class="pagination--pager" title="上一页
">Linux 基础 - 16. 程序的构建</a>
    
    
      <a href="https://linotes.netlify.com/linux/rpm/" class="pagination--pager" title="下一页
">Linux 基础 - 18. 软件包的管理</a>
    
  </nav>


    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">相关文章</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/kernel/filedescriptor/" rel="permalink">文件描述符简介
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash03/" rel="permalink">Bash 入门 03
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">循环，变量，函数，捕捉信号
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash02/" rel="permalink">Bash 入门 02
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">正则表达式，SED，AWK，条件结构，交互式脚本
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash01/" rel="permalink">Bash 入门 01
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">Bash 与 Bash 脚本，脚本的编写与调试，Bash 环境
</p>
-->

  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
    
    
    
    
    <li><a href="https://linotes.netlify.com/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://linotes.netlify.com/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>








  </body>
</html>
