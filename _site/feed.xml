<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-08-02T14:41:43+08:00</updated><id>/</id><title type="html">LINOTES</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="/jekyll/update/welcome-to-jekyll/" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-08-01T21:35:40+08:00</published><updated>2018-08-01T21:35:40+08:00</updated><id>/jekyll/update/welcome-to-jekyll</id><content type="html" xml:base="/jekyll/update/welcome-to-jekyll/">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Linux 基础 - 20. 备份</title><link href="/linux/linux.backup/" rel="alternate" type="text/html" title="Linux 基础  - 20. 备份" /><published>2015-01-20T00:00:00+08:00</published><updated>2015-01-20T00:00:00+08:00</updated><id>/linux/linux.backup</id><content type="html" xml:base="/linux/linux.backup/">&lt;h2 id=&quot;201-备份简介&quot;&gt;20.1 备份简介&lt;/h2&gt;

&lt;p&gt;对文件系统的备份主要可分为对文件系统整体的 &lt;strong&gt;完整备份&lt;/strong&gt;，和对部分目录、文件的 &lt;strong&gt;选择备份&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2011-为什么要备份&quot;&gt;20.1.1 为什么要备份&lt;/h3&gt;

&lt;h4 id=&quot;硬件故障&quot;&gt;硬件故障&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;计算机是一个相当不可靠的机器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;会造成系统损坏的硬件主要是 &lt;strong&gt;硬盘&lt;/strong&gt; 。解决方案为使用可备份的 &lt;code class=&quot;highlighter-rouge&quot;&gt;RAID1、RAID5、RAID6&lt;/code&gt; 等磁盘阵列，但 &lt;code class=&quot;highlighter-rouge&quot;&gt;RAID&lt;/code&gt; 控制芯片也有损坏的可能。&lt;/p&gt;

&lt;h4 id=&quot;软件故障&quot;&gt;软件故障&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;系统的软件伤害，使用者误操作造成数据丢失&lt;/li&gt;
  &lt;li&gt;信息安全事件：遭受黑客攻击，钓鱼软件攻击，木马攻击等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2012-备份要考虑的因素&quot;&gt;20.1.2 备份要考虑的因素&lt;/h3&gt;

&lt;h4 id=&quot;备份对象&quot;&gt;备份对象&lt;/h4&gt;

&lt;p&gt;对系统或使用者来说最重要的数据，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/&lt;/code&gt; 及 &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/&lt;/code&gt; 等&lt;/p&gt;

&lt;h4 id=&quot;备份介质&quot;&gt;备份介质&lt;/h4&gt;

&lt;p&gt;光盘、硬盘、同一硬盘的不同分区、网络备份&lt;/p&gt;

&lt;h4 id=&quot;备份方式&quot;&gt;备份方式&lt;/h4&gt;

&lt;p&gt;完整备份，增量备份，差异备份&lt;/p&gt;

&lt;h4 id=&quot;备份的频率&quot;&gt;备份的频率&lt;/h4&gt;

&lt;h4 id=&quot;备份工具&quot;&gt;备份工具&lt;/h4&gt;

&lt;h3 id=&quot;2013-备份对象&quot;&gt;20.1.3 备份对象&lt;/h3&gt;

&lt;h4 id=&quot;系统数据&quot;&gt;系统数据&lt;/h4&gt;

&lt;h5 id=&quot;必须备份&quot;&gt;必须备份&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/root/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/spool/mail/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/spoll/cron/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/spool/at/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务软件数据库：如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;/srv/www/&lt;/code&gt; 等&lt;/li&gt;
  &lt;li&gt;用户的家目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;建议备份&quot;&gt;建议备份&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;无需备份&quot;&gt;无需备份&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/sys/&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/run/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/mnt/&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/media/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2014-备份介质&quot;&gt;20.1.4 备份介质&lt;/h3&gt;

&lt;p class=&quot;notice--success&quot;&gt;常见的 3-2-1 备份策略：本地有 2 份不同介质的备份，网络上有 1 份备份。&lt;/p&gt;

&lt;h4 id=&quot;异地备份&quot;&gt;异地备份&lt;/h4&gt;

&lt;p&gt;异地物理备份是首先要保证的，避免连备份本身都被偷。&lt;/p&gt;

&lt;h4 id=&quot;介质&quot;&gt;介质&lt;/h4&gt;

&lt;p&gt;以前多用磁带，Mo，Zip，CD-RW，DVD-RW，外接磁盘，近年来性价比较高的是外接 &lt;strong&gt;台式 NAS&lt;/strong&gt; 储存设备。&lt;/p&gt;

&lt;p&gt;NAS 是内嵌 Linux 的小型服务器，包含硬或软 RAID 功能，能够提供个性化服务，包括不同的连接接口和传输协议。&lt;/p&gt;

&lt;p&gt;如果经费不足，可以考虑外接 USB 3.0 硬盘，用多块硬盘轮流备份。&lt;/p&gt;

&lt;p&gt;最后的选择是磁带，适于较长时间的备份，存在消磁及发霉变质的风险。&lt;/p&gt;

&lt;h2 id=&quot;202-完整备份&quot;&gt;20.2 完整备份&lt;/h2&gt;

&lt;p&gt;对整个 &lt;strong&gt;文件系统&lt;/strong&gt; 做一次完整的备份。&lt;/p&gt;

&lt;p&gt;系统、软件、数据整体备份，有利于 &lt;strong&gt;快速&lt;/strong&gt; 复原 &lt;strong&gt;整个系统&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;完整备份常用的工具有 &lt;code class=&quot;highlighter-rouge&quot;&gt;dd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;cpio&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;xfsdump&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;xfsrestore&lt;/code&gt; 等。这些工具都能够备份设备与特殊文件。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;实现完整备份有两种方法：&lt;strong&gt;增量备份&lt;/strong&gt; 和 &lt;strong&gt;差异备份&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2021-增量备份&quot;&gt;20.2.1 增量备份&lt;/h3&gt;

&lt;p&gt;Incremental Backup&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/8.4.incremental.Backup.png&quot; alt=&quot;增量备份原理&quot; /&gt;
  
&lt;/figure&gt;

&lt;p&gt;只有做过完全备份以后才能做增量备份。&lt;/p&gt;

&lt;p&gt;增量备份，是在进行完第一次完整备份后，经过一段时间的运行，比较当前系统与备份文件之间的差异，仅备份有差异的文件。&lt;/p&gt;

&lt;p&gt;而第二次增量备份则与第一次增量备份的数据比较，也是仅备份有差异的数据。&lt;/p&gt;

&lt;p&gt;如此一来，由于仅备份有差异的数据，因此备份的数据量小且快速。&lt;/p&gt;

&lt;p&gt;增量备份在 &lt;strong&gt;还原时也要按相反的顺序逐个还原&lt;/strong&gt;，比较麻烦。&lt;/p&gt;

&lt;h3 id=&quot;2022-差异备份&quot;&gt;20.2.2 差异备份&lt;/h3&gt;

&lt;p&gt;Differential backup&lt;/p&gt;

&lt;p&gt;差异备份进行之前，需要先进行一次完整备份，之后每次的备份都是与原始的完整备份的差异部分。&lt;/p&gt;

&lt;p&gt;所以，系统运行的越久，离完整备份时间越长，差异备份数据越大。&lt;/p&gt;

&lt;p&gt;差异备份比增量备份占用的磁盘空间更大，但 &lt;strong&gt;差异备份还原速度更快&lt;/strong&gt;，因为只需要还原完整备份与最近一次的差异备份即可。&lt;/p&gt;

&lt;h2 id=&quot;203-选择备份&quot;&gt;20.3 选择备份&lt;/h2&gt;

&lt;p&gt;仅备份文件系统中的 &lt;strong&gt;部分目录和文件&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tar&lt;/li&gt;
  &lt;li&gt;cpio&lt;/li&gt;
  &lt;li&gt;wodim 刻录光盘。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;204-备份策略&quot;&gt;20.4 备份策略&lt;/h2&gt;

&lt;p&gt;数据是 Linux 系统中最重要的组成部分，但是数据的备份与同步却是最容易被忽略的任务。通过定期的数据备份与同步，可以在磁盘出现故障时，最大程度的降低数据损失。当用户误操作导致数据损坏或者丢失时，可以快速恢复。&lt;/p&gt;

&lt;p&gt;数据的备份不同于整个系统备份，将不同数据按照优先级分类，根据用户需求，备份重要文件。&lt;/p&gt;

&lt;p&gt;从而使数据独立于操作系统，降低备份成本与时间。&lt;/p&gt;

&lt;h3 id=&quot;2041-有效的备份策略应包含哪些内容&quot;&gt;20.4.1 有效的备份策略应包含哪些内容&lt;/h3&gt;

&lt;h4 id=&quot;成本&quot;&gt;成本&lt;/h4&gt;

&lt;p&gt;应该制定支付得起的数据备份计划。衡量数据丢失会带来的经济损失，然后将之与备份系统的项目成本进行比对，有助于制定务实的备份策略。&lt;/p&gt;

&lt;h4 id=&quot;备份数据保存位置&quot;&gt;备份数据保存位置&lt;/h4&gt;

&lt;p&gt;可以保存在云端，可以保存到磁带等物理设备，也可同时保存，以增加保险系数。&lt;/p&gt;

&lt;h4 id=&quot;面对什么样的数据风险&quot;&gt;面对什么样的数据风险&lt;/h4&gt;

&lt;p&gt;一方面要考虑木马、钓鱼软件的风险，另一方面要考虑水患，有条件尽量做离站备份。&lt;/p&gt;

&lt;h4 id=&quot;备份频率&quot;&gt;备份频率&lt;/h4&gt;

&lt;p&gt;多久做一次备份？根据公司具体情况，对数据时效的敏感度来定。&lt;/p&gt;

&lt;p&gt;简单的数据备份是指一次性备份所有数据，然后再备份上次备份之后所做的修改。第一次备份是指 “&lt;strong&gt;完全备份&lt;/strong&gt;”，后一次备份是 “&lt;strong&gt;增量备份&lt;/strong&gt;”。通常适用于个人或者小型网站。对于机构或者大型网站来说，需要采用 “多级备份”。将完全备份设定为 0 级，增量备份的级别分别是 1，2，3 等。在每个增量备份级别上，可备份同级或上一级的上次备份以来的变动。&lt;/p&gt;

&lt;p&gt;比如，如果我们有 10 盘磁带，如果使用简单备份进行日备份，则可恢复两周内的数据。&lt;/p&gt;

&lt;p&gt;如果使用多级备份，例如：&lt;/p&gt;

&lt;p&gt;磁带 1－2， 月备份，每月第一个星期五&lt;/p&gt;

&lt;p&gt;磁带 3－6， 周备份，每周星期五（排除第一周）&lt;/p&gt;

&lt;p&gt;磁带 7－10，日备份，每周星期一到四，则可以将备份历史扩展到两个月。&lt;/p&gt;

&lt;h4 id=&quot;交给什么人去做&quot;&gt;交给什么人去做&lt;/h4&gt;

&lt;p&gt;谁对备份计划负责？员工培训很重要，需交给可信任的、经验丰富的人来执行。&lt;/p&gt;

&lt;h3 id=&quot;2042-评估备份需求&quot;&gt;20.4.2 评估备份需求&lt;/h3&gt;

&lt;p&gt;在商业环境中，必须首先确定需要备份哪些文件以及备份所消耗的时间。如果备份过多的文件，会导致备份系统的成本过于庞大，从而带来不必要的开支。如果没有备份足够的数据，那么可能导致重要数据的丢失，反而带来更大的损失。&lt;/p&gt;

&lt;p&gt;当然，备份整个系统是简单易行的，但是通常这样的备份是浪费的且缺乏意义的。从减少备份系统的成本出发，只有当某些数据足够重要，需要共享，才具有备份的必要。&lt;/p&gt;

&lt;h4 id=&quot;有哪些数据需要保护&quot;&gt;有哪些数据需要保护&lt;/h4&gt;

&lt;p&gt;以短期和长期的眼光思考以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是否需要快速恢复整个 &lt;strong&gt;文件系统&lt;/strong&gt; 的数据？&lt;/li&gt;
  &lt;li&gt;是否需要恢复 &lt;strong&gt;部分数据&lt;/strong&gt;？&lt;/li&gt;
  &lt;li&gt;是否需要保持 &lt;strong&gt;服务可用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;备份哪些类型的文件：数据库、文件、操作系统、程序、配置文件&lt;/li&gt;
  &lt;li&gt;哪些数据是最重要的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;备份计划制定的越全面，将来数据恢复的越容易。&lt;/p&gt;

&lt;p&gt;基本数据一般分为以下几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户数据：所有的用户数据以及用户目录，及私人文件等。&lt;/li&gt;
  &lt;li&gt;系统信息：系统用户，组，密码，主机列表等。&lt;/li&gt;
  &lt;li&gt;应用程序：系统上启动的服务，比如 web 应用程序，apache 等。&lt;/li&gt;
  &lt;li&gt;应用程序的配置文件与数据：针对不同的应用程序，不同的配置选项和重要数据文件。&lt;/li&gt;
  &lt;li&gt;数据库：事实上数据库可以单独提供针对数据库所有数据的备份与同步功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;面临的数据风险有哪些&quot;&gt;面临的数据风险有哪些&lt;/h4&gt;

&lt;p&gt;通过以下问题来入手，考虑公司所面临的数据风险：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;过去的日子有很多公司被黑过吗？&lt;/li&gt;
  &lt;li&gt;马虎的员工对数据安全有影响吗？&lt;/li&gt;
  &lt;li&gt;自己所处的物理位置有无自然灾害的风险？&lt;/li&gt;
  &lt;li&gt;客户需要登陆到我的系统来访问数据或服务吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;应采用什么备份设备&quot;&gt;应采用什么备份设备&lt;/h4&gt;

&lt;p&gt;选择的备份设备应能满足备份计划的要求。如果要规避硬件损坏及自然灾害所带来的风险，可以考虑离站备份方案。&lt;/p&gt;

&lt;p&gt;站内物理备份有利于快速恢复数据，在断网及紧急情况下能节省很多时间。&lt;/p&gt;

&lt;p&gt;为了避免 &lt;strong&gt;持续业务&lt;/strong&gt; 被中断，可以选择远程云端灾难恢复站点（remote cloud disaster recovery site），保存于数据中心的数据是以同样的结构化存在的，能够快速恢复到本地。&lt;/p&gt;

&lt;h4 id=&quot;备份数据要保存多久&quot;&gt;备份数据要保存多久&lt;/h4&gt;

&lt;p&gt;存储是累积的，所需要的空间会越来越大。&lt;/p&gt;

&lt;h3 id=&quot;2043-评估候选方案找出最佳备份策略&quot;&gt;20.4.3 评估候选方案，找出最佳备份策略&lt;/h3&gt;

&lt;h4 id=&quot;硬件备份&quot;&gt;硬件备份&lt;/h4&gt;

&lt;p&gt;硬盘备份可以保存在本地，用硬盘备份的主要优势在于可以方便地接入工作网络，劣势在于如果硬盘损坏，没有额外的备份。&lt;/p&gt;

&lt;h4 id=&quot;软件备份&quot;&gt;软件备份&lt;/h4&gt;

&lt;p&gt;购买备份软件，安装于不同的系统。&lt;/p&gt;

&lt;p&gt;购买云服务可以把备份保存到云上，将其做为离站备份。&lt;/p&gt;

&lt;h4 id=&quot;混合云方案&quot;&gt;混合云方案&lt;/h4&gt;

&lt;p&gt;比较流行的解决方案是使用混合的备份方案。把私有云和公有云结合在一起，可为恢复数据提供多个选择。&lt;/p&gt;

&lt;p&gt;混合云的优势在于它同时以两种方式保护数据。&lt;/p&gt;

&lt;h4 id=&quot;存储的选择&quot;&gt;存储的选择&lt;/h4&gt;

&lt;p&gt;选择备份和存储方案的过程，意味着对预算和需求的平衡。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存到本地磁盘或 USB 磁盘：适合保存单独的文件，不适合网络备份。如果磁盘被破坏，备份就丢失。&lt;/li&gt;
  &lt;li&gt;NAS、SAN：适于通过网络保存数据，风险是硬件设备的损坏。&lt;/li&gt;
  &lt;li&gt;保存到磁盘：保存好的磁带应放到安全的地点保存。劣势在于磁带往返运输的时间成本，适于备份整个系统，不适合单个文件。&lt;/li&gt;
  &lt;li&gt;云备份：需要互联网连接，有网的地方就可访问数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要想确定最佳选择，你需要考虑两个因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RPO：Recovery Point Objective，可接受的系统数据丢失的最长的 &lt;strong&gt;时间点&lt;/strong&gt;，如一年前的数据丢失也许是可以接受的。&lt;/li&gt;
  &lt;li&gt;RTO：Recovery Time Objective，可接受的系统 &lt;strong&gt;中断时间&lt;/strong&gt;，要恢复正常的业务运营可接受的最长时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2044-制定预算&quot;&gt;20.4.4 制定预算&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;预算的上限是多少？&lt;/li&gt;
  &lt;li&gt;是否打算将预算分配为资本支出，或是运营支出？&lt;/li&gt;
  &lt;li&gt;如果被黑或受灾导致数据丢失，会造成什么损失？&lt;/li&gt;
  &lt;li&gt;培训员工要花费多少？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果选择 Backup As A Service，则可以按月付费，可以避免先期支付大量经费。&lt;/p&gt;

&lt;h3 id=&quot;2045-选择平台&quot;&gt;20.4.5 选择平台&lt;/h3&gt;

&lt;p&gt;云备份只需要有互联网的连接，从任何地方都可以访问数据了。唯一有争论的就是数据的保密。&lt;/p&gt;

&lt;p&gt;如果要保存敏感数据，则可能不会考虑外部公司提供的服务。&lt;/p&gt;

&lt;p&gt;可以考虑离站安全存储。&lt;/p&gt;

&lt;h3 id=&quot;2046-选择供应商&quot;&gt;20.4.6 选择供应商&lt;/h3&gt;

&lt;p&gt;可以选择全包的供应商，有些公司可以提供硬件、软件，及基于云的解决方案，有的甚至还可以帮助公司培训员工。&lt;/p&gt;

&lt;p&gt;任何时候选择供应商，都应该要求提案，这是了解所有可供选择的方案的最好办法。&lt;/p&gt;

&lt;p&gt;在对比报价时，应考虑以下因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;整体实施成本&lt;/li&gt;
  &lt;li&gt;包括哪些功能&lt;/li&gt;
  &lt;li&gt;项目部署需要多久&lt;/li&gt;
  &lt;li&gt;供应商的信誉&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;建议对供应商的现有客房进行详细的调查，尽可能的了解他们的使用情况，了解供应商的服务与支持。&lt;/p&gt;

&lt;h3 id=&quot;2047-制定时间表&quot;&gt;20.4.7 制定时间表&lt;/h3&gt;

&lt;p&gt;虽然供应商也会提供一个大概的时间表，但你自己仍有必要制定自己的时间表。可以帮助你做具体的规划。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;供应商可以开始工作之前，你需要做哪些？如备份现有数据，指定团队跟进实施进程。&lt;/li&gt;
  &lt;li&gt;开始之前，是否需要先走完预算的审批流程？大概需要多久？&lt;/li&gt;
  &lt;li&gt;供应商提出的时间表是多久完成项目？可以在此基础上稍微增加几天。&lt;/li&gt;
  &lt;li&gt;系统的安装会影响正常运营吗？是否可以夜间或周末进行来避免影响？&lt;/li&gt;
  &lt;li&gt;项目会如何影响到客户？如何能防止对客户业务的影响、延迟？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应该在时间表上增加一些缓冲时间，以避免意料之外的事件影响项目进度，总是会有你无法控制的事情发生。&lt;/p&gt;

&lt;h3 id=&quot;2048-制定详细的恢复计划&quot;&gt;20.4.8 制定详细的恢复计划&lt;/h3&gt;

&lt;p&gt;在项目实施过程中，可以制定详细的系统使用说明，让每个人都很容易上手使用。&lt;/p&gt;

&lt;p&gt;记住，最后真正负责进行备份的人很有可能会精简工作流程，因此恢复流程至少要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;要使用的恢复类型&lt;/li&gt;
  &lt;li&gt;要恢复的数据集&lt;/li&gt;
  &lt;li&gt;会影响数据恢复的其它因素&lt;/li&gt;
  &lt;li&gt;恢复后需要进行的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在从供应商获取技术支持的同时，一定要记得必须让最终负责备份的人参与进来。&lt;/p&gt;

&lt;h3 id=&quot;2049-测试备份系统&quot;&gt;20.4.9 测试备份系统&lt;/h3&gt;

&lt;p&gt;实际上，对备份系统的测试应该经常进行，最好是每次备份之后都做一次测试。如果实际情况不允许，则应该考虑一个可行的测试频率。&lt;/p&gt;

&lt;h4 id=&quot;测试哪些内容&quot;&gt;测试哪些内容&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;备份是否成功，数据是否正常复制&lt;/li&gt;
  &lt;li&gt;恢复的过程很顺利，没有故障发生&lt;/li&gt;
  &lt;li&gt;员工知道做什么，什么时候做&lt;/li&gt;
  &lt;li&gt;备份没有故障或问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据测试&quot;&gt;数据测试&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;恢复文件测试：是否可以成功地从备份中恢复单个文件？&lt;/li&gt;
  &lt;li&gt;虚拟机恢复：是否可以成功恢复虚拟机，注意检查应用程序的授权冲突&lt;/li&gt;
  &lt;li&gt;物理服务器的恢复可能会因硬件配置而异，有些从 SAN 恢复，有些从本地磁盘恢复，确保了解各自的恢复方法。&lt;/li&gt;
  &lt;li&gt;数据恢复也可能不同。但是，如果以应用级备份了数据库，应该检查是否能恢复。&lt;/li&gt;
  &lt;li&gt;程序的恢复更复杂。需要了解程序与其服务器的关系，最好能在隔离的环境中测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;测试计划&quot;&gt;测试计划&lt;/h4&gt;

&lt;p&gt;一旦确认备份系统工作正常，就可以制定测试计划了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;制定一个基于时间的计划。例如，一周或一个月进行一次完整测试，周期完全由你自己制定。&lt;/li&gt;
  &lt;li&gt;制定数据发生修改后的测试计划。如，增加或升级了一个应用程序，有必要进行测试。&lt;/li&gt;
  &lt;li&gt;如果有大量的数据，应该安排测试以确保其安全。数据可能来自于一个新的程序，或者，也许是两个公司合并产生的。不管怎样，要确保最新的数据被备份下来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;205-灾难恢复&quot;&gt;20.5 灾难恢复&lt;/h2&gt;

&lt;h3 id=&quot;硬件损坏有完整备份&quot;&gt;硬件损坏，有完整备份&lt;/h3&gt;

&lt;p&gt;先处理好硬件，然后依据备份状态来复原。&lt;/p&gt;

&lt;h3 id=&quot;系统文件损坏&quot;&gt;系统文件损坏&lt;/h3&gt;

&lt;p&gt;系统文件损坏的可能原因，一方面是非正常关机，另一方面是黑客入侵。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;拔掉网线，把当前系统完整备份到其他介质，以备未来检查&lt;/li&gt;
  &lt;li&gt;检查日志文件，找出问题所在&lt;/li&gt;
  &lt;li&gt;安装新系统&lt;/li&gt;
  &lt;li&gt;系统升级，设定防火墙&lt;/li&gt;
  &lt;li&gt;修复已发现的问题&lt;/li&gt;
  &lt;li&gt;安装各项服务，恢复数据&lt;/li&gt;
  &lt;li&gt;重新上线测试&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="备份" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 19. 编译内核</title><link href="/linux/linux.cmpkernel/" rel="alternate" type="text/html" title="Linux 基础 - 19. 编译内核" /><published>2015-01-19T00:00:00+08:00</published><updated>2015-01-19T00:00:00+08:00</updated><id>/linux/linux.cmpkernel</id><content type="html" xml:base="/linux/linux.cmpkernel/">&lt;h2 id=&quot;191-内核简介&quot;&gt;19.1 内核简介&lt;/h2&gt;

&lt;p&gt;Linux 主要由 liunx 内核和一些支持模块组成。&lt;/p&gt;

&lt;h3 id=&quot;1911-内核&quot;&gt;19.1.1 内核&lt;/h3&gt;

&lt;p&gt;Kernel&lt;/p&gt;

&lt;p&gt;内核是整个操作系统的最底层，它负责了整个 &lt;strong&gt;硬件的驱动&lt;/strong&gt;，以及提供各种系统所需的 &lt;strong&gt;核心功能&lt;/strong&gt;。包括防火墙机制、是否支援 LVM 或 Quota 等文件系统。如果你的内核不认识某个最新的硬件，那么该硬件也就无法被驱动，当然也就无法使用该硬件。&lt;/p&gt;

&lt;p&gt;其实内核就是系统上面的 &lt;strong&gt;一个文件&lt;/strong&gt; 而已，其中包含了驱动主机各项硬件的 &lt;strong&gt;检测程序与驱动模块&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在开机流程中，系统读取 BIOS 并加载 MBR 内的引导程序后，就能够把该内核文件加载到内存中了。然后内核开始检测硬件，挂载根目录，获取内核模块来驱动所有的硬件，之后调用 systemd 依序启动所有系统服务。&lt;/p&gt;

&lt;p&gt;内核文件位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/&lt;/code&gt; 目录，文件名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;vmlinuz-*&lt;/code&gt;，一台主机上可以有多个内核文件，但开机时仅能选择一个来加载。多个内核文件可以实现多重启动。&lt;/p&gt;

&lt;h3 id=&quot;1912-内核源码&quot;&gt;19.1.2 内核源码&lt;/h3&gt;

&lt;h4 id=&quot;原厂内核&quot;&gt;原厂内核&lt;/h4&gt;

&lt;p&gt;各主要发行版在发布产品时，都附带内核的源代码。&lt;/p&gt;

&lt;p&gt;主要的源代码网站：&lt;/p&gt;

&lt;p&gt;CentOS 的 SRPM： http://vault.centos.org&lt;/p&gt;

&lt;p&gt;Linux 内核官网： http://www.kernel.org&lt;/p&gt;

&lt;p&gt;从 CentOS 7 开始的版本，在版本号后面会接上发布日期，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;7.1.1503&lt;/code&gt; 表示 CentOS 7.1 是在 2015 年 03 月发布的。&lt;/p&gt;

&lt;p&gt;原厂发布的源代码中，含有出厂的默认设置，便于了解内核及模块在出厂时的各项目的参数，可以更好地配合系统的默认参数来加以修改，编译的难度较低。&lt;/p&gt;

&lt;h4 id=&quot;内核补丁&quot;&gt;内核补丁&lt;/h4&gt;

&lt;p&gt;每一次发布新内核时，同时也会发布该版本与前一版本的 &lt;strong&gt;差异补丁文件&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;内核源码目录结构&quot;&gt;内核源码目录结构&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arch&lt;/code&gt;  硬件平台相关代码，每种平台一个目录，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;arm64&lt;/code&gt; 等&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;  部分块设备驱动程序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crypto&lt;/code&gt;  常用加密和散列算法（如 AES、SHA 等），还有一些压缩和 CRC 校验算法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Documentation&lt;/code&gt;  内核各部分的通用解释和注释&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;drivers&lt;/code&gt;  设备驱动程序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;firmware&lt;/code&gt;  旧硬件的固件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fs&lt;/code&gt;  内核支持的文件系统，如 xfs，nfs 等&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;  头文件。其中，和系统相关的头文件被放置在linux子目录下。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;  内核初始化代码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ipc&lt;/code&gt;  进程间通信的代码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;  内核的最核心部分，包括进程调度、定时器等，和平台相关的一部分代码放在 archmm 目录下&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lib&lt;/code&gt;  公用的函数库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mm&lt;/code&gt;  内存管理代码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;net&lt;/code&gt;  网络相关代码，实现了各种常见的网络协议。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;security&lt;/code&gt;  包括 selinux 在内的安全性设置&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sound&lt;/code&gt;  常用音频设备的驱动程序等&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;virt&lt;/code&gt;  与虚拟化有关的信息，KVM （Kernel base Virtual Machine）等&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;  配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令进行一系列编译期间操作的配置文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;README&lt;/code&gt;  编译说明文档，通常只是简要的说明，更多的文档在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Documentation&lt;/code&gt; 目录&lt;/p&gt;

&lt;h2 id=&quot;192-自定义内核&quot;&gt;19.2 自定义内核&lt;/h2&gt;

&lt;p&gt;内核是通过源代码构建而成的，如果获得了内核的源代码，可以根据需要进行修改，&lt;strong&gt;重新构建&lt;/strong&gt;，生成自定义的内核 RPM 包。&lt;/p&gt;

&lt;h3 id=&quot;1921-为什么要重新构建内核&quot;&gt;19.2.1 为什么要重新构建内核&lt;/h3&gt;

&lt;h5 id=&quot;创建自已的系统调用&quot;&gt;创建自已的系统调用&lt;/h5&gt;

&lt;p&gt;希望把自己的程序放进内核，平时使用自已的系统调用。&lt;/p&gt;

&lt;h5 id=&quot;需要新功能&quot;&gt;需要新功能&lt;/h5&gt;

&lt;p&gt;有些新版本的内核会提供一些新的功能，如果恰好是你需要的，就可以通过更新内核来获得。&lt;/p&gt;

&lt;p&gt;另外，新的内核对新的硬件支持的也更完美，能充分发挥新硬件的性能。&lt;/p&gt;

&lt;h5 id=&quot;需要精简内核&quot;&gt;需要精简内核&lt;/h5&gt;

&lt;p&gt;如果对于系统 &lt;strong&gt;稳定性&lt;/strong&gt; 要求很高，可以通过重新构建内核来删除不需要的部分。组件越少，相对来说稳定性就越有保证。&lt;/p&gt;

&lt;h5 id=&quot;提升安全性&quot;&gt;提升安全性&lt;/h5&gt;

&lt;p&gt;新版本的内核经常会修补之前的安全漏洞，提升了安全性。&lt;/p&gt;

&lt;p&gt;虽说如此，就像 CentOS Wiki 中说的，99.9% 的用户不再需要重新构建自己的内核了，大多数情况下，可能只需要构建一个 &lt;strong&gt;内核模块&lt;/strong&gt; 就能满足特定的需求。&lt;/p&gt;

&lt;h3 id=&quot;1922-构建内核流程&quot;&gt;19.2.2 构建内核流程&lt;/h3&gt;

&lt;p&gt;本文以 &lt;strong&gt;CentOS 7&lt;/strong&gt; 为例构建内核。CentOS 6 在构建过程中有部分内容&lt;a href=&quot;https://wiki.centos.org/HowTos/Custom_Kernel&quot;&gt;稍有不同&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;构建准备工作&quot;&gt;构建准备工作&lt;/h4&gt;

&lt;h5 id=&quot;构建所需工具&quot;&gt;构建所需工具&lt;/h5&gt;

&lt;p&gt;开始构建之前，准备好 &lt;strong&gt;开发工具&lt;/strong&gt; 以及一个 &lt;strong&gt;配置文件&lt;/strong&gt;。配置文件用来设定内核中哪些东西需要构建，哪些不需要。&lt;/p&gt;

&lt;p&gt;对于 CentOS，可以根据当前主机的情况，选择运行以下命令来准备开发工具：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum groupinstall &quot;Development Tools&quot;
yum install ncurses-devel
yum install hmaccalc zlib-devel binutils-devel elfutils-libelf-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者借助 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum-builddep&lt;/code&gt; 命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum-builddep -y kernel
sudo yum install -y pesign
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pesign&lt;/code&gt; 是为二进制文件签名的工具。&lt;/p&gt;

&lt;h5 id=&quot;确定系统硬件&quot;&gt;确定系统硬件&lt;/h5&gt;

&lt;p&gt;可以用以下命令统计当前主机所有硬件设备。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lscpu&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lspci&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;lsblk&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;hal-device&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;确定要保留的内核功能&quot;&gt;确定要保留的内核功能&lt;/h5&gt;

&lt;p&gt;内核功能选择的原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;确认要使用的功能，直接构建进内核&lt;/li&gt;
  &lt;li&gt;可能会用到的功能，尽量构建成模块&lt;/li&gt;
  &lt;li&gt;不了解的可以保留默认值，或构建成模块&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;取得内核-srpm&quot;&gt;取得内核 SRPM&lt;/h5&gt;

&lt;p&gt;可以从发行版软件库或 kernel.org 来下载，建议下载 SRPM，相比 Tarball 更便于构建 RPM。&lt;/p&gt;

&lt;p&gt;记住，从发行版下载的内核与从 kernel.org 下载的完全不同，即使是版本号相同。因为发行版厂商都会对原版内核进行修改和调整。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;出于对系统的保护，&lt;a href=&quot;http://www.owlriver.com/tips/non-root/&quot;&gt;CentOS 建议以普通用户的身份来构建，而不使用超级用户。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以用以下命令来下载内核 SRPM：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yumdownloader --source kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;解包-srpm&quot;&gt;解包 SRPM&lt;/h5&gt;

&lt;p&gt;使用普通用户运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -i kernel-3.10.0-862.el7.src.rpm&lt;/code&gt; 命令来解开软件包，&lt;strong&gt;SPEC 文件&lt;/strong&gt; 默认被放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SPECS&lt;/code&gt; 目录，其它的文件（内核源代码压缩包、补丁等）都被放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SOURCES&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;下一步，把内核 &lt;strong&gt;源代码&lt;/strong&gt; 解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/BUILD/kernel-*/linux-*/&lt;/code&gt; 目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SPECS
rpmbuild -bp --target=$(uname -m) kernel.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置内核&quot;&gt;配置内核&lt;/h4&gt;

&lt;h5 id=&quot;清理缓存&quot;&gt;清理缓存&lt;/h5&gt;

&lt;p&gt;如果是首次构建，本步可以省略。如果已构建过内核，建议再次构建前要清理一下缓存。&lt;/p&gt;

&lt;h6 id=&quot;make-clean&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;用于删除前一次构建残留的中间文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt; 会删除所有的目标文件和内核目标文件，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.o&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;*.ko&lt;/code&gt;，以及一些其它文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/BUILD/kernel-*/linux-*/
make clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;make-mrproper&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make mrproper&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make mrproper&lt;/code&gt; 命令会删除所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt; 要删除的文件，再加上用户的配置文件（.config）、依赖关系文件，以及其它 make config 生成的文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/BUILD/kernel-*/linux-*/
make mrproper
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;创建-config&quot;&gt;创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;本步为构建内核最重要的环节，用于选择、确定需要构建的内核功能，通常由一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 的配置文件决定。&lt;/p&gt;

&lt;p&gt;在构建内核时，&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令需要配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 来工作，该配置文件的内容为 &lt;strong&gt;内核功能列表&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 文件的内容决定了要构建内核的哪些驱动和功能，因此要花一点时间来按照准备工作中计划好的功能清单，逐项地落实到配置文件中。同时也指明了哪些需要以外部模块化的方式构建，不要构建到内核中。&lt;/p&gt;

&lt;h6 id=&quot;复制-config&quot;&gt;复制 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;该配置文件无需手动创建，可以从当前版本的配置文件 &lt;strong&gt;复制一份&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/BUILD/kernel-*/linux-*/
cp /boot/config-`uname -r`* .config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者从下载的内核源代码中复制：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/BUILD/kernel-*/linux-*/
cp configs/kernel-3.10.0-x86_64.config .config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;自定义内核配置&quot;&gt;自定义内核配置&lt;/h6&gt;

&lt;p&gt;上面得到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 可借助 &lt;code class=&quot;highlighter-rouge&quot;&gt;make menuconfig&lt;/code&gt; 做进一步的自定义。&lt;/p&gt;

&lt;p&gt;在此之前建议先备份一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp .config config.bak
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make menuconfig&lt;/code&gt; 运行的程序是一个基于 ncurse 库编写的图形界面工具，允许用户逐项进行选择要构建的内核功能等项目：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/menuconfig.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;menuconfig&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中的一个目标。&lt;/p&gt;

&lt;p&gt;程序启动时，如果当前目录存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 文件，会将该文件的配置读取到程序中对应的选项。如果不存在，则会以默认配置启动。&lt;/p&gt;

&lt;p&gt;用户使用方向键、回车键在各级菜单中导航，空格键切换选择与否，&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 键将条目模块化。&lt;/p&gt;

&lt;p&gt;退出时可以自定义要保存的配置文件名，如果之前不存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 文件，会自动保存为该文件。&lt;/p&gt;

&lt;p&gt;进行到这里，我们已经获得了自定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 文件。&lt;/p&gt;

&lt;h6 id=&quot;更新-config&quot;&gt;更新 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;我们需要把修改好的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 放回 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/BUILD/kernel-*/linux-*/configs/&lt;/code&gt; 目录，但之前，还要在其第一行加入当前系统的硬件平台信息，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(uname -i)&lt;/code&gt; 的值，64 位 PC 上通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;x86_64&lt;/code&gt;，前面要加上注释井号：&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 最前面加上一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;.config&lt;/code&gt; 文件拷回 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/&lt;/code&gt; 目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp .config configs/kernel-3.10.0-`uname -m`.config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一步，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/&lt;/code&gt; 目录中所有文件拷到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SOURCES/&lt;/code&gt; 目录中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp configs/* ~/rpmbuild/SOURCES/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;内核-abi&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux_kernel_interfaces#Linux_ABI&quot;&gt;内核 ABI&lt;/a&gt;&lt;/h4&gt;

&lt;h5 id=&quot;linux-abi-简介&quot;&gt;Linux ABI 简介&lt;/h5&gt;

&lt;p&gt;Application Binary Interface&lt;/p&gt;

&lt;p&gt;ABI 定义了两个软件模块在特定硬件平台上的二进制接口。它定义了应用内部如何交互，应用如何与内核交互，以及如何和库交互。&lt;/p&gt;

&lt;p&gt;Linux ABI 是指 &lt;code class=&quot;highlighter-rouge&quot;&gt;内核-用户空间&lt;/code&gt; 的 ABI。该 ABI 是指编译好的二进制程序，任何这样的 ABI 都被绑定到指令集中。对于每种不同的硬件平台都要定义各自的指令集的 ABI。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;API，是编程的接口，编写应用程序时候调用的函数之类的东西。对于内核来说，它的 “应用程序” 有两种：一种是在它之上的，用户空间的真正的应用程序，内核给它们提供的是系统调用这种接口，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;read(2)&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;write(2)&lt;/code&gt;；另一种就是内核模块了，它们和内核处于同一层，内核给它们提供的是导出的内核函数，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;kmalloc()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;printk()&lt;/code&gt;。这些接口都是你可以在编写程序的时候直接看到的，可以直接拿来用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;而 ABI 是另一种形式的接口，二进制接口。除非你直接使用汇编语言，这种接口一般是不能直接拿来用的。比如，内核系统调用用哪些寄存器或者干脆用堆栈来传递参数，返回值又是通过哪个寄存器传递回去，内核里面定义的某个结构体的某个字段偏移是多少等等，这些都是二进制层面上的接口。这些接口是直接给 &lt;strong&gt;编译好的&lt;/strong&gt; 二进制用的。换句话说，如果 ABI 保持稳定的话，你在之前版本上编译好的二进制应用程序、内核模块，完全可以无须重新编译直接在新版本上运行。另一种比较特殊的 ABI 是像 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/sys&lt;/code&gt; 目录下面导出的文件，它们虽然不是直接的二进制形式，但也会影响编译出来的二进制，如果它里面使用到它们的话，因此这些 “接口” 也是一种 ABI。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;禁用-kabi-检查&quot;&gt;禁用 kABI 检查&lt;/h5&gt;

&lt;p&gt;CentOS 内核有一个特点，它的 ABI 在整个产品周期内始终保留，拥有一个持续稳定的 ABI 有很大的好处，外部的内核模块可以独立于内核版本来构建，因此无需为每个新版本的内核重新构建。&lt;/p&gt;

&lt;p&gt;为了维护 ABI 的一致性，原始的内核 ABI 被记录下来，并保存在一个文件中。构建每个新内核时，该文件都用于进行内核 ABI 的检查。如果新内核配置或修改的方式与已发布的 ABI 不一致，则构建将失败，并显示一条消息，指出发生了 kABI 破坏。此时可以选择重新配置新内核以适应现有的 ABI，或者在构建过程中禁用对 KABI 的检查。&lt;/p&gt;

&lt;p&gt;禁用对 kABI 的检查：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpmbuild --without kabichk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;修改内核-spec-文件&quot;&gt;修改内核 SPEC 文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SPECS/
cp kernel.spec kernel.spec.distro
vi kernel.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;修改-buildid&quot;&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;buildid&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;通常定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;buildid&lt;/code&gt; 的语句会被注释，需将其取消注释：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%define buildid .my_identifier
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; 之前不能有空格。&lt;/p&gt;

&lt;h5 id=&quot;应用补丁&quot;&gt;应用补丁&lt;/h5&gt;

&lt;p&gt;如果没有补丁要应用，则忽略此步。如果有，需要在两处引用：&lt;/p&gt;

&lt;p&gt;第一处：&lt;/p&gt;

&lt;p&gt;找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;# empty final patch to facilitate testing of kernel patches&lt;/code&gt; 段落，在这一行下面增加一行，用数字 40000 声明，以便补丁不会与内核补丁冲突：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Patch40000: my-custom-kernel.patch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二处：&lt;/p&gt;

&lt;p&gt;找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;ApplyOptionalPatch linux-kernel-test.patch&lt;/code&gt; 段落，在该行之前增加一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ApplyOptionalPatch my-custom-kernel.patch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;构建新内核&quot;&gt;构建新内核&lt;/h4&gt;

&lt;p&gt;开始构建：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SPECS/
rpmbuild -bb --target=`uname -m` kernel.spec 2&amp;gt; build-err.log | tee build-out.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建命令中，如有需要，可以选择一些有用的选项，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--with&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;--without&lt;/code&gt; 标签：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--with baseonly
--without up
--without debug
--without debuginfo
--without fips
--without kabichk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如，只构建最基本的内核：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--with baseonly --without debug --without debuginfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;安装新内核&quot;&gt;安装新内核&lt;/h4&gt;

&lt;p&gt;构建完成后，自定义的新内核 RPM 文件保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/RPMS/&lt;/code&gt; 中的硬件平台的子目录中。&lt;/p&gt;

&lt;p&gt;切换到超级用户后，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt; 来安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum localinstall kernel-*.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -ivh kernel-*.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令安装，需注意提前必须安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-devel&lt;/code&gt;，不是更新，而是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -ivh&lt;/code&gt; 安装。&lt;/p&gt;

&lt;p&gt;如果构建了一个比当前安装的内核版本低的内核，安装时需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--oldpackage&lt;/code&gt; 标签。&lt;/p&gt;

&lt;h2 id=&quot;193-内核模块&quot;&gt;19.3 内核模块&lt;/h2&gt;

&lt;h3 id=&quot;1931-内核模块简介&quot;&gt;19.3.1 内核模块简介&lt;/h3&gt;

&lt;p&gt;Loadable Kernel Module，LKM，内核模块是一种 &lt;strong&gt;目标文件&lt;/strong&gt;，其中包含了能在内核空间运行的代码。&lt;/p&gt;

&lt;p&gt;内核模块是单独的代码，运行在 base kernel，通常用来支持新的硬件、文件系统、系统调用，需要时可以动态地加载或卸载，可以最小化内核的内存占用。&lt;/p&gt;

&lt;p&gt;Linux 内核之所以提供模块机制，是因为它本身是一个单内核（monolithic kernel）。单内核的最大优点是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。借助内核模块，可以轻松地扩展基础内核的功能，而无需重新构建内核。&lt;/p&gt;

&lt;p&gt;内核模块的扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.ko&lt;/code&gt;，通常位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/$(uname -r)/kernel/&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;内核模块是要运行在内核态的代码，所以编写内核模块需要包含的头文件都是内核中的头文件，使用的函数都是内核的函数。&lt;/p&gt;

&lt;h4 id=&quot;内部模块&quot;&gt;内部模块&lt;/h4&gt;

&lt;p&gt;In-tree build&lt;/p&gt;

&lt;p&gt;内部模块是与内核其它部分一起构建的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内核的源代码其结构也是树形的，习惯性地称为 source tree，因此随内核一同发布的内核模块可以称为内部模块，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;in-tree&lt;/code&gt; module。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;外部模块&quot;&gt;外部模块&lt;/h4&gt;

&lt;p&gt;Out-of-tree build&lt;/p&gt;

&lt;p&gt;外部模块是在 &lt;strong&gt;独立的软件包&lt;/strong&gt; 中构建的，并且是针对某个 &lt;strong&gt;特定的内核版本&lt;/strong&gt; 构建的。&lt;/p&gt;

&lt;h4 id=&quot;动态内核模块&quot;&gt;动态内核模块&lt;/h4&gt;

&lt;p&gt;Dynamic Kernel Module Support，DKMS，动态内核模块支持&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;DKMS 是一个 &lt;strong&gt;程序框架&lt;/strong&gt;，可以编译内核代码树之外的模块。升级内核时，通过 DKMS 管理的内核模块可以被 &lt;strong&gt;自动重新构建&lt;/strong&gt; 以适应新的内核版本。&lt;/p&gt;

&lt;p&gt;无需等待软件包维护者发布最新版本的内核模块，内核更新时会自动生成和安装新的软件包。&lt;/p&gt;

&lt;p&gt;动态内核模块支持框架基本上是内核源代码树的副本，存在于内核源代码之外，保存着特定模块的源代码以及二进制文件。可通过调用 DKMS 来构建、安装、卸载模块。DKMS 要求模块的源代码必须保存在系统中。DKMS 的二进制文件负责构建、安装模块。&lt;/p&gt;

&lt;p&gt;DKMS 可以用在两个方向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内核版本升级&lt;/strong&gt; 时，自动编译所有的模块。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;旧系统装新模块&lt;/strong&gt;，无需手动编译或预编译软件包。使得新显卡可以用在旧系统上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DKMS 由一个用户层的 DKM 服务器来管理，并非由内核来管理。当核心需要某模块时，由 DKM 服务器负责把相应的 DKM 加载；当内核的内存资源紧缺时，由 DKM 服务器负责卸载没有被使用的 DKM。&lt;/p&gt;

&lt;h3 id=&quot;1932-内核模块的构建&quot;&gt;19.3.2 内核模块的构建&lt;/h3&gt;

&lt;h4 id=&quot;构建相关软件包&quot;&gt;构建相关软件包&lt;/h4&gt;

&lt;p&gt;构建内核模块时，根据不同的硬件平台和不同的功能需求，可能需要安装不同的内核软件包：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;  ：包含支持多处理器系统的内核，对于 x86 系统，只能使用前 4GB 内存&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-devel&lt;/code&gt;  ：包含内核头文件及 makefile，便于构建针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 包的模块&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-PAE&lt;/code&gt;  ：仅适用于 i686 系统，除支持 kernel 包的选项之外，还支持&lt;/p&gt;

&lt;p&gt;超过 4GB 内存（x86 最高到 64GB）；&lt;/p&gt;

&lt;p&gt;支持 PAE，Physical Address Extension，物理地址扩展，或在支持 PAE 的 x86 处理器上使用三级页面；&lt;/p&gt;

&lt;p&gt;内核可使用 4GB 虚拟地址空间，在 x86 系统中，每用户进程可使用接近 4GB 地址空间。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-PAE-devel&lt;/code&gt;  ：包含内核头文件及 makefile，用于构建针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-PAE&lt;/code&gt; 包的模块&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-xen&lt;/code&gt;  ：包含运行虚拟机所需要的内核&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-xen-devel&lt;/code&gt;  ：包含内核头文件及 makefile，用于构建针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-xen&lt;/code&gt; 包的模块&lt;/p&gt;

&lt;h4 id=&quot;kbuild&quot;&gt;KBUILD&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kbuild&lt;/code&gt; 是早期专门用于构建外部模块的工具，它需要提前编译好的完整的内核。实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;kbuild&lt;/code&gt; 不是一个程序，它是由一系列内置于内核的脚本组成的，其构建的过程也是靠 make 来完成的。&lt;/p&gt;

&lt;p&gt;构建模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make -C &amp;lt;path to kernel src&amp;gt; M=$PWD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make -C &amp;lt;path to kernel src&amp;gt; M=$PWD modules_install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;dkms&quot;&gt;DKMS&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms&lt;/code&gt; 命令用于动态内核模块的管理。它会把模块编译、安装到内核代码树中，卸载模块时，可以恢复之前版本的模块。&lt;/p&gt;

&lt;p&gt;默认情况下，会把模块安装到当前的内核代码树，可以通过选项来指定特定的代码树来安装。&lt;/p&gt;

&lt;p&gt;要想使用 DKMS 来管理模块，首先要把模块的代码放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src/&lt;/code&gt; 目录中，同时还需要一个配套的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.conf&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;p&gt;DKMS 还支持基于条件的构建、打补丁等。&lt;/p&gt;

&lt;h5 id=&quot;语法&quot;&gt;语法&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dkms &amp;lt;command&amp;gt; &amp;lt;module&amp;gt;/&amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms autoinstall&lt;/code&gt;  重新构建模块&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms uninstall&lt;/code&gt;  将模块从内核删除&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms remove&lt;/code&gt;  将 &lt;moudle&gt;/&lt;moudule-version&gt; 从 DKMS 目录树删除&lt;/moudule-version&gt;&lt;/moudle&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms status&lt;/code&gt;  查看 DKMS 的当前状态、版本，包括源码树内的模块&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms mkrpm&lt;/code&gt;  在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/dkms/&amp;lt;module&amp;gt;/&amp;lt;module-version&amp;gt;/rpm/&lt;/code&gt; 目录中生成一个 RPM 文件&lt;/p&gt;

&lt;h3 id=&quot;1933-模块管理工具&quot;&gt;19.3.3 模块管理工具&lt;/h3&gt;

&lt;h4 id=&quot;查看模块信息&quot;&gt;查看模块信息&lt;/h4&gt;

&lt;p&gt;模块名通常使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 连接，但是这些符号在 modprobe 命令和 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modprobe.d/&lt;/code&gt; 配置文件中都是可以相互替换的。&lt;/p&gt;

&lt;h5 id=&quot;查看内核中已加载的模块&quot;&gt;查看内核中已加载的模块：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ lsmod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;查询内核模块的信息&quot;&gt;查询内核模块的信息：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ modinfo module_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;查看所有模块的配置信息&quot;&gt;查看所有模块的配置信息：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ modprobe -c | less
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modprobe&lt;/code&gt; 用于向内核中增加、删除模块。它很智能，会基于模块依赖关系进行加载、卸载的操作。&lt;/p&gt;

&lt;h5 id=&quot;查看某个模块的配置信息&quot;&gt;查看某个模块的配置信息：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ modprobe -c | grep module_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;查看已加载模块所用的选项&quot;&gt;查看已加载模块所用的选项：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systool -v -m module_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;查看模块的依赖关系&quot;&gt;查看模块的依赖关系：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ modprobe --show-depends module_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;自动加载模块&quot;&gt;自动加载模块&lt;/h4&gt;

&lt;p&gt;目前，所有必要模块的加载均由 udev 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。&lt;/p&gt;

&lt;p&gt;systemd 读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modules-load.d/&lt;/code&gt; 中的配置文件，加载额外的内核模块。配置文件名称通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modules-load.d/&amp;lt;program&amp;gt;.conf&lt;/code&gt;。格式很简单，一行一个要读取的模块名，而空行以及第一个非空格字符为 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; 的行会被忽略，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Load virtio-net.ko at boot
virtio-net
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;手动加载卸载模块&quot;&gt;手动加载卸载模块&lt;/h4&gt;

&lt;p&gt;控制内核模块载入/移除的命令是 kmod 软件包提供的, 要手动加载模块的话，执行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# modprobe _module_name_
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;按文件名加载模块:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# insmod filename [args]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;如果升级了内核但是没有重启，路径 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/modules/$(uname -r)/&lt;/code&gt; 已经不存在。&lt;code class=&quot;highlighter-rouge&quot;&gt;modprobe&lt;/code&gt; 会返回错误 1，没有额外的错误信息。如果出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;modprobe&lt;/code&gt; 加载失败，请检查模块路径以确认是否是这个问题导致。&lt;/p&gt;

&lt;p&gt;如果要移除一个模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# modprobe -r _module_name_
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# rmmod _module_name_
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置模块参数&quot;&gt;配置模块参数&lt;/h4&gt;

&lt;h5 id=&quot;手动加载时设置&quot;&gt;手动加载时设置&lt;/h5&gt;

&lt;p&gt;传递参数的基本方式是使用 modprobe 选项，格式是 &lt;code class=&quot;highlighter-rouge&quot;&gt;key=value&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# modprobe module_name parameter_name=parameter_value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;使用-etcmodprobed中的文件&quot;&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modprobe.d/&lt;/code&gt;中的文件&lt;/h5&gt;

&lt;p&gt;要通过配置文件传递参数，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modprobe.d/&lt;/code&gt; 中放入任意名称 &lt;code class=&quot;highlighter-rouge&quot;&gt;.conf&lt;/code&gt; 文件，加入:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;options modname parametername=parametercontents
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# On thinkpads, this lets the thinkfan daemon control fan speed
options thinkpad_acpi fan_control=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;使用内核命令行&quot;&gt;使用内核命令行&lt;/h5&gt;

&lt;p&gt;如果模块直接编译进内核，也可以通过启动管理器 GRUB 的内核行加入参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modname.parametername=parametercontents
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;thinkpad_acpi.fan_control=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;别名&quot;&gt;别名&lt;/h4&gt;

&lt;p&gt;有些模块具有别名，以方便其它程序自动加载模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Lets you use 'mymod' in MODULES, instead of 'really_long_module_name'
alias mymod really_long_module_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;禁用&lt;/strong&gt; 这些别名可以阻止自动加载，但是仍然可以手动加载：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Prevent autoload of bluetooth
alias net-pf-31 off

# Prevent autoload of ipv6
alias net-pf-10 off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;禁用内核模块&quot;&gt;禁用内核模块&lt;/h4&gt;

&lt;p&gt;对内核模块来说，黑名单是指禁止某个模块加载的机制。当对应的硬件不存在或者加载某个模块会导致问题时很有用。&lt;/p&gt;

&lt;h5 id=&quot;使用-etcmodprobed-中的文件&quot;&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modprobe.d/&lt;/code&gt; 中的文件&lt;/h5&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modprobe.d/&lt;/code&gt; 中创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;.conf&lt;/code&gt; 文件，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;blacklist&lt;/code&gt; 关键字屏蔽不需要的模块，例如如果不想加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;pcspkr&lt;/code&gt; 模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Do not load the pcspkr module on boot
blacklist pcspkr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;blacklist&lt;/code&gt; 命令将屏蔽一个模块，所以 &lt;strong&gt;不会自动加载&lt;/strong&gt;，但是如果其它非屏蔽模块需要这个模块，系统依然会加载它。&lt;/p&gt;

&lt;p&gt;要避免这个行为，可以让 modprobe 使用自定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt; 命令，直接返回导入失败：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/modprobe.d/blacklist.conf
...
install MODULE /bin/false
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以屏蔽模块及所有依赖它的模块。&lt;/p&gt;

&lt;h5 id=&quot;使用内核命令行-1&quot;&gt;使用内核命令行&lt;/h5&gt;

&lt;p&gt;同样可以通过内核命令行禁用模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modprobe.blacklist=modname1,modname2,modname3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当某个模块导致系统无法启动时，可以使用此方法禁用模块。&lt;/p&gt;

&lt;h4 id=&quot;模块未加载问题处理&quot;&gt;模块未加载问题处理&lt;/h4&gt;

&lt;p&gt;如果出现模块在启动时未加载，而且启动日志中 &lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl -b&lt;/code&gt; 显示模块被屏蔽，但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modprobe.d/&lt;/code&gt; 中未找到屏蔽设置，请检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/modprobe.d/&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vermagic&lt;/code&gt; 字符串与内核不一致的模块不会被加载，如果确认模块与当前内核兼容，可以用  &lt;code class=&quot;highlighter-rouge&quot;&gt;modprobe --force-vermagic&lt;/code&gt; 参数加载，跳过检查。&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;忽略模块检查，可能因为不兼容导致系统崩溃或不可预知行为，请谨慎使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--force-vermagic&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1934-编译内核模块&quot;&gt;19.3.4 编译内核模块&lt;/h3&gt;

&lt;h4 id=&quot;编译内部模块&quot;&gt;编译内部模块&lt;/h4&gt;

&lt;p&gt;编译内部模块有明显的劣势，因为它依赖于编译时的内核版本，一旦要在新版本的内核中使用，或硬件架构有所变化，就必须重新编译。&lt;/p&gt;

&lt;p&gt;假设在为 cifs 内核模块应用了一次更新补丁之后，现在要重新构建该模块。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/BUILD/kernel-2.6.18/linux-2.6.18-i686/fs/cifs/&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;应用更新补丁文件&quot;&gt;应用更新补丁文件&lt;/h5&gt;

&lt;h5 id=&quot;配置内核-1&quot;&gt;配置内核&lt;/h5&gt;

&lt;p&gt;切换到内核源代码根目录，如果是首次编译该内核，进行必要的配置，务必确保 cifs 做为模块构建。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rmpbuild/BUILD/kernel-2.6.18/linux-2.6.18-i686
make oldconfig
make menuconfig
make prepare
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;更新内核源文件&quot;&gt;更新内核源文件&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make modules_prepare
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上，编译单独的内核模块之前，如果能先把内核完整地编译一遍是最好的，因为构建过程会生成构建模块所需要的配置信息及头文件。当然不编译内核也是可以的，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make modules_prepare&lt;/code&gt; 命令来 &lt;strong&gt;确保内核源代码包含构建模块所需要的信息&lt;/strong&gt;。这个目标的存在基本上就是为了这个目的。&lt;/p&gt;

&lt;p&gt;但 &lt;code class=&quot;highlighter-rouge&quot;&gt;make modules_prepare&lt;/code&gt; 不会构建 &lt;code class=&quot;highlighter-rouge&quot;&gt;Module.symvers&lt;/code&gt;，即使设置了 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONFIG_MODVERSIONS&lt;/code&gt;。因此，要想让模块的版本正常工作，还是需要完整地编译内核的。&lt;/p&gt;

&lt;h5 id=&quot;编译模块&quot;&gt;编译模块&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make M=fs/cifs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过把模块的相对路径做为参数，来编译该模块。&lt;/p&gt;

&lt;p&gt;模块所在的目录可以放置于任何地方。例如：如果将其放置在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/mycifs/&lt;/code&gt; 目录，则上面的命令可以修改为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make M=~/mycifs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;剥离冗余符号&quot;&gt;剥离冗余符号&lt;/h5&gt;

&lt;p&gt;如果编译该模块不是为了调试，此时需要剥离掉无用的符号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strip --strip-debug fs/cifs/cifs.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;复制到系统模块目录&quot;&gt;复制到系统模块目录&lt;/h5&gt;

&lt;p&gt;用超级用户权限把构建好的模块复制到模块目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo cp fs/cifs/cifs.ko /lib/modules/`uname -r`/extra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;更新模块依赖关系&quot;&gt;更新模块依赖关系&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo depmod -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;更新内核源代码版本号&quot;&gt;更新内核源代码版本号&lt;/h5&gt;

&lt;p&gt;修改内核源代码根目录中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;，更新其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXTRAVERSION&lt;/code&gt; 变量的值，额外版本号可以是以下形式的一种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXTRAVERSION = -419.el5
EXTRAVERSION = -419.el5PAE
EXTRAVERSION = -419.el5xen
EXTRAVERSION = -419.el5.centos.plus
EXTRAVERSION = -419.el5.centos.plusPAE
EXTRAVERSION = -419.el5.centos.plusxen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在编译完标准内核的模块之后，更新 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXTRAVERSION&lt;/code&gt; 变量，然后运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make modules_prepare&lt;/code&gt;，最后运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make M=fs/cifs&lt;/code&gt; 来构建带新版本号的模块。&lt;/p&gt;

&lt;h4 id=&quot;构建动态模块&quot;&gt;构建动态模块&lt;/h4&gt;

&lt;p&gt;使用 DKMS 来构建内核模块。&lt;/p&gt;

&lt;p&gt;使用与上面相同的例子来构建、安装 cifs 模块。整个过程都要用 &lt;strong&gt;root&lt;/strong&gt; 来操作。&lt;/p&gt;

&lt;p&gt;目前模块源代码在这里： &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/BUILD/kernel-2.6.18/linux-2.6.18-i686/fs/cifs/&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;安装开发工具包&quot;&gt;安装开发工具包&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum update kernel*
reboot
......
yum install kernel-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;安装-dkms-软件包&quot;&gt;安装 DKMS 软件包&lt;/h5&gt;

&lt;p&gt;从 EPEL 软件库安装 dkms 软件包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo 
yum clean all
yum install dkms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;创建源代码目录&quot;&gt;创建源代码目录&lt;/h5&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src/&lt;/code&gt; 目录中创建模块目录，命名格式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;module&amp;gt;-&amp;lt;module-version&amp;gt;&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir /usr/src/cifs-1.45fixed/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;复制源代码&quot;&gt;复制源代码&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/BUILD/kernel-2.6.18/linux-2.6.18-i686/fs/cifs
cp -a * /usr/src/cifs-1.45fixed/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;创建模块配置文件&quot;&gt;创建模块配置文件&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/src/cifs-1.45fixed
vi dkms.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms.conf&lt;/code&gt; 需要包含以下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PACKAGE_NAME=&quot;cifs&quot;
PACKAGE_VERSION=&quot;1.45fixed&quot;
BUILT_MODULE_NAME[0]=&quot;cifs&quot;
DEST_MODULE_LOCATION[0]=&quot;/kernel/fs/cifs/&quot;
AUTOINSTALL=&quot;yes&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DEST_MODULE_LOCATION[0]&lt;/code&gt; 参数仅在 &lt;strong&gt;替换&lt;/strong&gt; 了某个 &lt;strong&gt;内部模块&lt;/strong&gt; 时才使用。所以其值在安装模块时会被忽略，因为模块始终会被安装到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&amp;lt;kernel-version&amp;gt;/extra/&lt;/code&gt; 目录中。用这个参数的目的是，卸载该外部模块时，之前被替换的 &lt;strong&gt;旧的内部模块&lt;/strong&gt; 应该被 &lt;strong&gt;恢复&lt;/strong&gt; 到该位置。&lt;/p&gt;

&lt;h5 id=&quot;加入-dkms-目录树&quot;&gt;加入 DKMS 目录树&lt;/h5&gt;

&lt;p&gt;把 &lt;module&gt;/&lt;module-version&gt; 加入 DKMS 目录树。&lt;/module-version&gt;&lt;/module&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dkms add -m cifs/1.45fixed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DKMS 会创建符号链接 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/dkms/cifs/1.45fixed/source/&lt;/code&gt;，指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src/cifs-1.45fixed&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;在-dkms-的控制下构建模块&quot;&gt;在 DKMS 的控制下构建模块&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dkms build -m cifs/1.45fixed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;在-dkms-的控制下安装模块&quot;&gt;在 DKMS 的控制下安装模块&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dkms install -m cifs/1.45fixed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="kernel" /><category term="linux" /><category term="编译" /><category term="内核" /></entry><entry><title type="html">Linux 基础 - 18. 软件包的管理</title><link href="/linux/linux.rpm/" rel="alternate" type="text/html" title="Linux 基础 - 18. 软件包的管理" /><published>2015-01-18T00:00:00+08:00</published><updated>2015-01-18T00:00:00+08:00</updated><id>/linux/linux.rpm</id><content type="html" xml:base="/linux/linux.rpm/">&lt;h2 id=&quot;181-rpm&quot;&gt;18.1 RPM&lt;/h2&gt;

&lt;h3 id=&quot;1811-软件包的安装方式&quot;&gt;18.1.1 软件包的安装方式&lt;/h3&gt;

&lt;h4 id=&quot;普通安装方式&quot;&gt;普通安装方式&lt;/h4&gt;

&lt;p&gt;Linux 开发商先在固定的硬件平台与操作系统平台上，把需要安装或升级的软件编译好，然后将相关文件打包成为一个特殊格式的文件，其中还包含了检测系统和所需软件的脚本，并记录该软件提供的所有文件信息。最终发布。&lt;/p&gt;

&lt;p&gt;用户下载文件后，使用特定的命令安装，该软件先 &lt;strong&gt;按检测安装环境&lt;/strong&gt; 是否满足，满足则安装。&lt;/p&gt;

&lt;p&gt;安装完成后会 &lt;strong&gt;把该软件的信息写入软件管理机制&lt;/strong&gt; 中，以备将来升级、卸载。&lt;/p&gt;

&lt;p&gt;当前在 Linux 业内最常见的安装方式为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;dpkg&lt;/strong&gt;：Debian Package，Debian 开发，安装包为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 格式。dpkg 是比较底层的工具。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RPM&lt;/strong&gt;：Red Hat Package Manager，由 Red Hat 开发，后被很多发行版采用，包括 Fedora，CentOS，SuSE 等。安装包为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.rpm&lt;/code&gt; 格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;dpkg 和 rpm 都无法解决安装环境对其它软件的 &lt;strong&gt;依赖&lt;/strong&gt; 的问题，即如果系统中没有安装特定的软件，该软件就无法正常运行。&lt;/p&gt;

&lt;h4 id=&quot;在线安装方式&quot;&gt;在线安装方式&lt;/h4&gt;

&lt;p&gt;因此，为了解决这个问题，各家开发了 &lt;strong&gt;在线安装机制&lt;/strong&gt;，在安装某一软件时，如果该软件所依赖的其它软件在系统中不存在，则会先在线自动安装它们，待所有这些软件安装完毕之后，再安装目标软件。&lt;/p&gt;

&lt;p&gt;在 dpkg 基础上开发了 &lt;strong&gt;APT&lt;/strong&gt;（Advanced Packaging Tool） ，在 RPM 基础上开发了 &lt;strong&gt;yum&lt;/strong&gt;（Yellowdog Updater, Modified），这两种在线安装机制。&lt;/p&gt;

&lt;p&gt;📕 dpkg 和 RPM 均是底层的机制，对应发展出来的 APT 和 yum 机制为更高层的机制。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;发行版&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;软件管理机制&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;命令&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;在线安装命令&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Red Hat/Fedora&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RPM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;rpm，rpmbuild&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;yum&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Debian/Ubuntu&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DPKG&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dpkg&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;apt-get&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p class=&quot;notice--info&quot;&gt;CentOS 使用的软件管理机制为 &lt;strong&gt;RPM 机制&lt;/strong&gt;，在线安装使用 &lt;strong&gt;yum&lt;/strong&gt; 命令。&lt;/p&gt;

&lt;h3 id=&quot;1812-rpm-机制&quot;&gt;18.1.2 RPM 机制&lt;/h3&gt;

&lt;p&gt;RPM 是以一种记录数据库的方式将软件安装到 Linux 系统的管理机制，其 &lt;strong&gt;RPM 数据库&lt;/strong&gt; 保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/rpm/&lt;/code&gt; 目录中。&lt;/p&gt;

&lt;p&gt;安装软件时，RPM 先检查该软件所需要的其它软件是否有安装，满足则安装，不满足则不安装。安装时把该软件的信息完整地写入 RPM 的数据库中，以便将来的查询、验证和卸载。&lt;/p&gt;

&lt;h4 id=&quot;rpm-优点&quot;&gt;RPM 优点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RPM 已经编译过，打包后更利于传输和安装&lt;/li&gt;
  &lt;li&gt;RPM 使用数据库记录 RPM 文件的相关参数，便于升级、移除、查询与验证&lt;/li&gt;
  &lt;li&gt;RPM 在被安装之前，先检查系统的磁盘空间、操作系统版本等，可避免文件被错误安装&lt;/li&gt;
  &lt;li&gt;RPM 文件包含软件版本信息、依赖软件、软件用途、包含文件等信息，易于了解软件安装时会把这些信息保存到 RPM 数据库中&lt;/li&gt;
  &lt;li&gt;RPM 使用数据库记录 RPM 文件的相关参数，便于升级、移除、查询与验证&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rpm-缺点&quot;&gt;RPM 缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;软件安装环境必须与打包时的环境一致&lt;/li&gt;
  &lt;li&gt;所依赖的其它软件必须已经安装&lt;/li&gt;
  &lt;li&gt;卸载时，如果先卸载底层软件容易出问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;brpm--srpm&quot;&gt;BRPM / SRPM&lt;/h4&gt;

&lt;p&gt;一个 RPM 软件包可以包含任意多组文件，最常见的 RPM 文件是 &lt;strong&gt;二进制&lt;/strong&gt; RPM，即 BRPM，Binary RPM，包含编译好的软件。&lt;/p&gt;

&lt;p&gt;另外还有一种 RPM 叫 SRPM，Source RPM，文件中包含 &lt;strong&gt;源代码&lt;/strong&gt;，用来生成软件包。这类的文件在其文件头中含有适当的标签，用来与普通的 RPM 区分开，这样在安装时，其中的文件在安装过程中就会被解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src&lt;/code&gt; 目录。SRPM 其扩展名通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.src.rpm&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;SRPM 同样含有该软件的依赖说明、以及其它 RPM 该有的文件。与 BRPM 不同的是，其中包含了参数配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;格式&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;文件名&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;允许直接安装&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;内含程序类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;允许修改参数来编译&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BRPM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;xxx.rpm&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;已编译的二进制&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SRPM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;xxx.src.rpm&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;未编译的源代码&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;rpm-文件命名&quot;&gt;RPM 文件命名&lt;/h4&gt;

&lt;p&gt;RPM 文件名描述了软件的版本、适用的平台、编译发布的次数。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/rpm.naming.convention.png&quot; alt=&quot;RPM 命名规则&quot; /&gt;
  
&lt;/figure&gt;

&lt;p&gt;发布次数通常就是编译的次数。&lt;/p&gt;

&lt;p&gt;硬件平台：不同的平台设置的参数有所不同。可以针对比较高级的 CPU 进行参数优化。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;平台名称&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;i386&lt;/td&gt;
      &lt;td&gt;几乎适用于所有 x86 平台，不论是旧的 pentum 还是 Intel Core 2 与 K8 系列的 CPU 等，都可以正常的工作。i 指的是 Intel 兼容的 CPU，386 是 CPU 的等级。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i586&lt;/td&gt;
      &lt;td&gt;针对 586 等级的计算机进行最优化编译。pentum 第一代 MMX CPU，AMD  K5，K6 系列 CPU（socket 7 插槽） 等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i686&lt;/td&gt;
      &lt;td&gt;pentun II 以后的 Intel 系列 CPU，及 K7 以后的 CPU&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x86_64&lt;/td&gt;
      &lt;td&gt;针对 64 位的 CPU 进行最优化编译，Intel Core 2 以上，AMD Athlon64 以上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;noarch&lt;/td&gt;
      &lt;td&gt;没有硬件等级的限制。这种 RPM 文件通常不包含二进制文件，一般有脚本文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;srpm-文件名&quot;&gt;SRPM 文件名&lt;/h5&gt;

&lt;p&gt;SRPM 文件名通常是这样：&lt;code class=&quot;highlighter-rouge&quot;&gt;foo-2.3.5-1.mga1.src.rpm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其它元素都与 BRPM 相同，只是硬件平台那部分变成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;tarball-文件名&quot;&gt;Tarball 文件名&lt;/h5&gt;

&lt;p&gt;而  Tarball 文件名通常是 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo-2.3.5.tar.bz2&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;rpm-软件包的结构&quot;&gt;RPM 软件包的结构&lt;/h4&gt;

&lt;p&gt;通常情况下，一个 BRPM 软件包里包含共享库、程序、帮助文档等，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/lib64/libfoo.so
/usr/bin/foo
/usr/share/doc/foo/README
/usr/share/man/man1/foo.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;SRPM 一般是一个 Tarball，再加上一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;specfile&lt;/code&gt;，也许会有更新补丁等其他文件（如桌面文件或图标），如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SPECS/foo.spec
SOURCES/foo-2.3.5.tar.bz2
SOURCES/foo-2.3.5-path-to-fix-specific-bug.patch
SOURCES/foo.desktop
SOURCES/foo.png
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;rpm-默认安装路径&quot;&gt;RPM 默认安装路径&lt;/h4&gt;

&lt;p&gt;RPM 软件包安装默认的路径：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;目录&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;配置文件，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/crontab&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/usr/bin/&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可执行文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/usr/lib/&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;动态共享库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/usr/share/doc/&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;软件使用手册与说明文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/usr/share/man/&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;man page&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;rpm-数据库&quot;&gt;RPM 数据库&lt;/h4&gt;

&lt;p&gt;RPM 文件安装完毕后，该软件的信息会被写入 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/rpm/&lt;/code&gt;&lt;/strong&gt; 目录下的数据库文件中。&lt;/p&gt;

&lt;p&gt;之后在软件需要升级时，依靠该数据库来进行版本之间的比较。&lt;/p&gt;

&lt;p&gt;借助该数据库可以查询当前系统已安装的软件。&lt;/p&gt;

&lt;p&gt;该目录中还包含当前的 RPM 数字签名信息。&lt;/p&gt;

&lt;h4 id=&quot;rpm-vs-tarball&quot;&gt;RPM vs Tarball&lt;/h4&gt;

&lt;p&gt;如何在 RPM 与 Tarball 之间做出选择。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首选 CentOS 官方的 RPM&lt;/p&gt;

    &lt;p&gt;一方面利于保证系统安全，另一方面自动维护也比较方便。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件官网的 RPM 或软件库&lt;/p&gt;

    &lt;p&gt;原厂 RPM 没有的软件，可以到软件的官网查找 RPM 文件下载，如果官网有软件库，则把该软件库加入 yum 配置文件，这样以后就可以自动安装和更新该软件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tarball 安装特殊软件&lt;/p&gt;

    &lt;p&gt;某些特殊用途的软件没有 RPM 包，不建议自已制作 SRPM 来转成 RPM，因为对于仅一台主机来说没有意义，如果要管理相同的 100 台主机，自已制作 RPM 才有价值。单机版的特殊软件，建议用 tarball 安装。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 Tarball 测试新版软件&lt;/p&gt;

    &lt;p&gt;可以用 tarball 安装 &lt;strong&gt;未知风险&lt;/strong&gt; 的新软件到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/&lt;/code&gt; 目录中，这样就可以同时安装该软件的两个版本了，不会互相干扰，比较适合测试新软件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之，有 RPM 就尽量使用；如果软件的架构差异性太大，或依赖软件很难搞定，则直接用 tarball 安装。&lt;/p&gt;

&lt;h3 id=&quot;1813-rpm-软件管理程序&quot;&gt;18.1.3 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 软件管理程序&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令在现实中多只用于 &lt;strong&gt;查询&lt;/strong&gt; 与 &lt;strong&gt;检验&lt;/strong&gt;，安装软件通常使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;rpm-命令语法&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令语法&lt;/h4&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令需要 root 身份。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -ivh package_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i &lt;/code&gt; install&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;  显示详细安装信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt;  显示安装进度&lt;/p&gt;

&lt;h5 id=&quot;范例安装光盘上的软件&quot;&gt;范例：安装光盘上的软件&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -ivh /mnt/Packages/rp-pppoe-3.11-5.el7.x86_64.rpm
Preparing...                          ################################# [100%]
Updating / installing...
   1:rp-pppoe-3.11-5.el7              ################################# [100%]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;范例同时安装多个软件&quot;&gt;范例：同时安装多个软件&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -ivh a.i386.rpm b.i386.rpm *.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;范例使用网址安装&quot;&gt;范例：使用网址安装&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -ivh http://website.name/path/pkgname.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;rpm-常用选项&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 常用选项&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;选项&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–nodeps&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺少依赖软件时强制安装，可能导致该软件无法正常使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–replacefiles&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;安装过程中提示“某文件已被安装在系统”，或 “文件冲突”时，覆盖文件。操作无法恢复&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–replacepkgs&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重新安装已安装过的软件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–force&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等同于 &lt;code class=&quot;highlighter-rouge&quot;&gt;--replacefiles&lt;/code&gt; 加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;--replacepkgs&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–test&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;仅测试安装环境，检查是否存在依赖软件缺失的问题&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–justdb&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RPM 数据库损坏，或其他原因产生错误时，该选项会更新该软件在数据库内的相关信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–nosignature&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;跳过数字签名检查&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–prefix 新路径&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;要将软件安装到其他非正规目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;–noscripts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不希望该软件在安装过程中自动执行某些系统命令（前置操作，如数据库初始化等）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;升级与更新&quot;&gt;升级与更新&lt;/h4&gt;

&lt;p&gt;升级：Upgrade	&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -U&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;更新：Freshen &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -F&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;未装过的软件&lt;/th&gt;
      &lt;th&gt;已安装的软件&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-Uvh&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;安装新软件&lt;/td&gt;
      &lt;td&gt;更新版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-Fvh&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不安装&lt;/td&gt;
      &lt;td&gt;更新版本&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Fvh&lt;/code&gt; 仅更新已有的软件，而不会安装系统原来没有的软件，常用于 &lt;strong&gt;大量升级低版本的软件&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;rpm-查询&quot;&gt;RPM 查询&lt;/h4&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -q&lt;/code&gt; 进行 RPM 查询，返回的结果来自于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/rpm/&lt;/code&gt; 目录中的 &lt;strong&gt;数据库&lt;/strong&gt; 文件。&lt;/p&gt;

&lt;p&gt;RPM 也可以查询 &lt;strong&gt;未安装的 RPM&lt;/strong&gt; 信息。&lt;/p&gt;

&lt;p&gt;下表中所指的安装包文件名均不含后缀 &lt;code class=&quot;highlighter-rouge&quot;&gt;.rpm&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;rpm--q-常用参数&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -q&lt;/code&gt; 常用参数&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;用途&lt;/th&gt;
      &lt;th&gt;查询依据&lt;/th&gt;
      &lt;th&gt;返回结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;——–&lt;/td&gt;
      &lt;td&gt;软件包相关的选项&lt;/td&gt;
      &lt;td&gt;——–&lt;/td&gt;
      &lt;td&gt;——–&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pkg1 … pkgN&lt;/td&gt;
      &lt;td&gt;查询某软件的安装包文件名&lt;/td&gt;
      &lt;td&gt;已安装的软件名称&lt;/td&gt;
      &lt;td&gt;安装包文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p &lt;file&gt; / -&lt;/file&gt;&lt;/td&gt;
      &lt;td&gt;查询某文件中包含什么软件包，&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 用于管道接收 stdin&lt;/td&gt;
      &lt;td&gt;文件名或 URL&lt;/td&gt;
      &lt;td&gt;安装包文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f &lt;file&gt;&lt;/file&gt;&lt;/td&gt;
      &lt;td&gt;查询某文件来自于哪个软件包&lt;/td&gt;
      &lt;td&gt;文件名&lt;/td&gt;
      &lt;td&gt;安装包文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;查询已安装的所有包&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;所有安装包文件名列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–whatprovides &lt;x&gt;&lt;/x&gt;&lt;/td&gt;
      &lt;td&gt;查询什么软件包提供 &lt;strong&gt;特定功能&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;共享库名称或功能名&lt;/td&gt;
      &lt;td&gt;安装包文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-g &lt;group&gt;&lt;/group&gt;&lt;/td&gt;
      &lt;td&gt;查询属于某个组的软件包&lt;/td&gt;
      &lt;td&gt;组名&lt;/td&gt;
      &lt;td&gt;安装包文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–whatrequires &lt;x&gt;&lt;/x&gt;&lt;/td&gt;
      &lt;td&gt;查询什么软件包需要指定功能&lt;/td&gt;
      &lt;td&gt;共享库名称或功能名&lt;/td&gt;
      &lt;td&gt;安装包文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;——–&lt;/td&gt;
      &lt;td&gt;信息相关的选项&lt;/td&gt;
      &lt;td&gt;——–&lt;/td&gt;
      &lt;td&gt;——–&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i&lt;/td&gt;
      &lt;td&gt;查看软件详细信息&lt;/td&gt;
      &lt;td&gt;软件名&lt;/td&gt;
      &lt;td&gt;软件名、开发商、版本、安装日期、组、源代码文件名、软件包大小等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;查看某软件的所有文件&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;该软件包安装在系统中的所有文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;查看某软件的所有配置文件&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;该软件包安装在系统中的所有配置文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;查看某软件的所有说明文档&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;该软件包安装在系统中的所有说明文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s&lt;/td&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;软件名&lt;/td&gt;
      &lt;td&gt;该软件包安装在系统中的所有文件，及其状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–scripts&lt;/td&gt;
      &lt;td&gt;查看软件安装、卸载、验证过程中具体有哪些操作&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;安装前后、卸载前后、验证时的脚本内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–queryformat&lt;/td&gt;
      &lt;td&gt;用各种参数控制查询结果的显示方式&lt;/td&gt;
      &lt;td&gt;各种标签及转义符&lt;/td&gt;
      &lt;td&gt;各种自定义格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–dump&lt;/td&gt;
      &lt;td&gt;查义软件简要信息&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;该软件包安装在系统中的所有文件，每个文件的大小、创建日期、MD5、文件模式、用户、组、是否配置文件、是否说明文档等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–provides&lt;/td&gt;
      &lt;td&gt;查询软件提供的功能&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;功能列表，通常为开发者自定义的字符串，与文件名无关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–requires / -R&lt;/td&gt;
      &lt;td&gt;查询软件需要的功能&lt;/td&gt;
      &lt;td&gt;软件名称&lt;/td&gt;
      &lt;td&gt;该软件正常运行所需要的功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;——–&lt;/td&gt;
      &lt;td&gt;一般选项&lt;/td&gt;
      &lt;td&gt;——–&lt;/td&gt;
      &lt;td&gt;——–&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;让显示结果与 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 类似，便于查看&lt;/td&gt;
      &lt;td&gt;配合其它参数如 &lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 相似的列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-vv&lt;/td&gt;
      &lt;td&gt;查看更多 RPM 内部动作的信息&lt;/td&gt;
      &lt;td&gt;配合其它参数&lt;/td&gt;
      &lt;td&gt;RPM 内部具体工作信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–root &lt;path&gt;&lt;/path&gt;&lt;/td&gt;
      &lt;td&gt;告诉 RPM 根目录是哪个，常用于初始化阶段，或用其它介质引导时&lt;/td&gt;
      &lt;td&gt;根目录绝对路径&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–rcfile &lt;rcfile&gt;&lt;/rcfile&gt;&lt;/td&gt;
      &lt;td&gt;切换不同的 RPM 设定&lt;/td&gt;
      &lt;td&gt;包含 RPM 默认设置参数的文件名&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–dbpath &lt;path&gt;&lt;/path&gt;&lt;/td&gt;
      &lt;td&gt;检查来自别处的 RPM 数据库文件&lt;/td&gt;
      &lt;td&gt;陌生的 RPM 数据库文件名&lt;/td&gt;
      &lt;td&gt;.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;查询本地 RPM 信息时，只需要软件名称，不需要版本号，因为是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/rpm/&lt;/code&gt; 中的数据库查询。&lt;/p&gt;

&lt;h4 id=&quot;rpm-验证&quot;&gt;RPM 验证&lt;/h4&gt;

&lt;p&gt;验证（Verify）：&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -V&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -V&lt;/code&gt; 用于验证已安装的软件包的完整性。&lt;/p&gt;

&lt;h5 id=&quot;工作原理&quot;&gt;工作原理&lt;/h5&gt;

&lt;p&gt;管理员时常要确认一下整个系统是正常运转的，确认已安装的软件是否配置正确，确认没有发生任何未知的修改，确认没有误删任何重要文件。&lt;/p&gt;

&lt;p&gt;如果 RPM 安装的文件发生了改变，或是为某软件提供功能的其它依赖软被删除，RPM 都可以发出警告。&lt;/p&gt;

&lt;p&gt;每一次安装、更新、卸载软件包时，系统所做出的改变均会记录在 RPM 数据库中，以便 RPM 持续追踪所有信息，只有这样，它才能保证其每一步操作的正确性。这是 RPM 正常运作的保证。&lt;/p&gt;

&lt;p&gt;RPM 数据库反应了其依赖生存的整个系统的配置情况，当 RPM 访问其数据库来确认安装、更新、卸载过程中该如何管理各个文件时，实际上它是把数据库做为一个系统配置的镜子来使用的。&lt;/p&gt;

&lt;p&gt;反过来，我们也可以把系统配置做为体现 RPM 数据库的一面镜子来使用：&lt;/p&gt;

&lt;p&gt;📕 我们用这面镜子来检查系统配置是否准确地反应了 RPM 数据库的内容。如果当前的系统配置与数据库不匹配，有两种可能性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RPM 数据库被损坏，系统配置正常&lt;/li&gt;
  &lt;li&gt;RPM 数据库正常，系统配置被修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为 RPM 数据库损坏的机率要更小，因此它为我们提供了一个免费的、强大的验证工具。&lt;/p&gt;

&lt;h5 id=&quot;rpm-验证内容&quot;&gt;RPM 验证内容&lt;/h5&gt;

&lt;p&gt;在 RPM 验证过程中，每一个由 RPM 安装过的文件都会被检查，每个文件至少有九种不同的属性可以检查：&lt;/p&gt;

&lt;h6 id=&quot;文件所有者&quot;&gt;文件所有者&lt;/h6&gt;

&lt;p&gt;User ownership，文件所有者直接影响文件的访问权限，因此文件所有权的任何更改都可能对数据安全性和系统可用性产生深远影响。&lt;/p&gt;

&lt;h6 id=&quot;文件属组&quot;&gt;文件属组&lt;/h6&gt;

&lt;p&gt;Group ownership，与所有者类似，该属性主要用于决定文件访问权限，因此文件属组发生变化也应该受到重视。&lt;/p&gt;

&lt;h6 id=&quot;文件模式&quot;&gt;文件模式&lt;/h6&gt;

&lt;p&gt;Mode，文件模式（即权限）由一组权限控制位组成，即隐藏属性加三组 rwx 位。SUID 许用户在执行程序期间变成 root，尤其需要留意。&lt;/p&gt;

&lt;h6 id=&quot;md5-校验码&quot;&gt;MD5 校验码&lt;/h6&gt;

&lt;p&gt;MD5 sum，从文件内容中获取的 128 位的数字，对文件做出的任何改动都会导致 MD5 校验码发生变化。RPM 会为每一个它管理的文件生成 MD5 校验码，并保存到数据库中，只要发生变化，RPM 就会发现。&lt;/p&gt;

&lt;h6 id=&quot;文件大小&quot;&gt;文件大小&lt;/h6&gt;

&lt;p&gt;Size，RPM 也追踪文件大小的细微变化。&lt;/p&gt;

&lt;h6 id=&quot;主设备号&quot;&gt;主设备号&lt;/h6&gt;

&lt;p&gt;Device major number，主设备号用于和设备驱动程序交流信息，如 SCSI 磁盘的主设备号为 8，IDE 磁盘的主设备号为 3。如果主设备号被篡改将会带来灾难性的结果，因此有必要追踪其变化。&lt;/p&gt;

&lt;h6 id=&quot;次设备号&quot;&gt;次设备号&lt;/h6&gt;

&lt;p&gt;Device minor number，与主设备号的概念类似，但它和设备驱动程序传递的信息与主设备号是不同的，对于磁盘驱动来说，信息中会包含 UUID，只要次设备号变化，RPM 就会察觉。&lt;/p&gt;

&lt;h6 id=&quot;符号链接内容&quot;&gt;符号链接内容&lt;/h6&gt;

&lt;p&gt;symbolic Link contents，如果文件是符号链接，则会检查链接的文件名是否发生变化。&lt;/p&gt;

&lt;h6 id=&quot;修改时间&quot;&gt;修改时间&lt;/h6&gt;

&lt;p&gt;mtime，多数文件系统都会追踪文件的修改日期和时间，RPM 利用这一点把修改时间保存在数据库中。&lt;/p&gt;

&lt;h6 id=&quot;软件功能&quot;&gt;软件功能&lt;/h6&gt;

&lt;p&gt;capabilities，功能被修改。&lt;/p&gt;

&lt;h5 id=&quot;rpm-验证的语法&quot;&gt;RPM 验证的语法&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -V  package_name&lt;/code&gt; 验证已安装的文件包是否被修改过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -V logrotate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -Va&lt;/code&gt; 列出系统中所有被修改过的文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -Vp package_filename&lt;/code&gt; 验证该文件包中是否有文件被修改&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -Vf package_owning_file&lt;/code&gt;  验证指定文件是否被修改过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -Vf /etc/crontab
.......T.  c /etc/crontab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;rpm--v-的输出格式&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -V&lt;/code&gt; 的输出格式&lt;/h5&gt;

&lt;p&gt;在验证文件包时，只有发现问题 RPM 才会有输出。&lt;/p&gt;

&lt;p&gt;输出的格式如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SM5DLUGTP c &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最前面的是连续 9 位的 &lt;strong&gt;状态位&lt;/strong&gt;，基本上不可能发生所有 9 个状态同时验证失败的情况。每个状态位只有在该属性验证失败时才会用其标签来表示，否则均以点 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 来表示验证正常。&lt;/p&gt;

&lt;h6 id=&quot;9-个状态位的意义&quot;&gt;9 个状态位的意义&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; 文件大小&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 文件模式&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;  MD5 校验码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt; 主、次设备号&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt; 文件的符号链接内容&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;U&lt;/code&gt; 文件所有者&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;G&lt;/code&gt; 文件属组&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; 文件修改时间&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; 文件功能&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 文件类型位，&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 为配置文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 验证失败的文件，绝对路径&lt;/p&gt;

&lt;h6 id=&quot;文件类型位&quot;&gt;文件类型位&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;  config，配置文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;  documentation，说明文档&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;  ghost，不知哪儿来的文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;  license，授权文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;  readme，帮助文档&lt;/p&gt;

&lt;h5 id=&quot;验证结果分析&quot;&gt;验证结果分析&lt;/h5&gt;

&lt;p&gt;如果文件的变动是预期就无所谓，如果是非预期的，则要分析是否被入侵。&lt;/p&gt;

&lt;p&gt;配置文件被修改是很正常的，但通常二进制文件不应该轻易被修改，需引起警惕。&lt;/p&gt;

&lt;h4 id=&quot;rpm-数字签名&quot;&gt;RPM 数字签名&lt;/h4&gt;

&lt;p&gt;Digital Signature&lt;/p&gt;

&lt;p&gt;RPM 只能依据软件包和 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/rpm/&lt;/code&gt; 数据库中的信息来比较验证，如果软件包中的数据本身就有问题，则无法保证验证过程自身的正确。&lt;/p&gt;

&lt;p&gt;软件包中的 md5 指纹也有被篡改的可能，我们可以通过数字签名来校验软件的来源。&lt;/p&gt;

&lt;p&gt;软件开发商发布的软件有一个自己的签名系统，该系统为每个软件颁发不同的 &lt;strong&gt;签名&lt;/strong&gt;，同时公开发布该签名的 &lt;strong&gt;公钥&lt;/strong&gt;（public key）。&lt;/p&gt;

&lt;p&gt;CentOS 7 原厂发布的 GPG 数字签名的公钥文件为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;基本工作原理&quot;&gt;基本工作原理&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;用户安装原厂发布的公钥文件。&lt;/li&gt;
  &lt;li&gt;在安装原厂的 RPM 软件包时，rpm 命令读取 RPM 文件的签名信息，与本机系统内的签名信息（公钥）作对比。&lt;/li&gt;
  &lt;li&gt;如果签名相同则安装，如果不同或找不到对应的签名信息时，则给予警告并停止安装。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CentOS 使用的数字签名系统为 GNU 计划的 GnuPG（GNU Privacy Guard, GPG）。GPG 可以通过杂凑运算，算出独一无二的专属公钥系统或者是数字签名系统。&lt;/p&gt;

&lt;h5 id=&quot;安装公钥&quot;&gt;安装公钥&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不同版本 GPG 公钥文件保存的位置不同，但文件名中大多包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPG-KEY&lt;/code&gt; ，因此可以用 locate 或 find 来查找。&lt;/p&gt;

&lt;p&gt;公钥安装之后，其软件名多为 &lt;code class=&quot;highlighter-rouge&quot;&gt;gpg-pubkey-****&lt;/code&gt;：&lt;/p&gt;

&lt;h4 id=&quot;卸载软件包&quot;&gt;卸载软件包&lt;/h4&gt;

&lt;p&gt;从各软件的依赖关系来讲，卸载软件时一定要从最上层开始，如很多软件都需要使用 pam ，如果直接卸载了 pam，则很多软件就无法正常工作了。&lt;/p&gt;

&lt;h5 id=&quot;语法&quot;&gt;语法&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -e package_name&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -e pam
error: Failed dependencies:   # 提示会损坏依赖关系

        libpam.so.0（）（64bit） is needed by （installed） systemd-libs-208-20.el7.x86_64

        libpam.so.0（）（64bit） is needed by （installed） libpwquality-1.2.3-4.el7.x86_64

# 告知用户具体的依赖关系
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# rpm -e pam-devel  
# 卸载时没有任何反馈表示成功执行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;重建-rpm-数据库&quot;&gt;重建 RPM 数据库&lt;/h4&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/rpm/&lt;/code&gt; 内的文件发生损坏，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm --rebuilddb&lt;/code&gt; 来重建数据库。&lt;/p&gt;

&lt;h2 id=&quot;182-yum&quot;&gt;18.2 YUM&lt;/h2&gt;

&lt;p&gt;Yum 是 CentOS 中的软件包管理软件，可以用于查询可用安装包信息、从仓库下载软件包、安装或卸载软件包。可以用于更新整个系统到最新可用版本。&lt;/p&gt;

&lt;p&gt;Yum 在更新、安装或卸载软件时，会自动解析软件的依赖关系，自动判断、下载、安装所有可用的依赖软件。&lt;/p&gt;

&lt;p&gt;为了重复利用既有的软件功能，很多软件用共享库的方式发布部分功能，以方便其他软件的调用，如 PAM 模块的验证功能。&lt;/p&gt;

&lt;p&gt;发行版在发布软件时，会分两个版本，分别面对一般用户与开发用户。如 &lt;code class=&quot;highlighter-rouge&quot;&gt;pam-x.x.rpm&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;pam-devel-x.x.rpm&lt;/code&gt; 。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;yum 并不是 rpm 的替代者，它只是 rpm 包管理器的 &lt;strong&gt;前端工具&lt;/strong&gt;，是 &lt;strong&gt;依赖于&lt;/strong&gt; rpm 包管理器的。平时使用 yum 来解决安装问题，使用 rpm 来查询软件包。&lt;/p&gt;

&lt;h3 id=&quot;1821-yum-工作机制&quot;&gt;18.2.1 yum 工作机制&lt;/h3&gt;

&lt;h4 id=&quot;yum-服务器&quot;&gt;yum 服务器&lt;/h4&gt;

&lt;p&gt;所有要发行的 rpm 包都放在 yum 服务器上供下载，rpm 包根据内核的版本号、CPU 的版本号分别编译发布。yum 服务器只需提供 ftp 或 httpd 服务以供下载。&lt;/p&gt;

&lt;p&gt;yum 服务器会收集每个 rpm 包的 &lt;strong&gt;元数据&lt;/strong&gt;，包括 rpm 包对应的版本号、配置文件、二进制信息、以及软件依赖关系，并把该信息做成一张 xml 格式的 &lt;strong&gt;软件包清单&lt;/strong&gt;，它会记录软件的依赖关系，及所有文件的网址。。&lt;/p&gt;

&lt;p&gt;在 yum 服务器上可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;createrepo&lt;/code&gt; 命令来更新该清单。&lt;/p&gt;

&lt;p&gt;客户端在使用 yum 安装程序时，会先把服务器上的清单自动 &lt;strong&gt;同步到本地&lt;/strong&gt;，然后再进行其它操作。&lt;/p&gt;

&lt;h4 id=&quot;yum-安装流程&quot;&gt;yum 安装流程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;用户端发起安装、升级 &lt;strong&gt;请求&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;本机 yum 向软件库请求 &lt;strong&gt;更新本地&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/cache/yum/&lt;/code&gt; 中的 &lt;strong&gt;软件包清单&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;用本机清单 &lt;strong&gt;对照&lt;/strong&gt; 本机 RPM 数据库，判断需要下载哪些软件&lt;/li&gt;
  &lt;li&gt;yum 从 yum server &lt;strong&gt;下载&lt;/strong&gt; 所需要软件&lt;/li&gt;
  &lt;li&gt;通过 RPM 机制 &lt;strong&gt;安装&lt;/strong&gt; 软件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;yum 通过分析 RPM 的标头数据，根据软件依赖关系制定解决方案，来自动处理软件依赖关系，从而使软件安装、卸载、更新顺利进行。&lt;/p&gt;

&lt;h3 id=&quot;1822-yum-命令&quot;&gt;18.2.2 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt; 命令&lt;/h3&gt;

&lt;h4 id=&quot;查询&quot;&gt;查询&lt;/h4&gt;

&lt;p&gt;查询的软件名支持通配符 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;yum-list&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看软件包中的软件列表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list available&lt;/code&gt;  列出所有可用软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list installed&lt;/code&gt;   列出所有已安装的软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list all&lt;/code&gt;  列出已安装及可用的所有软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list kernel&lt;/code&gt;  列出已安装及可用的内核软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list updates&lt;/code&gt;  列出服务器上可供本机更新的软件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list web*&lt;/code&gt;  列出以 web 开头的软件包&lt;/p&gt;

&lt;h5 id=&quot;yum-info&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum info&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查询软件包的信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum info vsftpd&lt;/code&gt;  查看关于 vsftpd 软件包的信息&lt;/p&gt;

&lt;h5 id=&quot;yum-deplist&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum deplist&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看软件包的依赖&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum deplist nfs-untils&lt;/code&gt;  查看该软件的依赖&lt;/p&gt;

&lt;h5 id=&quot;yum-provides&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum provides&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查找提供关键字的软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum provides &quot;*bin/top&quot;&lt;/code&gt;  查找包含 top 命令的软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum provides &quot;*/README.top&quot;&lt;/code&gt;  查找包含该文件的软件包&lt;/p&gt;

&lt;h5 id=&quot;yum-search&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum search&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;根据软件包的名称和描述查找关键字&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum search samba&lt;/code&gt;  在软件包的名称或描述中查找含有 samba 的&lt;/p&gt;

&lt;h5 id=&quot;yum-updateinfo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum updateinfo&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看可用的软件包更新&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum updateinfo security&lt;/code&gt;  查看可用的安全更新&lt;/p&gt;

&lt;h5 id=&quot;yum-grouplist&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum grouplist&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;可看已安装及可用的软件包组&lt;/p&gt;

&lt;h5 id=&quot;yum-groupinfo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum groupinfo&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看软件包组的描述及内容&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum groupinfo &quot;Web Server&quot;&lt;/code&gt;  查看该组中的软件&lt;/p&gt;

&lt;h5 id=&quot;yum-check-update&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum check-update&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看软件库是否有可用的软件包更新&lt;/p&gt;

&lt;h4 id=&quot;软件库操作&quot;&gt;软件库操作&lt;/h4&gt;

&lt;h5 id=&quot;yum-repolist&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repolist&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看已启用的软件库&lt;/p&gt;

&lt;h5 id=&quot;yum-repoinfo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repoinfo&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看指定的启用的软件库的信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repoinfo rhel-7-server-rpms&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;yum-repo-pkgs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repo-pkgs&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;把特定的软件库当做一组软件包来对待。允许用户将其做为一个单独的实体来安装或删除。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repo-pkgs my-rmps list&lt;/code&gt;  查看 my-repo 软件库中的软件列表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repo-pkgs my-rpms install&lt;/code&gt;  安装 my-repo 库中所有软件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum repo-pkgs my-rpms remove&lt;/code&gt;  卸载 my-repo 库中所有软件&lt;/p&gt;

&lt;h5 id=&quot;yum-makecache&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum makecache&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;从服务器下载软件库数据到本地缓存&lt;/p&gt;

&lt;h4 id=&quot;排错及维护&quot;&gt;排错及维护&lt;/h4&gt;

&lt;h5 id=&quot;yum-check&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum check&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;检查地本 RPM 数据库是否有错误，运行时间较长&lt;/p&gt;

&lt;h5 id=&quot;yum-history&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum history&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;查看 yum 历史记录&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum history list&lt;/code&gt;  查看所有安装、更新、删除的历史动作&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum history info 3&lt;/code&gt;  查看 yum 的第 3 号操作&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum history undo 3&lt;/code&gt;  撤回 yum 的第 3 号操作&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum history redo 3&lt;/code&gt;  重做第 3 号没有完成的操作&lt;/p&gt;

&lt;h5 id=&quot;yum-clean&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum clean&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;清除缓存的软件包数据&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum clean packages&lt;/code&gt;  删除缓存中的软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum clean all&lt;/code&gt;  删除缓存中所有软件包及元数据&lt;/p&gt;

&lt;h4 id=&quot;安装卸载软件包&quot;&gt;安装、卸载软件包&lt;/h4&gt;

&lt;h5 id=&quot;yum-install&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;从软件库安装软件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install vsftpd&lt;/code&gt; 安装指定软件包&lt;/p&gt;

&lt;h5 id=&quot;yum-update&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum update&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;更新一个或多个软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum update&lt;/code&gt; 更新所有可更新的软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum update httpd&lt;/code&gt;  更新特定软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum update --security&lt;/code&gt;  应用安全相关的更新&lt;/p&gt;

&lt;h5 id=&quot;yum-update-to&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum update-to&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;把软件包更新到特定的版本&lt;/p&gt;

&lt;h5 id=&quot;yum-localinstall&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum localinstall&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;从本地文件、http、ftp 安装软件包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum localinstall abc-1-1.i686.rpm&lt;/code&gt;  安装本地文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum localinstall http://myrepo/abc-1-1.i686.rpm&lt;/code&gt;  从网址安装&lt;/p&gt;

&lt;h5 id=&quot;yum-reinstall&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum reinstall&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;重新安装软件包当前版本，以替换被删除的文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum reinstall util-linux&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;yum---installroot&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum --installroot=&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;将该软件安装到指定目录，而非默认路径&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install vsftpd --installroot=/some/path&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;yum-erase&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum erase&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;删除软件包及依赖&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum erase vsftpd&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;yum-remove&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum remove&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum erase&lt;/code&gt; 相同&lt;/p&gt;

&lt;h5 id=&quot;yum-groupinstall&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum groupinstall&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;安装软件包组中所有软件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum groupinstall &quot;web server&quot;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;其它常用选项&quot;&gt;其它常用选项&lt;/h4&gt;

&lt;h5 id=&quot;yum--y&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum -y&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;对所有问题回答 yes&lt;/p&gt;

&lt;h5 id=&quot;yum--v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum -v&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;产生更多的调试信息&lt;/p&gt;

&lt;h5 id=&quot;yum---enablerepo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum --enablerepo=&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;在本次命令中临时启用某软件库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install docker --enablerepo=rhel-7-server-extras-rpm&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;yum---disablerepo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum --disablerepo=&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;在本次命令中临时禁用某软件库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum list available --disablerepo=epel&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;1823-yum-的配置文件&quot;&gt;18.2.3 yum 的配置文件&lt;/h3&gt;

&lt;p&gt;yum 的配置文件为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.conf&lt;/code&gt;，它包含了一个强制的 &lt;code class=&quot;highlighter-rouge&quot;&gt;[main]&lt;/code&gt; 区块，在此可以设置全局生效的 yum 选项。虽然允许在该文件中加入其它软件库，但不推荐这样做。建议在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.repos.d/&lt;/code&gt; 目录下为不同的软件库 &lt;strong&gt;使用各自的配置文件&lt;/strong&gt;，后缀为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.repo&lt;/code&gt;，即 repository。&lt;/p&gt;

&lt;h4 id=&quot;使用配置文件原原则&quot;&gt;使用配置文件原原则&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;如需修改全局选项，应编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.conf&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;[main]&lt;/code&gt; 区块&lt;/li&gt;
  &lt;li&gt;如需修改个别软件库的选项，应编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.repos.d/&lt;/code&gt; 目录中其对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.repo&lt;/code&gt; 文件&lt;/li&gt;
  &lt;li&gt;应尽可能使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.conf&lt;/code&gt; 及 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.repos.d/*.repo&lt;/code&gt; 中的变量，以保证动态版本和架构的值能被正确使用&lt;/li&gt;
  &lt;li&gt;需要时，在命令行中启用、禁用软件库&lt;/li&gt;
  &lt;li&gt;需要时可以设置自定义软件库&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;配置文件的结构&quot;&gt;配置文件的结构&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# vim /etc/yum.repos.d/CentOS-Base.repo

[base]
name=CentOS-$releasever - Base
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=os&amp;amp;infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
enabled=0
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[base]：软件库名称，必须要有 &lt;strong&gt;中括号&lt;/strong&gt;，里面的 &lt;strong&gt;软件库名称&lt;/strong&gt; 则可以任意，但 &lt;strong&gt;不能重复&lt;/strong&gt;， 否则会引起混淆。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;  软件库简要说明&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mirrorlist=&lt;/code&gt;  该软件库可以使用的镜像站点，是由 yum 程序自动捕捉的&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;baseurl=&lt;/code&gt;  软件库的真实网址，固定的网址&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enable=0&lt;/code&gt;  禁用该软件库。注意：如果该软件库被启用，会直接删除该条目，并不会有 &lt;code class=&quot;highlighter-rouge&quot;&gt;enable=1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gpgcheck=1&lt;/code&gt;  是否校验数字签名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gpgkey=&lt;/code&gt;  数字签名的公钥所在位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;清除-yum-缓存&quot;&gt;清除 yum 缓存&lt;/h4&gt;

&lt;p&gt;如果修改了软件库的网址，但没有修改软件库名称，可能会造成本机的清单与 yum 服务器的不同步，会导致无法更新。可通过删除本机旧的数据来解决：&lt;code class=&quot;highlighter-rouge&quot;&gt;yum clean all&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1824-yum-的软件包组&quot;&gt;18.2.4 yum 的软件包组&lt;/h3&gt;

&lt;p&gt;yum 按用途把众多软件分成了若干个组，允许通过组一次性安装多个软件。&lt;/p&gt;

&lt;h4 id=&quot;修改组的安装选项&quot;&gt;修改组的安装选项&lt;/h4&gt;

&lt;p&gt;每个软件组中，有一部分软件是 &lt;strong&gt;强制&lt;/strong&gt; 安装的，有一部分是 &lt;strong&gt;可选&lt;/strong&gt; 安装的，这些可选软件默认不会被安装。要想安装这些软件，需要修改配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.conf&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# vim /etc/yum.conf
.....
distroverpkg=centos-release   # 此行下面新增一行
group_package_types=default, mandatory, optional
.....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1825-yum-安装第三方软件&quot;&gt;18.2.5 yum 安装第三方软件&lt;/h3&gt;

&lt;p&gt;针对常用的第三方软件，一些组织建立了软件仓库。&lt;/p&gt;

&lt;h4 id=&quot;epel&quot;&gt;EPEL&lt;/h4&gt;

&lt;p&gt;EPEL，Extra Packages for Enterprise Linux, 是 Fedora 基金会开发的一个 &lt;strong&gt;附加软件计划&lt;/strong&gt;，主要是针对 Red Hat Enterprise Linux 开发的，同样支持 CentOS。&lt;/p&gt;

&lt;h4 id=&quot;elrepo&quot;&gt;ELRepo&lt;/h4&gt;

&lt;p&gt;另一个支持 RHEL 的软件仓库。&lt;/p&gt;

&lt;p&gt;该软件库提供的大多是与 &lt;strong&gt;内核、内核模块、虚拟化&lt;/strong&gt; 相关的软件。包括 NVidia 的驱动程序，最新的内核（文件名为 kernel-ml ）。&lt;/p&gt;

&lt;h4 id=&quot;安装第三方软件的流程&quot;&gt;安装第三方软件的流程&lt;/h4&gt;

&lt;p&gt;通过 EPEL 仓库安装 netcdf 及 R 这两套软件。&lt;/p&gt;

&lt;h5 id=&quot;增加软件库&quot;&gt;增加软件库&lt;/h5&gt;

&lt;p&gt;在 yum 配置文件中增加 EPEL 库：&lt;/p&gt;

&lt;p&gt;如果是首次安装第三方软件，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/yum.repos.d/&lt;/code&gt; 目录中新建配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;epel.repo&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# vim /etc/yum.repos.d/epel.repo
[epel]
name=epel packages
baseurl=https://dl.fedoraproject.org/pub/epel/7/x86_64/
gpgcheck=0
enabled=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;修改软件库的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.conf&lt;/code&gt; 文件之后，一定要用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo yum clean all&lt;/code&gt; 来清除缓存数据。&lt;/p&gt;

&lt;p&gt;无需启动该软件库，只需在安装时临时启用。&lt;/p&gt;

&lt;h5 id=&quot;安装软件包&quot;&gt;安装软件包&lt;/h5&gt;

&lt;p&gt;仅使用该软件库来安装 netcdf 和 R&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# yum --disablerepo=&quot;*&quot; --enablerepo=&quot;epel&quot; install netcdf R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--disablerepo=&quot;*&quot;&lt;/code&gt;  在本命令中先禁用所有软件库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--enablerepo=&quot;epel&quot;&lt;/code&gt;  在本命令中临时启用 epel 软件库&lt;/p&gt;

&lt;p&gt;如果确认在加入这个新软件库之前，现有的软件库都没有这个软件包，也可以直接使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# yum --enablerepo=&quot;epel&quot; install netcdf R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;用-yum-安装光盘中的软件包&quot;&gt;用 yum 安装光盘中的软件包&lt;/h4&gt;

&lt;p&gt;本机的光驱挂载以后，可以使用 yum 来安装软件，新建并编辑新的配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;cdrom.repo&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# vim /etc/yum.repos.d/cdrom.repo
[mycdrom]
name = mycdrom
baseurl = file:///mnt	# 挂载点
gpgcheck = 0
enabled = 0

~]# yum --enablerepo=&quot;mycdrom&quot; install software_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1826-系统自动更新&quot;&gt;18.2.6 系统自动更新&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yum -y update&lt;/code&gt; 系统自动更新，&lt;code class=&quot;highlighter-rouge&quot;&gt;-y&lt;/code&gt; 可以对所有问题自动回答 yes，以便无障碍下载安装，再用 crontab 做成计划任务即可。&lt;/p&gt;

&lt;p&gt;同时，要分析日志文件，并注意查收 root 的邮件， 因为如果更新了内核，需要重启系统。&lt;/p&gt;

&lt;h2 id=&quot;183-rpm-的创建&quot;&gt;18.3 RPM 的创建&lt;/h2&gt;

&lt;p&gt;虽然有了 Tarball 就可以安装软件，但经常无法卸载，更不便于升级、维护。相比之下，RPM 软件包的形式更利于软件的安装、卸载、更新和维护。&lt;/p&gt;

&lt;p&gt;因此，在有的情况下，需要自己从源码来创建 RPM 软件包。&lt;/p&gt;

&lt;h3 id=&quot;1831-准备相关工具&quot;&gt;18.3.1 准备相关工具&lt;/h3&gt;

&lt;p&gt;要想创建 RPM 软件包，建议安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum-utils&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm-build&lt;/code&gt; 两套工具，其中包含了许多有用的程序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum install yum-utils rpm-build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1832-获得源代码&quot;&gt;18.3.2 获得源代码&lt;/h3&gt;

&lt;p&gt;源代码的形式通常为 SRPM 或 Tarball。&lt;/p&gt;

&lt;p&gt;SRPM 比 Tarball 多了 spec 文件、更新补丁等。而 spec 文件在生成 rpm 软件包的过程中至关重要。&lt;/p&gt;

&lt;h4 id=&quot;srpm&quot;&gt;SRPM&lt;/h4&gt;

&lt;h5 id=&quot;下载-srpm&quot;&gt;下载 SRPM&lt;/h5&gt;

&lt;p&gt;如果要下载在线软件库中的 SRPM，可以使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yumdownloader --source vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该命令会直接把 SRPM 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;vsftpd-3.0.2-22.el7.src.rpm&lt;/code&gt; 下载到当前目录。&lt;/p&gt;

&lt;h5 id=&quot;安装-srpm&quot;&gt;安装 SRPM&lt;/h5&gt;

&lt;p&gt;下载的 SRPM 文件需要以 &lt;strong&gt;普通用户&lt;/strong&gt; 身份，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -i&lt;/code&gt; 命令来安装。不能使用 root 来安装，有损坏系统的风险。&lt;/p&gt;

&lt;p&gt;其中的源代码压缩包、更新补丁及相关文件将会被安装到一个目录，该目录被称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;topdir&lt;/code&gt;，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm --showrc | grep topdir&lt;/code&gt; 来查看该变量的值，通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;%{getenv:HOME}/rpmbuild&lt;/code&gt;，即用户家目录中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;现在用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令来安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -ivh ./vsftpd-3.0.2-22.el7.src.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;该命令会将 SRPM &lt;strong&gt;解包&lt;/strong&gt;，把 SPEC 文件放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;SPECS&lt;/code&gt; 目录，把其余的文件（源代码压缩包、更新补丁和其它文件）放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;SOURCES&lt;/code&gt; 目录。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]$ tree rpmbuild/
rpmbuild/
├── SOURCES
│   ├── vsftpd-2.0.5-fix_qm.patch
│   ├── vsftpd-2.1.0-build_ssl.patch
│   ├── vsftpd-3.0.2-seccomp.patch
│   ├── vsftpd-3.0.2.tar.gz
│   ├── vsftpd_conf_migrate.sh
│   ├── vsftpd.ftpusers
│   ├── vsftpd-generator
│   ├── vsftpd.init
│   ├── vsftpd.pam
│   ├── vsftpd.service
│   ├── vsftpd@.service
│   ├── vsftpd.target
│   ├── vsftpd.user_list
│   └── vsftpd.xinetd
└── SPECS
    └── vsftpd.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;自定义安装目录&quot;&gt;自定义安装目录&lt;/h6&gt;

&lt;p&gt;如果要自定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;topdir&lt;/code&gt; 的值，可以在家目录新建文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;.rpmmacros&lt;/code&gt;，内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%_topdir	%(echo $HOME)/my-rpm-build-dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该 &lt;code class=&quot;highlighter-rouge&quot;&gt;.rpmmacros&lt;/code&gt; 文件会促使 SRPM 安装到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/my-rpm-build-dir&lt;/code&gt; 目录。&lt;/p&gt;

&lt;h4 id=&quot;tarball&quot;&gt;Tarball&lt;/h4&gt;

&lt;p&gt;没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpm&lt;/code&gt; 命令的帮助，只能手动创建目录结构、解压源代码。&lt;/p&gt;

&lt;h6 id=&quot;创建编译的目录结构&quot;&gt;创建编译的目录结构&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
echo '%_topdir %(echo $HOME)/rpmbuild' &amp;gt; ~/.rpmmacros
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;解压源代码&quot;&gt;解压源代码&lt;/h6&gt;

&lt;p&gt;把源代码下载并解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SOURCES/&lt;/code&gt; 目录。如果编译时需要加入一些补丁，同样也将其放到该目录。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SOURCES/
wget http://***.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1833-spec-文件&quot;&gt;18.3.3 SPEC 文件&lt;/h3&gt;

&lt;p&gt;SPEC 文件用于 &lt;strong&gt;控制&lt;/strong&gt; 如何构建和安装 RPM 文件包，可以视为是 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild&lt;/code&gt; 的配置文件。&lt;/p&gt;

&lt;p&gt;SPEC 文件即软件包描述文件，其中包含了软件包的诸多信息，如软件包的名字、版本、类别、说明摘要，以及构建要执行的指令、安装时要执行的操作、以及软件包所要包含的文件列表等。&lt;/p&gt;

&lt;h4 id=&quot;spec-文件的主要结构&quot;&gt;SPEC 文件的主要结构&lt;/h4&gt;

&lt;h5 id=&quot;文件头&quot;&gt;文件头&lt;/h5&gt;

&lt;p&gt;一般的 SPEC 文件头包含以下几个域：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Summary&lt;/code&gt;  用一句话概括该软件包尽量多的信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Name&lt;/code&gt;  软件包的名字，最终RPM软件包是用该名字与版本号，发布号及体系号来命名软件包的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Version&lt;/code&gt;  软件版本号。仅当软件包比以前有较大改变时才增加版本号。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Release&lt;/code&gt;  软件包发布号。一般我们对该软件包做了一些小的补丁的时候就应该把发布号加1。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vendor&lt;/code&gt;  软件开发者的名字。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Copyright&lt;/code&gt;  软件包所采用的版权规则。具体有：GPL（自由软件），BSD，MIT，Public Domain（公共域），Distributable（贡献），commercial（商业），Share（共享）等，一般的开发都写GPL。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Group&lt;/code&gt;  软件包所属软件包组&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Source&lt;/code&gt;  源程序软件包的名字。如 stardict-2.0.tar.gz。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%description&lt;/code&gt;  软件包详细说明，可写在多个行上。&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -qi pack_name&lt;/code&gt; 返回的结果就是这个说明。&lt;/p&gt;

&lt;h5 id=&quot;prep-段&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%prep&lt;/code&gt; 段&lt;/h5&gt;

&lt;p&gt;这个段是 &lt;strong&gt;预处理&lt;/strong&gt; 段，&lt;strong&gt;解压&lt;/strong&gt; 源代码，&lt;strong&gt;应用补丁&lt;/strong&gt;，为编译和安装 &lt;strong&gt;作准备&lt;/strong&gt;。功能上类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;%prep 和下面的 %build，%install 段一样，除了可以执行 RPM 所定义的宏命令（以%开头）以外，还可以执行 SHELL 命令，命令可以有很多行，如常用的 tar 解包命令。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;%setup&lt;/code&gt; 解压源程序的 tar 文件包&lt;/li&gt;
  &lt;li&gt;如果有补丁文件，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;%patch&lt;/code&gt; 将其应用到解开的源码中&lt;/li&gt;
  &lt;li&gt;检验软件所需的目录是否存在&lt;/li&gt;
  &lt;li&gt;创建软件所需目录&lt;/li&gt;
  &lt;li&gt;运行需要提前执行的任务&lt;/li&gt;
  &lt;li&gt;如果安装过程中会覆盖某些文件，需提前备份&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;build-段&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt; 段&lt;/h5&gt;

&lt;p&gt;定义编译软件包所要执行的命令， 这一节一般由多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令组成。&lt;/p&gt;

&lt;h5 id=&quot;install-段&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%install&lt;/code&gt; 段&lt;/h5&gt;

&lt;p&gt;定义在 &lt;strong&gt;安装软件包&lt;/strong&gt; 时将执行命令，类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;将已编译的软件安装到虚拟的目录结构中，从而可以打包成一个 RPM。&lt;/p&gt;

&lt;p&gt;有些 SPEC 文件还有 %post-install 段，用于定义在软件安装完成后所需执行的配置工作。&lt;/p&gt;

&lt;h5 id=&quot;files-段&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%files&lt;/code&gt; 段&lt;/h5&gt;

&lt;p&gt;用于定义软件包所包含的文件。&lt;/p&gt;

&lt;p&gt;分为三类：说明文档、配置文件及可执行程序，还可定义文件存取权限，所有者及组别。&lt;/p&gt;

&lt;h5 id=&quot;changelog-段&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%changelog&lt;/code&gt; 段&lt;/h5&gt;

&lt;p&gt;修改日志段。&lt;/p&gt;

&lt;p&gt;可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。&lt;/p&gt;

&lt;p&gt;每个修改日志的格式为：&lt;/p&gt;

&lt;p&gt;第一行以星号开始：&lt;code class=&quot;highlighter-rouge&quot;&gt;* 星期 月 日 年 修改人 电子信箱&lt;/code&gt;，其中，星期、月份均用英文形式的前 3 个字母，用中文会报错。&lt;/p&gt;

&lt;p&gt;其它行以减号 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 开始，记录修改内容，可写多行。&lt;/p&gt;

&lt;h5 id=&quot;构建依赖软件&quot;&gt;构建依赖软件&lt;/h5&gt;

&lt;p&gt;构建 RPM 时需要的软件会用 &lt;code class=&quot;highlighter-rouge&quot;&gt;BuildRequires&lt;/code&gt; 标签来设定。在构建 RPM 软件包时，如果系统中没有安装这些依赖包，构建就会失败。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BuildRequires: pam-devel
BuildRequires: libcap-devel
BuildRequires: openssl-devel
BuildRequires: systemd
BuildRequires: tcp_wrappers-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;srpm--tarball&quot;&gt;SRPM / Tarball&lt;/h4&gt;

&lt;p&gt;SRPM 通常会携带 &lt;code class=&quot;highlighter-rouge&quot;&gt;.spec&lt;/code&gt; 文件，并被解包到 &lt;code class=&quot;highlighter-rouge&quot;&gt;SPEC&lt;/code&gt; 目录中。如有需要可以修改。&lt;/p&gt;

&lt;p&gt;而 Tarball 则通常不会有，必须自己创建。&lt;/p&gt;

&lt;h3 id=&quot;1834-安装依赖软件包&quot;&gt;18.3.4 安装依赖软件包&lt;/h3&gt;

&lt;p&gt;除了基本的开发工具之外，每个软件在构建 RPM 包时，有时会需要系统中安装特定的其它软件包。正如上面 SPEC 文件中 &lt;code class=&quot;highlighter-rouge&quot;&gt;BuildRequires&lt;/code&gt; 标签所设定的。此时，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum-builddep&lt;/code&gt; 命令来自动安装依赖包，只需要把 SPEC 文件做为参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum-builddep ~/rpmbuild/SPECS/vsftpd.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就会自动按照 SPEC 文件所给定的构建依赖来逐项安装或更新软件包了。&lt;/p&gt;

&lt;h3 id=&quot;1835-构建-rpm&quot;&gt;18.3.5 构建 RPM&lt;/h3&gt;

&lt;h4 id=&quot;rpmbuild-命令&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild&lt;/code&gt; 命令&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild&lt;/code&gt; 用于构建软件包。使用时必须指定基本模式的一种：构建软件包，从 Tarball 构建软件包，重编译软件包，查看配置信息。&lt;/p&gt;

&lt;h5 id=&quot;基本语法&quot;&gt;基本语法&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild {-ba|-bb|-bp|-bc|-bi|-bl|-bs} [ rpmbuild-options ] SPECFILE...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild {-ta|-tb|-tp|-tc|-ti|-tl|-ts} [ rpmbuild-options ] TARBALL...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild {--rebuild|--recompile} SOURCEPKG...&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;编译安装-srpm&quot;&gt;编译、安装 SRPM&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild --rebuild&lt;/code&gt;  编译、打包，生成 RPM 文件，不安装。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild --recompile&lt;/code&gt;  编译、打包、安装。&lt;/p&gt;

&lt;p&gt;这两个选项都是用 SRPM 的 &lt;strong&gt;默认设置&lt;/strong&gt; 进行安装。&lt;/p&gt;

&lt;p&gt;如果进行的顺利，编译过程中产生的临时文件会被自动删除。如果发生错误，临时文件将被保留。&lt;/p&gt;

&lt;p&gt;编译完成的 RPM 位置：&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/RPMS/x86_64/*.rpm&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;rpmbuild--b&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -b&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -b&amp;lt;stage&amp;gt; options file1.spec … fileN.spec&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -b&lt;/code&gt; 命令会开始一个 &lt;strong&gt;构建&lt;/strong&gt; 软件包的流程，而命令后面所加的其他参数，会决定该流程最终编译的结果，以及该流程要完成 SPEC 文件中的哪些步骤。&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt; 选项运行时，有两个信息必须确认：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个或多个 SPEC 文件&lt;/li&gt;
  &lt;li&gt;构建流程需要走到 SPEC 文件中的哪个阶段（stage）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在构建 RPM 的过程中，要经历一定数量的阶段，通过 &lt;strong&gt;指定阶段&lt;/strong&gt;，构建流程会走到该阶段就中止。&lt;/p&gt;

&lt;h6 id=&quot;rpmbuild--bp&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -bp&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;仅执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;%prep&lt;/code&gt; 阶段，即解压源代码，应用补丁。&lt;/p&gt;

&lt;h6 id=&quot;rpmbuild--ba&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -ba&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ba&lt;/code&gt; 选项会引导 RPM 执行构建过程的所有阶段，即执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;%prep&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%build&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%install&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%check&lt;/code&gt; 阶段。然后处理所有说明文档，创建 &lt;strong&gt;BRPM&lt;/strong&gt; 文件，清理临时文件，最后一步是创建 &lt;strong&gt;SRPM&lt;/strong&gt; 文件。该 SRPM 文件由 SPEC 文件和源代码文件（Tarball）组成，有时还会包含一个或多个补丁文件。&lt;/p&gt;

&lt;p&gt;主要步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解包原始代码&lt;/li&gt;
  &lt;li&gt;按需应用补丁&lt;/li&gt;
  &lt;li&gt;编译软件&lt;/li&gt;
  &lt;li&gt;安装软件&lt;/li&gt;
  &lt;li&gt;运行软件的测试套件&lt;/li&gt;
  &lt;li&gt;生成二进制 RPM 文件&lt;/li&gt;
  &lt;li&gt;生成源代码 RPM 文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;rpmbuild--bb&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -bb&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;%prep&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%build&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%install&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%check&lt;/code&gt; 阶段的命令，编译生成 RPM 文件。&lt;/p&gt;

&lt;p&gt;在执行完 &lt;code class=&quot;highlighter-rouge&quot;&gt;%prep&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%build&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%install&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;%check&lt;/code&gt; 阶段之后，处理所有说明文档，RPM 判断软件包中的可执行文件需要哪些共享库来运行，以此来自动进行依赖关系的检查。之后，RPM 把所有文件打包，添加签名，创建 RPM 文件。&lt;/p&gt;

&lt;h4 id=&quot;构建目录结构&quot;&gt;构建目录结构&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SPECS/&lt;/code&gt;  用于保存 SPEC 文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SOURCES/&lt;/code&gt;  保存源代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.tar.gz&lt;/code&gt; 及补丁文件等&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/BUILD/&lt;/code&gt;  源代码文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/RPMS/&lt;/code&gt;  构建好的 BRPM 文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/SRPMS/&lt;/code&gt;  构建好的 SRPM 文件&lt;/p&gt;

&lt;p&gt;编译过程中如果发生错误，会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/&lt;/code&gt; 目录中产生一个对应的错误文件，可以根据该错误文件来排错。&lt;/p&gt;

&lt;p&gt;编译成功后，&lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbild/{SPECS，SOURCES，BUILD}&lt;/code&gt; 目录中的文件都会被删除，只保留 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/rpmbuild/RPMS/&lt;/code&gt; 中的 RPM 文件。&lt;/p&gt;

&lt;h4 id=&quot;构建命令&quot;&gt;构建命令&lt;/h4&gt;

&lt;p&gt;SPEC 文件准备好后，就可以开始构建 RPM 了。&lt;/p&gt;

&lt;h5 id=&quot;直接构建-rpm&quot;&gt;直接构建 RPM&lt;/h5&gt;

&lt;p&gt;如果此时没有什么要修改，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -ba&lt;/code&gt; 来执行构建的所有阶段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SPECS
rpmbuild -ba vsftpd.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建完成后，会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;RPMS&lt;/code&gt; 目录中生成 BRPM 软件包，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;SRPMS&lt;/code&gt; 目录中生成 SRPM 包。&lt;/p&gt;

&lt;h5 id=&quot;先修改再构建-rpm&quot;&gt;先修改，再构建 RPM&lt;/h5&gt;

&lt;p&gt;如果需要先修改源代码，则先使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -bp&lt;/code&gt; 执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;%prep&lt;/code&gt; 阶段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SPECS
rpmbuild -bp vsftpd.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;源代码会被解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;BUILD&lt;/code&gt; 目录中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ll rpmbuild/BUILD/
total 12
drwxr-xr-x. 8 neo neo 8192 May 14 07:55 vsftpd-3.0.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;修改完源代码后，再使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rpmbuild -ba&lt;/code&gt; 来执行所有阶段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/rpmbuild/SPECS
rpmbuild -ba vsftpd.spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建完成后，会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;RPMS&lt;/code&gt; 目录中生成 BRPM 软件包，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;SRPMS&lt;/code&gt; 目录中生成 SRPM 包。&lt;/p&gt;

&lt;h3 id=&quot;1836-安装-rpm&quot;&gt;18.3.6 安装 RPM&lt;/h3&gt;

&lt;p&gt;安装构建好的 RPM 包，以测试是否一切正常，包括其依赖软件是否也解析正常。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -ivvh ~/rpmbuild/RPMS/x86_64/vsftpd-3.0.2-22.el7.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装以后，可以再查询一下 RPM 数据库，以再次确认安装正确：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -qa vsftpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="rpm" /><category term="yum" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 17. 程序的加载</title><link href="/linux/linux.exeloading/" rel="alternate" type="text/html" title="Linux 基础 - 17. 程序的加载" /><published>2015-01-17T00:00:00+08:00</published><updated>2015-01-17T00:00:00+08:00</updated><id>/linux/linux.exeloading</id><content type="html" xml:base="/linux/linux.exeloading/">&lt;h2 id=&quot;175-程序的加载&quot;&gt;17.5 程序的加载&lt;/h2&gt;

&lt;p&gt;可执行文件只有加载到内存以后才能被 CPU 执行。早期的程序加载十分简陋，加载的基本过程就是把程序从外部存储器中读取到内存中的某个位置。随着硬件 MMU 的诞生，多进程、多用户、虚拟存储的操作系统出现以后，可执行文件的加载过程变得非常复杂。&lt;/p&gt;

&lt;h3 id=&quot;1751-进程的虚拟地址空间&quot;&gt;17.5.1 进程的虚拟地址空间&lt;/h3&gt;

&lt;p&gt;每个程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间的大小由计算机的硬件平台决定，具体地说是由 CPU 的位数决定的。&lt;/p&gt;

&lt;p&gt;硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如 32 位的硬件平台决定了虚拟地址空间的地址为 4GB。&lt;/p&gt;

&lt;p&gt;程序在运行的时候处于操作系统的监管下，操作系统为了达到监控程序运行等一系列目的，进程的虚拟空间都在操作系统的掌握之中。进程只能使用那些操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程。&lt;/p&gt;

&lt;p&gt;对于 32 位平台，只能使用 4GB 的虚拟空间，其中操作系统本身用去了一部分，对于 Linux 来说，进程在执行的时候，可用的虚拟空间不超过 3GB。只有使用 64 位平台才能让进程使用更多的虚拟空间。&lt;/p&gt;

&lt;h3 id=&quot;1752-加载的方式&quot;&gt;17.5.2 加载的方式&lt;/h3&gt;

&lt;p&gt;程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的静态装入的办法。&lt;/p&gt;

&lt;p&gt;为了让更多更大的程序得以运行而不停地增加内存是不实际的，最好在不添加内存的情况下让更多的程序运行起来，尽可能有效地利用内存。&lt;/p&gt;

&lt;p&gt;根据程序运行时的 &lt;strong&gt;局部性原理&lt;/strong&gt;，可以将程序最 &lt;strong&gt;常用&lt;/strong&gt; 的部分 &lt;strong&gt;驻留&lt;/strong&gt; 在内存中，而将一些 &lt;strong&gt;不太常用&lt;/strong&gt; 的数据存放在 &lt;strong&gt;磁盘&lt;/strong&gt; 里面，这就是 &lt;strong&gt;动态加载&lt;/strong&gt; 的基本原理。&lt;/p&gt;

&lt;p&gt;覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态加载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。&lt;/p&gt;

&lt;h4 id=&quot;覆盖加载&quot;&gt;覆盖加载&lt;/h4&gt;

&lt;p&gt;覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。&lt;/p&gt;

&lt;p&gt;覆盖装入在没有发明虚拟存储之前使用比较广泛，现在已经几乎被 &lt;strong&gt;淘汰&lt;/strong&gt; 了。&lt;/p&gt;

&lt;h4 id=&quot;页映射&quot;&gt;页映射&lt;/h4&gt;

&lt;p&gt;页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。&lt;/p&gt;

&lt;p&gt;页映射也不是一下子就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令划分成若干个页，以后所有的加载和操作的单位就使用页。&lt;/p&gt;

&lt;p&gt;假设加载由加载管理器来控制。当进程需要读取硬盘中的页，而没有可用虚拟空间时，加载管理器必须判断清除内存中的哪些页。如果选择清除最早分配的内存页，则称之为 FIFO；如果选择清除很少访问到的内存页，则为 LUR，最少使用算法。&lt;/p&gt;

&lt;p&gt;实际上，这个所谓的加载管理器就是现代的操作系统的存储管理器。目前几乎所有主流操作系统都是按照该方式加载可执行文件的。&lt;/p&gt;

&lt;h3 id=&quot;1753-从操作系统角度看可执行文件的加载&quot;&gt;17.5.3 从操作系统角度看可执行文件的加载&lt;/h3&gt;

&lt;p&gt;可执行文件中的页可能被装入内存中的任意页，如果程序使用物理地址直接进行操作，那么每次页被装入时都需要进行重定位。而有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。&lt;/p&gt;

&lt;h4 id=&quot;进程的建立&quot;&gt;进程的建立&lt;/h4&gt;

&lt;p&gt;从操作系统的角度来看，一个进程最关键的特征是它拥有 &lt;strong&gt;独立的虚拟地址空间&lt;/strong&gt;，这使得它有别于其他进程。&lt;/p&gt;

&lt;p&gt;很多时候一个程序被执行同时都伴随着一个新的进程的创建：创建一个进程，加载可执行文件并执行。&lt;/p&gt;

&lt;p&gt;在有虚拟存储的情况下，上述过程最开始只需要做三件事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个独立的 &lt;strong&gt;虚拟地址空间&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;读取可执行文件头，并且建立虚拟空间与可执行文件的 &lt;strong&gt;映射&lt;/strong&gt; 关系&lt;/li&gt;
  &lt;li&gt;将 CPU 的指令 &lt;strong&gt;寄存器&lt;/strong&gt; 设置成可执行文件的 &lt;strong&gt;入口地址&lt;/strong&gt;，启动 &lt;strong&gt;运行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;由于可执行文件在加载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做 &lt;strong&gt;映像文件&lt;/strong&gt;（Image）。&lt;/p&gt;

&lt;p&gt;可执行文件与其进程的虚拟空间的映射关系，只是保存在操作系统内部的一个数据结构。Linux 中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA, Virtual Memory Area）。操作系统在内部保存这种结构，为当程序执行发生段错误时，它可以通过查找这样的一个数据结构来定位错误页在可执行文件中的位置。&lt;/p&gt;

&lt;h4 id=&quot;页错误&quot;&gt;页错误&lt;/h4&gt;

&lt;p&gt;当 CPU 开始打算执行入口地址的指令时，如果发现该页面是个空页面，它就认为这是一个页错误（Page Fault）。&lt;/p&gt;

&lt;p&gt;CPU 将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。此时，操作系统会查询代表映射关系的数据结构，找到空页面所在的 VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。&lt;/p&gt;

&lt;p&gt;随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。有时进程所需要的内存会超过可用的内存数量，特别是在有多个进程同时执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚至有时候应将分配给进程的物理内存暂时收回。&lt;/p&gt;

&lt;h3 id=&quot;1754-进程虚拟空间分布&quot;&gt;17.5.4 进程虚拟空间分布&lt;/h3&gt;

&lt;h4 id=&quot;elf-文件链接视图和执行视图&quot;&gt;ELF 文件链接视图和执行视图&lt;/h4&gt;

&lt;p&gt;在一个正常的进程中，可执行文件中包含的往往不止代码段，还有数据段、BSS 等，所以映射到进程虚拟空间的往往不止一个段。当段的数量增多时，就会产生 &lt;strong&gt;空间浪费&lt;/strong&gt; 的问题。每个段在映射时的长度都是系统页长度的整数倍；如果不是，其多余部分也会占用一个页。&lt;/p&gt;

&lt;p&gt;操作系统加载可执行文件时，并不关心可执行文件各个段所包含的实际内容，只关心与加载相关的问题，主要是段的权限（可读、可写、可执行）。&lt;/p&gt;

&lt;p&gt;ELF 文件中，段的权限往往只有为数不多的几种组合，基本上是三种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可读可执行的段：代码段&lt;/li&gt;
  &lt;li&gt;可读可写的段：数据段和 BSS 段&lt;/li&gt;
  &lt;li&gt;只读的段：只读数据段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 &lt;strong&gt;相同权限的段&lt;/strong&gt;，把它们 &lt;strong&gt;合并&lt;/strong&gt; 到一起当作一个段进行映射。这样可以把原先的多个段当做一个整体进行映射，明显地减少页面内部碎片，节省内存空间。这个称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Segment&lt;/code&gt;，它表示一个或多个属性类似的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Section&lt;/code&gt;，可以认为 Section 是链接时的概念，Segment 是加载时的概念。链接器会把属性相似的 Section 放在一起，然后系统会按照这些 Section 组成的 Segment 来映射，并加载可执行文件。&lt;/p&gt;

&lt;h4 id=&quot;栈和堆&quot;&gt;栈和堆&lt;/h4&gt;

&lt;p&gt;进程的虚拟地址空间中除了被用来映射可执行文件的各个 Segment 之外，还有包括栈（Stack）和堆（Heap）的空间，一个进程中的栈和堆在也是以虚拟内存区域（VMA, Virtual Memrory Area）的形式存在。操作系统通过给进程空间划分出一个个的 VMA 来管理进程的虚拟空间，基本原则是将相同权限属性的、有相同映像文件的映射成一个 VMA，一个进程基本可以分为如下几种 VMA 区域：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码 VMA，权限只读，可执行，有映像文件。&lt;/li&gt;
  &lt;li&gt;数据 VMA，权限可读写，可执行，有映像文件。&lt;/li&gt;
  &lt;li&gt;堆 VMA，权限可读写，可执行，无映像文件，匿名，可向上扩展&lt;/li&gt;
  &lt;li&gt;栈 VMA，权限可读写，不可执行，无映像文件，匿名，可向下扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;174-库&quot;&gt;17.4 库&lt;/h2&gt;

&lt;p&gt;Library&lt;/p&gt;

&lt;p&gt;库是编译好的代码，可以被程序复用。库简化了程序员的工作，它们提供可重用的函数、类、数据结构等，而这些是之前由其他程序员编写的，现在可以被其他程序员所使用。&lt;/p&gt;

&lt;p&gt;例如，如果要构建的程序需要进行数学运算，你无需再编写数学函数，只需要使用库中现有的函数就可以了。&lt;/p&gt;

&lt;p&gt;Linux 中常见的库有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;libc&lt;/strong&gt; ：标准的 C 程序库&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;glibc&lt;/strong&gt;：GNU 版本的标准 C 程序库&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;libcurl&lt;/strong&gt;：多协议文件传输库&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;libcrypt&lt;/strong&gt;：用于加密、hash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux 支持两类的库：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;静态库&lt;/strong&gt;：编译期间被静态捆绑到程序中，扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;.lib&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动态库&lt;/strong&gt;：程序启动时加载，在运行时绑定。扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1741-静态库&quot;&gt;17.4.1 静态库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;文件名通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;libxxx.a &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;静态函数库在编译时会 &lt;strong&gt;整合&lt;/strong&gt; 到可执行程序中，因此最终文件比较大&lt;/li&gt;
  &lt;li&gt;编译成功的可执行文件可以 &lt;strong&gt;独立运行&lt;/strong&gt;，无需读取外部函数库&lt;/li&gt;
  &lt;li&gt;如果函数库升级，整个可执行文件须重新编译&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1742-共享库&quot;&gt;17.4.2 共享库&lt;/h3&gt;

&lt;p&gt;Linux 大多使用共享库。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件名通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;libxxx.so&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;共享库在编译时，仅在程序中保存一个指针，指向函数库。只有在可执行文件需要要使用函数库时，程序才去读取。文件比较小。&lt;/li&gt;
  &lt;li&gt;共享库编译的程序不能独立运行，依赖固定路径下的函数库。&lt;/li&gt;
  &lt;li&gt;函数库升级后，可执行文件无需重新编译。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大多数操作系统把解析共享库作为程序加载过程的一部分。在这些系统上，可执行文件包含一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;import directory&lt;/code&gt; 的表，该表的每一项包含一个库的名字。根据表中记录的名字，加载程序在硬盘上搜索需要的库，然后将其加载到内存中，之后，用库的地址来更新可执行程序。&lt;/p&gt;

&lt;p&gt;可执行程序根据更新后的库信息，调用库中的函数或引用库中的数据。这种类型的动态加载称为加载时（load-time）加载，Windows 和 Linux 均采用这种方式。加载程序在加载应用软件时要完成的最复杂的工作之一就是加载时链接。&lt;/p&gt;

&lt;p&gt;可以动态链接的函数库，在 Windows 上叫动态链接库 Dynamic Link Library（DLL），在 UNIX 或 Linux 上叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shared Library&lt;/code&gt;，共享库。&lt;/p&gt;

&lt;p&gt;库文件是预先编译、链接好的可执行文件，存储在计算机的硬盘上。大多数情况下，同一时间多个应用可以使用一个库的同一个副本，操作系统不需要加载这个库的多个实例。&lt;/p&gt;

&lt;p&gt;动态链接的最大 &lt;strong&gt;缺点&lt;/strong&gt; 是：可执行程序的运行 &lt;strong&gt;依赖&lt;/strong&gt; 于单独存储的库文件。如果库文件被删除、移动、重命名或者被替换为不兼容的版本，可执行程序就无法正常工作，即常说的 DLL-hell。&lt;/p&gt;

&lt;h4 id=&quot;共享库的命名&quot;&gt;共享库的命名&lt;/h4&gt;

&lt;p&gt;为了使用方便，共享库通常使用库名来命名，也叫 soname。实际上 soname 是指向其文件名的 &lt;strong&gt;绝对路径&lt;/strong&gt; 的符号链接。&lt;/p&gt;

&lt;p&gt;如 libc 的库名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lib&lt;/code&gt; 前缀&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; C 程序&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt; 共享库&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;  版本号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该库的文件名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib64/libc.so.6&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1743-共享库的加载&quot;&gt;17.4.3 共享库的加载&lt;/h3&gt;

&lt;p&gt;共享库是由程序 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld.so&lt;/code&gt; 及 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld-linux.so.x&lt;/code&gt; 加载的，其中 x 代表版本号。在 Linux 中，&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/ld-linux.so.x&lt;/code&gt; 会查找并加载程序所有的共享库。&lt;/p&gt;

&lt;p&gt;程序可以使用其库名或文件名来加载共享库。共享库通常位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/lib&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/lib64&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib64&lt;/code&gt; 目录中，系统启动需要的库位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib64/&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/&lt;/code&gt; 目录中，内核的库位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt; 中。也允许程序把库安装到自定义的位置。&lt;/p&gt;

&lt;p&gt;库的路径在配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.conf&lt;/code&gt; 中定义，通常默认只有一条语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;include ld.so.conf.d/*.conf&lt;/code&gt;，因此内核会加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.conf.d/&lt;/code&gt; 目录中的所有配置文件。&lt;/p&gt;

&lt;p&gt;按照这个思路，软件包的维护者或程序员就会把他们的自定义库的路径加到搜索列表中：&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.conf.d/&lt;/code&gt; 目录中新建一个自己的配置文件，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;mariadb-x86_64.conf&lt;/code&gt;，其内容为自定义库的路径 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib64/mysql&lt;/code&gt;。这样，mysql 的库路径就被加到系统库路径中了。&lt;/p&gt;

&lt;h3 id=&quot;1744-共享库高速缓存&quot;&gt;17.4.4 共享库高速缓存&lt;/h3&gt;

&lt;p&gt;把共享库载入高速缓存内存中，这样，程序在需要调用共享库时可以直接访问内存，提高效率。&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.conf&lt;/code&gt; 中指定共享库所在的目录，由 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldconfig&lt;/code&gt; 程序把 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.conf&lt;/code&gt; 中指定的目录中的共享库读入高速缓存。将共享库映射保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.cache&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.cache&lt;/code&gt; 这个文件是个二进制文件，其作用为缓存一系列映射：&lt;strong&gt;共享库文件名&lt;/strong&gt; 到其 &lt;strong&gt;完整路径&lt;/strong&gt; 的映射。如 &lt;code class=&quot;highlighter-rouge&quot;&gt;libXt.so.6&lt;/code&gt; – &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/x86_64-linux-gnu/libXt.so.6&lt;/code&gt; 这样的映射。有了这个映射表就可以快速找到程序所需的共享库。&lt;/p&gt;

  &lt;p&gt;每次往 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/&lt;/code&gt; 等系统目录安装新的共享库时，都需要运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldconfig&lt;/code&gt; 命令来更新该缓存文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以通过创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.conf.d/*.conf&lt;/code&gt; 文件，使 ldconfig 在更新缓存时自动添加自定义配置文件中指定的目录中的共享库。&lt;/p&gt;

&lt;h4 id=&quot;ldconfig-语法&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ldconfig&lt;/code&gt; 语法&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ldconfig [-f conf] [ -C cache]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ldconfig [-p]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f conf&lt;/code&gt; 手动指定配置文件 conf，从中读取共享库路径&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-C cache&lt;/code&gt; 手动指定缓存文件 cache&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;    列出当前所有共享库 （即 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ld.so.cache&lt;/code&gt; 的共享库）&lt;/p&gt;

&lt;p&gt;范例：手动指定配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# vim /etc/ld.so.conf.d/neo.conf
/usr/lib64/mysql   

~]# ldconfig  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上操作会把 Mariadb 的共享库读入高速缓存。&lt;/p&gt;

&lt;h3 id=&quot;1745-管理共享库&quot;&gt;17.4.5 管理共享库&lt;/h3&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldd&lt;/code&gt; 程序来分析可执行文件中含有哪些共享库。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ldd [-vdr] [filename]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; ：列出所有信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; ：重新检查共享库，并列出丢失的&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt; ：列出 ELF 的错误内容&lt;/p&gt;

&lt;p&gt;范例一：查看指定程序的共享库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# ldd /usr/bin/passwd
	libpam.so.0 =&amp;gt; /lib64/libpam.so.0 (0x00007f5e683dd000)            # PAM
	libpam_misc.so.0 =&amp;gt; /lib64/libpam_misc.so.0 (0x00007f5e681d8000)
	libaudit.so.1 =&amp;gt; /lib64/libaudit.so.1 (0x00007f5e67fb1000)        # SELinux
	libselinux.so.1 =&amp;gt; /lib64/libselinux.so.1 (0x00007f5e67d8c000)    # SELinux
........
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;范例二：查看指定共享库的相关共享库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# ldd -v /lib64/libc.so.6
/lib64/ld-linux-x86-64.so.2 (0x00007f7acc68f000)
linux-vdso.so.1 =&amp;gt;  (0x00007fffa975b000)

Version information:  #  -v 选项会显示其他版本信息
/lib64/libc.so.6:
		ld-linux-x86-64.so.2 (GLIBC_2.3) =&amp;gt; /lib64/ld-linux-x86-64.so.2
		ld-linux-x86-64.so.2 (GLIBC_PRIVATE) =&amp;gt; /lib64/ld-linux-x86-64.so.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;升级安装 RPM 软件时，可以先用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldd&lt;/code&gt; 来检查共享库之间的依赖关系。用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 参数可以了解该共享库来自于哪个软件。&lt;/p&gt;</content><author><name></name></author><category term="加载" /><category term="库" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 16. 程序的构建</title><link href="/linux/linux.build/" rel="alternate" type="text/html" title="Linux 基础 - 16. 程序的构建" /><published>2015-01-16T00:00:00+08:00</published><updated>2015-01-16T00:00:00+08:00</updated><id>/linux/linux.build</id><content type="html" xml:base="/linux/linux.build/">&lt;h2 id=&quot;161-程序的构建&quot;&gt;16.1 程序的构建&lt;/h2&gt;

&lt;p&gt;通常的开发环境都是流行的集成开发环境（IDE），一般都将编译和链接的过程一步完成，通常将这种 &lt;strong&gt;编译&lt;/strong&gt; 和 &lt;strong&gt;链接&lt;/strong&gt; 合并到一起的过程称为 &lt;strong&gt;构建&lt;/strong&gt;（Build）。即使使用命令行来编译一个源代码文件，简单的一句 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc hello.c&lt;/code&gt; 命令就包含了非常复杂的过程。&lt;/p&gt;

&lt;p&gt;构建程序的过程可以大致分解为预处理、编译、汇编和链接。但本节将其之前和之后的相关工作也加入进来，力图全面地讨论一个程序构建的全过程。在此要特别感谢&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/11/compiler.html&quot;&gt;阮一峰老师的文章&lt;/a&gt;以及&lt;a href=&quot;https://book.douban.com/subject/3652388/&quot;&gt;《程序员的自我修养》这本书&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/gcc.build.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compile.process2.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;源代码也称源程序，是指一系列人类可读的计算机语言指令。C 语言的源代码文件后缀为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1611-配置&quot;&gt;16.1.1 配置&lt;/h3&gt;

&lt;p&gt;Configure&lt;/p&gt;

&lt;p&gt;编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做 “配置”（configure）。&lt;/p&gt;

&lt;p&gt;这些配置信息保存在一个配置文件之中，约定俗成是一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 的脚本文件。通常它是由 &lt;code class=&quot;highlighter-rouge&quot;&gt;autoconf&lt;/code&gt; 工具生成的。编译器通过运行这个脚本，获知编译参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 脚本提供编译参数。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/www &lt;span class=&quot;nt&quot;&gt;--with-mysql&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码是 php 源码的一种编译配置，用户指定安装后的文件保存在 www 目录，并且编译时加入 mysql 模块的支持。&lt;/p&gt;

&lt;h3 id=&quot;1612-确定标准库和头文件的位置&quot;&gt;16.1.2 确定标准库和头文件的位置&lt;/h3&gt;

&lt;p&gt;源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。&lt;/p&gt;

&lt;p&gt;编译的第二步，就是从配置文件中了解标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。&lt;/p&gt;

&lt;h3 id=&quot;1613-确定信赖关系&quot;&gt;16.1.3 确定信赖关系&lt;/h3&gt;

&lt;p&gt;对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定 A 文件依赖于 B 文件，编译器应该保证做到下面两点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有在 B 文件编译完成后，才开始编译 A 文件。&lt;/li&gt;
  &lt;li&gt;当 B 文件发生变化时，A 文件会被重新编译。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;编译顺序保存在一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 的文件中，里面列出哪个文件先编译，哪个文件后编译。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 文件由 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 脚本运行生成，这就是为什么编译时 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 必须首先运行的原因。&lt;/p&gt;

&lt;p&gt;在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。&lt;/p&gt;

&lt;h3 id=&quot;1614-头文件的预编译&quot;&gt;16.1.4 头文件的预编译&lt;/h3&gt;

&lt;p&gt;PreCompilation&lt;/p&gt;

&lt;p&gt;不同的源码文件，可能引用同一个头文件（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;stdio.h&lt;/code&gt;）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。&lt;/p&gt;

&lt;p&gt;不过，并不是头文件的所有内容，都会被预编译。用来声明宏的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt; 命令，就不会被预编译。&lt;/p&gt;

&lt;h3 id=&quot;1615-预处理&quot;&gt;16.1.5 预处理&lt;/h3&gt;

&lt;p&gt;PreProcessing&lt;/p&gt;

&lt;p&gt;C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。C 预处理器只不过是一个 &lt;strong&gt;文本替换工具&lt;/strong&gt; 而已，它们会指示编译器在实际编译之前完成所需的预处理。C 预处理器（C Preprocessor）简写为 CPP。它用于在编译器处理程序之前 &lt;strong&gt;预扫描源代码&lt;/strong&gt;，完成头文件的包含, 宏扩展, 条件编译, 行控制（line control）等操作。&lt;/p&gt;

&lt;p&gt;C 源代码文件扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;，预处理之后的扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.i&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;经过预处理后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.i&lt;/code&gt; 文件不包含任何宏定义，因为所有的宏已经被 &lt;strong&gt;展开&lt;/strong&gt;，并且包含的文件也已经被 &lt;strong&gt;插入&lt;/strong&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;.i&lt;/code&gt; 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预处理后的文件来确定问题。&lt;/p&gt;

&lt;h4 id=&quot;编译阶段&quot;&gt;编译阶段&lt;/h4&gt;

&lt;p&gt;C 语言标准规定，编译共分 8 个阶段，预处理是指前 4 个编译阶段（phases of translation）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三字符组与双字符组的替换&lt;/li&gt;
  &lt;li&gt;行拼接（Line splicing）: 把物理源码行（Physical source line）中的换行符转义字符处理为普通的换行符，从而把源程序处理为逻辑行的顺序集合。&lt;/li&gt;
  &lt;li&gt;单词化（Tokenization）: 把处理结果变成 token 和空格，把注释替换为空格。&lt;/li&gt;
  &lt;li&gt;宏扩展与预处理指令（directive）处理.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;处理头文件&quot;&gt;处理头文件&lt;/h4&gt;

&lt;p&gt;include 包含文件，即头文件，扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;处理 &lt;code class=&quot;highlighter-rouge&quot;&gt;#include&lt;/code&gt; 预编译指令，将被包含的文件 &lt;strong&gt;插入&lt;/strong&gt; 到该预编译指令的位置。注意，这个过程是 &lt;strong&gt;递归&lt;/strong&gt; 进行的，也就是说被包含的文件可能还包含其他文件。&lt;/p&gt;

&lt;h4 id=&quot;处理条件预编译指令&quot;&gt;处理条件预编译指令&lt;/h4&gt;

&lt;p&gt;处理所有条件预编译指令，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;#if&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;#elif&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;#else&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;#endif&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;处理宏定义与扩展&quot;&gt;处理宏定义与扩展&lt;/h4&gt;

&lt;p&gt;将所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt; 删除，并且展开所有的宏定义。&lt;/p&gt;

&lt;h4 id=&quot;特殊宏与指令&quot;&gt;特殊宏与指令&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__FILE__&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;__LINE__&lt;/code&gt;, 扩展为当前文件与行号。以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。&lt;/p&gt;

&lt;h4 id=&quot;token-字符串化&quot;&gt;Token 字符串化&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 运算符把随后的 token（记号） 转化为 C 语言的字符串。&lt;/p&gt;

&lt;h4 id=&quot;token-连接&quot;&gt;Token 连接&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt; 运算符连接两个 token 为一个 token.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt; 运算符左侧或右侧如果是另一个宏名，这个宏名将不会被宏展开，而是按照字面值被当作一个 token。因此，如果需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt; 运算符左右的宏名做宏展开，需要使用两层宏的嵌套使用，其中外层的宏展开时也一并把 &lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt; 运算符左右的宏名做宏展开。&lt;/p&gt;

&lt;h4 id=&quot;用户定义的编译错误与警告&quot;&gt;用户定义的编译错误与警告&lt;/h4&gt;

&lt;h4 id=&quot;编译器相关的预处理特性&quot;&gt;编译器相关的预处理特性&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#pragma&lt;/code&gt; 指令提供了编译器特定的预处理功能。&lt;/p&gt;

&lt;h3 id=&quot;1616-编译&quot;&gt;16.1.6 编译&lt;/h3&gt;

&lt;p&gt;Compilation&lt;/p&gt;

&lt;p&gt;预处理的输出通常是轻微扩展过的 C，包含对于标准库所有相关部分的声明，下一步的构建流程是编译和汇编，它们把预处理的输出转换成目标文件。&lt;/p&gt;

&lt;p&gt;预处理之后，编译器就开始生成机器码。有两种基本的方法把 C 转成机器码，一种是直接进行转换，另一种是先转换为汇编码（介于 C 与机器码之间，易于阅读），再转换为机器码。&lt;/p&gt;

&lt;p&gt;编译过程就是把预处理完的文件进行一系列 “词法分析、语法分析、语义分析及优化” 后生产相应的 &lt;strong&gt;汇编代码文件&lt;/strong&gt;，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。&lt;/p&gt;

&lt;h4 id=&quot;基础概念&quot;&gt;基础概念&lt;/h4&gt;

&lt;h5 id=&quot;编译器&quot;&gt;编译器&lt;/h5&gt;

&lt;p&gt;编译器（compiler），是一种计算机程序，可以把（某种编程语言写成的）源代码转换成另一种编程语言。&lt;/p&gt;

&lt;p&gt;常用的编译器为 &lt;strong&gt;GCC&lt;/strong&gt;，即 GNU Compiler Collection。&lt;/p&gt;

&lt;h5 id=&quot;原始语言与目标语言&quot;&gt;原始语言与目标语言&lt;/h5&gt;

&lt;p&gt;对于编译器来说，原始的编程语言称原始语言，转换后的语言称目标语言。&lt;/p&gt;

&lt;p&gt;对于程序员来说，原始语言往往更便于编写、阅读、维护，是高级计算机语言。而目标语言往往是计算机可以解读、运行的低级语言。&lt;/p&gt;

&lt;p&gt;源代码一般为高阶语言，如 Pascal、C、C++、C# 、Java 等，而目标语言则是汇编语言或目标机器的目标代码，有时也称作机器代码（Machine code）。&lt;/p&gt;

&lt;p&gt;编译器的目的在于把源代码程序翻译为目标语言程序。&lt;/p&gt;

&lt;h4 id=&quot;编译的基本过程&quot;&gt;编译的基本过程&lt;/h4&gt;

&lt;p&gt;编译在把源语言编译为目标语言的过程中，通常包括以下几个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;扫描&lt;/li&gt;
  &lt;li&gt;语法分析；&lt;/li&gt;
  &lt;li&gt;语义分析；&lt;/li&gt;
  &lt;li&gt;源代码优化&lt;/li&gt;
  &lt;li&gt;中间代码生成和优化；&lt;/li&gt;
  &lt;li&gt;目标代码生成和优化；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compile.process.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在版本的 GCC 把预处理和编译两个步骤 &lt;strong&gt;合并&lt;/strong&gt; 成一个步骤，使用一个叫做 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;&lt;/strong&gt; 的程序来完成这两个步骤。这个程序位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/gcc/i486-linux-gnu/4.1/&lt;/code&gt;，也可以直接调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt; 来完成它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ /usr/lib/gcc/i486-linux-gnu/4.1/cc1 hello.c
 main
Execution times (seconds)
 preprocessing  :0.01(100%)usr  0.01(33%)sys  0.00( 0%)wall 77 kB( 8%)ggc
 lexical analysis :0.00( 0%)usr 0.00( 0%)sys  0.02(50%)wall 0 kB(0%)ggc
 parser         :0.00( 0%)usr 0.00( 0%)sys  0.01(25%)wall 125 kB(13%)ggc
 expand         :0.00( 0%)usr 0.01(33%)sys  0.00( 0%)wall 6 kB(1%)ggc
 TOTAL            :0.01         0.03        0.04          982 kB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者使用 gcc：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc –S hello.c –o hello.s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上两种方法都可以得到汇编输出文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.s&lt;/code&gt;。对于 C 语言的代码来说，这个预编译和编译的程序是 &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;所以实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序 &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;、汇编器 &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;、链接器 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;汇编&quot;&gt;汇编&lt;/h4&gt;

&lt;p&gt;对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。&lt;/p&gt;

&lt;p&gt;汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。&lt;/p&gt;

&lt;p&gt;所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编” 这个名字也来源于此。&lt;/p&gt;

&lt;p&gt;上面的汇编过程我们可以调用汇编器 &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt; 来完成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$as hello.s –o hello.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 命令从 C 源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$gcc –c hello.c –o hello.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;目标文件&quot;&gt;目标文件&lt;/h4&gt;

&lt;p&gt;Object file&lt;/p&gt;

&lt;p&gt;程序的源代码经过 &lt;strong&gt;编译后生成的文件&lt;/strong&gt;，称为目标文件，其实如果叫 &lt;strong&gt;中间目标文件&lt;/strong&gt; 会更容易理解其作用。&lt;/p&gt;

&lt;p&gt;目标文件从结构上讲，它是已经编译后的 &lt;strong&gt;可执行文件格式&lt;/strong&gt;，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。&lt;/p&gt;

&lt;h5 id=&quot;目标文件的格式&quot;&gt;目标文件的格式&lt;/h5&gt;

&lt;p&gt;当今可执行文件格式主要是 Windows 中的 &lt;strong&gt;PE&lt;/strong&gt;（Portable Executable）和 Linux 中的 &lt;strong&gt;ELF&lt;/strong&gt;（Executable Linkable Format），它们都是 &lt;strong&gt;COFF&lt;/strong&gt;（Common file format）格式的变种。&lt;/p&gt;

&lt;p&gt;目标文件就是源代码编译后，但未进行链接的那些 &lt;strong&gt;中间文件&lt;/strong&gt;（Windows 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.obj&lt;/code&gt; 和 Linux 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;），它跟可执行文件的内容与结构很相似，所以一般 &lt;strong&gt;与可执行文件采用相同的格式&lt;/strong&gt; 存储。&lt;/p&gt;

&lt;p&gt;从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是一种类型的文件，在 Windows 中，我们可以统称它们为 &lt;code class=&quot;highlighter-rouge&quot;&gt;PE-COFF&lt;/code&gt; 文件格式。在 Linux 中，我们可以将它们统称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ELF&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;其他不太常见的可执行文件格式还有 Intel/Microsoft 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;OMF&lt;/code&gt;（Object Module Format）、Unix &lt;code class=&quot;highlighter-rouge&quot;&gt;a.​out&lt;/code&gt; 格式和 MS-DOS &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; 格式等。&lt;/p&gt;

&lt;p&gt;目标文件一般有以下几类：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文件类型&lt;/th&gt;
      &lt;th&gt;英文名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;实例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;可重定位文件&lt;/td&gt;
      &lt;td&gt;Relocatable File&lt;/td&gt;
      &lt;td&gt;包含 &lt;strong&gt;代码和数据&lt;/strong&gt;，可以被链接成可执行文件或共享目标文件，&lt;strong&gt;静态链接库&lt;/strong&gt; 属于这一类&lt;/td&gt;
      &lt;td&gt;Linux 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可执行文件&lt;/td&gt;
      &lt;td&gt;Executable File&lt;/td&gt;
      &lt;td&gt;包含了 &lt;strong&gt;可以直接执行的程序&lt;/strong&gt;，一般 &lt;strong&gt;没有扩展名&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;共享目标文件&lt;/td&gt;
      &lt;td&gt;Shared Object File&lt;/td&gt;
      &lt;td&gt;包含 &lt;strong&gt;代码和数据&lt;/strong&gt;，可以跟其他可重定位文件和共享目标文件链接产生新的目标文件，也可以跟可执行文件结合作为进程映像的一部分来运行&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt; 文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;核心转储文件&lt;/td&gt;
      &lt;td&gt;Core Dump File&lt;/td&gt;
      &lt;td&gt;当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件&lt;/td&gt;
      &lt;td&gt;core dump&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; 命令来查看相应的类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ file foobar.o
foobar.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
#                        ^^^^^^^^^^^
$ file /bin/bash
/bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.8, dynamically linked (uses shared libs), stripped
#                         ^^^^^^^^^^
$ file /lib/ld-​2.​6.​1.​so
/lib/libc-2.​6.​1.​so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.8, stripped
#                                  ^^^^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;可执行文件格式的演变&quot;&gt;可执行文件格式的演变&lt;/h5&gt;

&lt;p&gt;目标文件与可执行文件格式跟操作系统和编译器密切相关，所以不同的系统平台下会有不同的格式，但这些格式又大同小异，目标文件格式与可执行文件格式的历史几乎是操作系统的发展史。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COFF&lt;/strong&gt; 是由 Unix System V Release 3 首先提出并且使用的格式规范，后来微软公司基于 &lt;code class=&quot;highlighter-rouge&quot;&gt;COFF&lt;/code&gt; 格式，制定了 &lt;code class=&quot;highlighter-rouge&quot;&gt;PE&lt;/code&gt; 格式标准，并将其用于当时的 Windows NT 系统。System V Release 4 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;COFF&lt;/code&gt; 的基础上引入了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ELF&lt;/code&gt; 格式，目前流行的 Linux 系统也以 &lt;code class=&quot;highlighter-rouge&quot;&gt;ELF&lt;/code&gt; 作为基本可执行文件格式。这也就是目前 PE 和 ELF 如此相似的主要原因，它们都源于同一种可执行文件格式 &lt;code class=&quot;highlighter-rouge&quot;&gt;COFF。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unix 最早的可执行文件格式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a.​out&lt;/code&gt; 格式，它的设计非常简单，以至于后来共享库这个概念出现的时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;a.​out&lt;/code&gt; 格式就变得捉襟见肘了。于是人们设计了 &lt;code class=&quot;highlighter-rouge&quot;&gt;COFF&lt;/code&gt; 格式来解决这些问题，这个设计非常通用，以至于 COFF 的继承者到目前还在被广泛地使用。&lt;/p&gt;

&lt;p&gt;COFF 的主要贡献是在目标文件里面引入了 “&lt;strong&gt;段&lt;/strong&gt;” 的机制，不同的目标文件可以拥有不同数量及不同类型的 “段”。另外，它还定义了调试数据格式。&lt;/p&gt;

&lt;h5 id=&quot;目标文件结构&quot;&gt;目标文件结构&lt;/h5&gt;

&lt;p&gt;目标文件中的内容除了编译后的机器指令代码、数据以外，还包括链接时所须要的符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以 “节”（Section）的形式存储，有时候也叫 “段”（Segment），在一般情况下，它们都表示一个一定长度的区域，基本上不加以区别，唯一的区别是在 ELF 的链接视图和加载视图的时候，默认情况下统一将它们称为 “段”。&lt;/p&gt;

&lt;p&gt;目标文件由许多段组成，其中主要的段包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;代码段&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;.code&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt;，保存编译后得到的 &lt;strong&gt;机器指令&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据段&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt;，保存 &lt;strong&gt;已初始化的全局静态变量和局部静态变量&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;只读数据段&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;.rodata&lt;/code&gt;，保存 &lt;strong&gt;只读变量和字符串常量&lt;/strong&gt;，有些编译器会把字符串常量放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt; 段。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BSS 段&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;.bss&lt;/code&gt;，保存 &lt;strong&gt;未初始化的全局变量和局部静态变量&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;未初始化的全局变量和局部静态变量默认值都为 0，本来它们也可以被放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt; 段的，但是因为它们都是 0，所以为它们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt; 段分配空间并且存放数据 0 是没有必要的。程序运行的时候它们的确是要占内存空间的，并且可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和，记为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bss&lt;/code&gt; 段。所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bss&lt;/code&gt; 段只是为未初始化的全局变量和局部静态变量 &lt;strong&gt;预留位置&lt;/strong&gt; 而已，它并没有内容，所以它在文件中也 &lt;strong&gt;不占据空间&lt;/strong&gt;。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/obj.file.png&quot; alt=&quot;目标文件的结构&quot; /&gt;
  
&lt;/figure&gt;

&lt;p&gt;从图中可以看到，ELF 文件的开头是一个 “文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，文件头还包括一个段表（Section Table），段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，比如代码段保存的就是程序的指令，数据段保存的就是程序的静态变量等。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;总体来说，程序源代码被编译以后主要分成两种段：&lt;strong&gt;程序指令&lt;/strong&gt; 和 &lt;strong&gt;程序数据&lt;/strong&gt;。代码段属于程序指令，而数据段和 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bss&lt;/code&gt; 段属于程序数据。&lt;/p&gt;

&lt;h3 id=&quot;1617-链接&quot;&gt;16.1.7 链接&lt;/h3&gt;

&lt;p&gt;Linking&lt;/p&gt;

&lt;p&gt;目标文件还不能运行，必须进一步转成可执行文件。&lt;/p&gt;

&lt;p&gt;编译器的下一步工作，就是把外部函数的代码（通常是后缀名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.lib&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt; 的文件），添加到可执行文件中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令的作用，就是从头文件预编译开始，一直到做完这一步。&lt;/p&gt;

&lt;h4 id=&quot;基础概念-1&quot;&gt;基础概念&lt;/h4&gt;

&lt;h5 id=&quot;链接器&quot;&gt;链接器&lt;/h5&gt;

&lt;p&gt;链接器是一个独立程序，用于将一个或多个库或目标文件链接到一起，生成可执行程序。&lt;/p&gt;

&lt;p&gt;gcc 中的链接器为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Linker.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;链接器不仅可以把源代码编译成的目标文件链接成为可执行文件，还可以用于生成库文件。&lt;/p&gt;

&lt;h5 id=&quot;重定位&quot;&gt;重定位&lt;/h5&gt;

&lt;p&gt;Relocation&lt;/p&gt;

&lt;p&gt;重定位是指给部分程序源代码 &lt;strong&gt;分配加载地址&lt;/strong&gt;，但该部分代码在整体源代码中的位置不是固定的。这个工作通常由链接器来完成。它会在文件或运行库中搜索特定的符号或运行库的名称，用真实可用的内存地址来替换。只有经过该过程，程序才能正常运行。&lt;/p&gt;

&lt;p&gt;重定位通常由链接器在链接时完成，但也可以由重定位加载器在加载时完成，或者由运行时程序在运行时完成。&lt;/p&gt;

&lt;h5 id=&quot;符号&quot;&gt;符号&lt;/h5&gt;

&lt;p&gt;Symbol&lt;/p&gt;

&lt;p&gt;在重定位时，汇编语言使用特定的字符串来标记位置，以便于定位。该字符串称为符号。&lt;/p&gt;

&lt;p&gt;汇编语言使用接近人类的各种符号和标记来帮助记忆，比如指令采用两个或三个字母的缩写。&lt;/p&gt;

&lt;p&gt;符号这个概念随着汇编语言的普及迅速被使用，它用来表示一个 &lt;strong&gt;地址&lt;/strong&gt;，这个地址可能是一段 &lt;strong&gt;子程序&lt;/strong&gt;（后来发展成函数）的起始地址，也可以是一个 &lt;strong&gt;变量&lt;/strong&gt; 的起始地址。&lt;/p&gt;

&lt;p&gt;汇编器在每次汇编程序的时候，会重新计算符号的地址，然后把所有引用到该符号的指令修正到这个正确的地址。&lt;/p&gt;

&lt;p&gt;符号相当于链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。&lt;/p&gt;

&lt;h5 id=&quot;模块&quot;&gt;模块&lt;/h5&gt;

&lt;p&gt;随着软件的规模日渐庞大，程序的代码量快速膨胀，于是人们开始将代码 &lt;strong&gt;按照功能或性质划分&lt;/strong&gt;，分别形成不同的功能模块，不同的模块之间按照 &lt;strong&gt;层次结构&lt;/strong&gt; 或其他结构来组织。C语言中，最小的单位是变量和函数，若干个变量和函数组成一个模块，存放在一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt; 的源代码文件里，然后这些源代码文件按照目录结构来组织。&lt;/p&gt;

&lt;p&gt;现代的大型软件往往拥有成千上万个模块，它们相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。&lt;/p&gt;

&lt;p&gt;在一个程序被分割成多个模块以后，就要实现 &lt;strong&gt;模块之间的通信&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;最常见的属于静态语言的 C/C++ 模块之间通信有两种方式，一种是模块间的 &lt;strong&gt;函数调用&lt;/strong&gt;，另外一种是模块间的 &lt;strong&gt;变量访问&lt;/strong&gt;。函数调用须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是 &lt;strong&gt;模块间符号的引用&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;链接&quot;&gt;链接&lt;/h5&gt;

&lt;p&gt;程序设计的模块化使得复杂的软件其源代码模块能够独立地编译，然后按照需要将它们 “组装” 起来，这个组装模块的过程就是链接（Linking）。链接的主要内容就是把各个模块之间 &lt;strong&gt;相互引用的部分&lt;/strong&gt; 都处理好，使得各个模块之间能够正确地衔接。从原理上来讲，就是把一些指令对其他符号地址的引用加以修正。&lt;/p&gt;

&lt;p&gt;链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号解析（Symbol Resolution）和重定位（Relocation）等这些步骤。&lt;/p&gt;

&lt;h5 id=&quot;符号解析&quot;&gt;符号解析&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Symbol Resolution&lt;/strong&gt;，也叫 Symbol Binding，Name Binding，Name Resolution，Address Binding，Instruction Binding。变态！&lt;/p&gt;

&lt;p&gt;符号解析就是将目标文件中的 &lt;strong&gt;符号引用&lt;/strong&gt; 与其它目标文件中的 &lt;strong&gt;符号定义&lt;/strong&gt; &lt;strong&gt;绑定&lt;/strong&gt; 起来&lt;/p&gt;

&lt;p&gt;最常见的简单解析方式需要将一个目标文件中的符号引用与另一个目标文件中的符号定义绑定起来。此种绑定可用于两个可重定位目标文件之间，也可用于一个可重定位目标文件与在共享目标文件依赖项中找到的第一个定义之间。复杂解析方式通常用于两个或多个可重定位目标文件之间。&lt;/p&gt;

&lt;h5 id=&quot;库&quot;&gt;库&lt;/h5&gt;

&lt;p&gt;库（library）是用于开发软件的 &lt;strong&gt;子程序集合&lt;/strong&gt;。库和可执行文件的区别是，库不是独立程序，他们是向其他程序提供服务的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;链接库&lt;/strong&gt; 是指把一个或多个库包括到程序中，有两种链接形式：&lt;strong&gt;静态链接&lt;/strong&gt; 和 &lt;strong&gt;动态链接&lt;/strong&gt;，相应的，前者链接的库叫做静态链接库，后者叫动态链接库。&lt;/p&gt;

&lt;p&gt;Linux 内核提供很多内核相关的函数库与外部参数，这些核心功能在设计硬件驱动程序时相当有用，多位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/include&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib&lt;/code&gt; ，&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib64&lt;/code&gt; 里面。&lt;/p&gt;

&lt;h4 id=&quot;静态链接&quot;&gt;静态链接&lt;/h4&gt;

&lt;p&gt;静态链接是由链接器在链接时 &lt;strong&gt;将库的内容加入到可执行程序中&lt;/strong&gt; 的做法。对于链接器来说，静态链接的过程，就是将几个输入文件加工后 &lt;strong&gt;合并&lt;/strong&gt; 成一个输出文件。输入为目标文件、库文件，输出为可执行文件。&lt;/p&gt;

&lt;p&gt;静态链接的最大缺点是生成的 &lt;strong&gt;可执行文件体积过大&lt;/strong&gt;，需要更多的系统资源，在载入内存时也会消耗更多的时间。&lt;/p&gt;

&lt;h5 id=&quot;链接基本流程&quot;&gt;链接基本流程&lt;/h5&gt;

&lt;p&gt;静态链接的主要工作包括空间和地址分配、符号决议、重定位。链接完毕后，数据访问、指令跳转的目标虚拟地址就都确定了。&lt;/p&gt;

&lt;p&gt;链接器首先扫描输入的目标文件，计算输出文件各段大小，合并同类段，分配虚拟地址。再根据重定位表（记录哪些指令需要调整、如何调整）和符号表（记录所有的符号及地址），确定编译时无法确定的符号地址，修改机器指令，这一步可以概括为 “把什么修改为什么”。如果最后仍有符号无法确定地址，就报告 “undefined reference” 错误。&lt;/p&gt;

&lt;h5 id=&quot;合并文件&quot;&gt;合并文件&lt;/h5&gt;

&lt;p&gt;几个目标文件进行链接时，每个目标文件都有其自身的代码段、数据段等，链接器需要将它们各个段的合并到输出文件中，具体有两种合并方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按序叠加：将输入的目标文件按照次序叠加起来。&lt;/li&gt;
  &lt;li&gt;相似段合并：将相同性质的段合并到一起，比如将所有输入文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; 合并到输出文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; 段，接着是 &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt; 段、&lt;code class=&quot;highlighter-rouge&quot;&gt;.bss&lt;/code&gt; 段等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种方法会产生很多零散的段，而且每个段有一定的地址和空间对齐要求，会造成内存空间大量的内部碎片。所以现在的链接器空间分配基本采用 &lt;strong&gt;第二种方法&lt;/strong&gt;，而且一般采用一种称为 &lt;strong&gt;两部链接&lt;/strong&gt; 的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;空间与地址分配。扫描所有输入的目标文件，获得他们各个段的长度、属性和位置，收集它们符号表中所有的符号定义和符号引用，统一放到一个全局符号表中。此时，链接器可以获得所有输入目标文件的段长度，将他们合并，计算出输出文件中各个段合并后的长度与位置并建立映射关系。&lt;/li&gt;
  &lt;li&gt;符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过第一步后，输入文件中的各个段在链接后的虚拟地址已经确定了，链接器开始计算各个符号的虚拟地址。各个符号在段内的相对地址是固定的，链接器只需要给他们加上一个偏移量，调整到正确的虚拟地址即可。&lt;/p&gt;

&lt;h5 id=&quot;重定位-1&quot;&gt;重定位&lt;/h5&gt;

&lt;p&gt;ELF 中每个需要重定位的段都有一个对应的重定位表，也称为重定位段。重定位表中每个需要重定位的地方叫一个重定位入口，包含：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重定位入口的偏移：对于可重定位文件来说，偏移指该重定位入口所要修正的位置的第一个字节相对于该段的起始偏移。&lt;/li&gt;
  &lt;li&gt;重定位入口的类型和符号：低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表的下标。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同的处理器指令对于地址的格式和方式都不一样，对于每一个重定位入口，根据其重定位类型使用对应的指令修正方式修改其指令地址，完成重定位过程。&lt;/p&gt;

&lt;h4 id=&quot;动态链接&quot;&gt;动态链接&lt;/h4&gt;

&lt;p&gt;静态链接的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时运行多个静态链接的进程时，如果其中包含多个相同的模块，会级大地浪费内存空间。&lt;/li&gt;
  &lt;li&gt;一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为解决以上问题，可以把程序的模块相互分割开，开成独立的文件，等到程序要运行时才进行链接。&lt;/p&gt;

&lt;p&gt;动态链接是指在可执行文件加载或运行时，&lt;strong&gt;由操作系统的加载程序动态加载库&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux 平台扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;，Windows 平台是 &lt;code class=&quot;highlighter-rouge&quot;&gt;.dll&lt;/code&gt;，Mac 平台是 &lt;code class=&quot;highlighter-rouge&quot;&gt;.dylib&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;动态链接原理&quot;&gt;动态链接原理&lt;/h5&gt;

&lt;p&gt;使用了动态链接之后，当我们运行一个程序时，系统会首先加载该程序依赖的其他的目标文件，如果其他目标文件还有依赖，系统会按照同样方法将它们 &lt;strong&gt;全部加载到内存&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当所需要的所有目标文件加载完毕之后，如果依赖关系满足，系统开始进行链接操作，包括符号解析及地址重定位等。&lt;/p&gt;

&lt;p&gt;完成之后，系统把控制权交回给原程序，程序开始运行。&lt;/p&gt;

&lt;p&gt;此时如果运行第二个程序，它依赖于一个已经加载过的目标文件，则系统不需要重新加载目标文件，而只要将它们连接起来即可。&lt;/p&gt;

&lt;p&gt;对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，那就是可执行文件本身。但是对于动态链接来说，除了可执行文件本身，还有它所依赖的共享目标文件（库），此时，它们都是被操作系统用同样的方法映射进进程的虚拟地址空间，只是它们占用的虚拟地址和长度不同。另外，动态链接器也和普通共享对象一样被映射到进程的地址空间。&lt;/p&gt;

&lt;p&gt;系统开始运行程序之前，会把控制权交给动态链接器，由它完成所有的动态链接工作，然后再把控制权交回给程序，程序就开始执行。&lt;/p&gt;

&lt;h5 id=&quot;动态链接优点&quot;&gt;动态链接优点&lt;/h5&gt;

&lt;p&gt;模块化的好处不仅仅是节省内存，它还可以 &lt;strong&gt;减少物理页面的换入换出&lt;/strong&gt;，也可以 &lt;strong&gt;增加 CPU 缓存的命中率&lt;/strong&gt;，因为不同进程间的数据和指令访问都集中在了同一个共享模块上。&lt;/p&gt;

&lt;p&gt;动态链接方案也可以使程序的升级变得更加容易，当我们要升级程序库或程序共享的某个模块时，理论上只要简单地将旧的目标文件覆盖掉，而无须将所有的程序再重新链接一遍。当程序下一次运行的时候，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。&lt;/p&gt;

&lt;h5 id=&quot;程序可扩展性和兼容性&quot;&gt;程序可扩展性和兼容性&lt;/h5&gt;

&lt;p&gt;动态链接还有一个特点就是程序在运行时可以动态地选择加载各种程序模块，这个优点就是后来被人们用来制作程序的插件。&lt;/p&gt;

&lt;h5 id=&quot;加载时重定位&quot;&gt;加载时重定位&lt;/h5&gt;

&lt;p&gt;动态链接的共享对象在被加载时，其在进程虚拟地址空间的位置是不确定的，为了使共享对象能够在任意地址加载，可以参考静态链接时的重定位（Link Time Relocation）思想，在链接时对所有的绝对地址的引用不做重定位，把这一步推迟到加载时再完成。一旦模块加载完毕，其地址就确定了，即目标地址确定，系统就对程序中所有的绝对地址引用进行重定位。这种加载时重定位（Load Time Relocation）又称为基址重置（Rebasing）。&lt;/p&gt;

&lt;p&gt;但是动态链接模块被加载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于加载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位之后对于每个进程来讲是不同的。当然，动态链接库中的可修改的数据部分对于不同的进程来说有多个副本，所以它们可以采用加载时重定位的方法来解决。&lt;/p&gt;

&lt;h3 id=&quot;1618-安装&quot;&gt;16.1.8 安装&lt;/h3&gt;

&lt;p&gt;Installation&lt;/p&gt;

&lt;p&gt;安装就是指把生成的可执行文件与相关数据文件复制到安装目录。&lt;/p&gt;

&lt;p&gt;经过链接，链接器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。&lt;/p&gt;

&lt;p&gt;此时可执行文件与目标文件、源文件都放在一起，非常没有条理。这种情况，很难把程序传递给别人。当然，在编译时可以把生成的可执行文件保存到指定的路径。但是这两种情况都需要复制一些文件，再重新组织一下文件，程序才能正常使用。&lt;/p&gt;

&lt;h4 id=&quot;提升权限&quot;&gt;提升权限&lt;/h4&gt;

&lt;p&gt;要说最简单的安装，可以把源文件、目标文件、可执行文件一股脑统统复制到安装路径，在概念上没有什么难点。但往往需要单独的一步：&lt;strong&gt;提升权限&lt;/strong&gt;。因为安装路径往往是系统目录，普通用户是无权写入的，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;细节操作&quot;&gt;细节操作&lt;/h4&gt;

&lt;p&gt;在此步骤中，构建系统还有一些细微的细节。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在把程序安装到目标路径之前，构建系统需要首先 &lt;strong&gt;创建目录&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;安装程序时往往需要 “&lt;strong&gt;轻量化&lt;/strong&gt;” 可执行文件：放弃符号表、调试信息等，程序运行时不需要它们&lt;/li&gt;
  &lt;li&gt;把 &lt;strong&gt;调试符号&lt;/strong&gt; 单独 &lt;strong&gt;分割&lt;/strong&gt; 也来，保存为一个单独的文件，通常保存在网络上，需要调试信息时再下载&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;设定文件的权限&quot;&gt;设定文件的权限&lt;/h4&gt;

&lt;p&gt;为要安装的文件设定权限，很容易弄错，尤其是需要与默认权限不同的时候。在 Linux 中，需要设定精细的权限来避免危及系统安全。&lt;/p&gt;

&lt;h3 id=&quot;1619-链接到操作系统&quot;&gt;16.1.9 链接到操作系统&lt;/h3&gt;

&lt;p&gt;单纯的一个可执行文件文件没什么用，它只有一个文件名而已。此时需要的是一种元数据：比文件名更长的描述、图标、版本号诸如此类的东西。操作系统系统需要把程序的所有这些元数据都登记下来。在 Linux 中，这些信息通常保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/share/applications&lt;/code&gt; 目录中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.desktop&lt;/code&gt; 文件中。在 windows 中还要在开始菜单中创建快捷方式。&lt;/p&gt;

&lt;p&gt;这些操作就是 “链接到操作系统”。&lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt;  所做的就是 “安装” 和 “链接到操作系统” 这两步操作。&lt;/p&gt;

&lt;h3 id=&quot;16110-生成安装包&quot;&gt;16.1.10 生成安装包&lt;/h3&gt;

&lt;p&gt;可执行文件只有做成可以分发的安装包，才便于程序的传播和使用。&lt;/p&gt;

&lt;p&gt;所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。&lt;/p&gt;

&lt;h2 id=&quot;162-自动化构建工具-make&quot;&gt;16.2 自动化构建工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;以上所讨论的是程序编译的理论步骤，但实际使用中不可能每一步都需要人为地干预，更不可能每一步都用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 命令去人工运行，往往会使用更有效率的自动化工具。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 是一个用于程序构建的 &lt;strong&gt;自动化&lt;/strong&gt; 工具，它会从源代码自动地构建可执行文件和库。它需要借助 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 来设定构建过程要遵守的 &lt;strong&gt;规则&lt;/strong&gt;。它可用于任何涉及把命令变成目标文件的场景。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 虽然可以编译、链接单个的文件，但它不知道如何把 &lt;strong&gt;多个&lt;/strong&gt; 源文件组合成一个可执行文件，通常需要至少两个 gcc（编译和链接）调用来创建最简单的程序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中的规则详细描述了如何从源代码一步一步地变成目标程序。&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 会解析 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;，确定哪些文件需要编译，然后调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 进行对应的操作。&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 非常适用于 &lt;strong&gt;大型&lt;/strong&gt; 的开发项目，成百上千的源文件，可以持续追踪编译选项、包含路径等，还可以追踪源文件与目标文件的信赖关系，根据规则 &lt;strong&gt;只编译最近发生变化的部分&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;make 会去读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中的设置，创建目标文件，链接函数库进行编译。类似于批处理的效果。如果修改了某一个文件之后，重新使用 make 来编译，make 只会更新修改过的文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 使用 &lt;strong&gt;目标&lt;/strong&gt; 做为 &lt;strong&gt;参数&lt;/strong&gt; 来构建程序。如果不加参数，它会构建在 makefile 中第一个出现的目标文件，通常是一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt; 的伪目标文件。&lt;/p&gt;

&lt;p&gt;但如果修改文件后，其 mtime 未发生变化，此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 就检测不到。在还原一个旧版本的源文件时很有可能会发生这样的情况，或者源文件在 NFS 上，其时钟或时区没有与运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 的主机同步，也会发生。面对这种情况，必须强制进行一次彻底的重新构建。&lt;/p&gt;

&lt;p&gt;相反地，如果文件的时间为未来时间，会造成不必要的重新构建。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 主要用于自动判断一个大组程序中哪一块需要重新编译，仅针对这一小部分执行命令来编译。只要编译器可以用命令来执行的，都可以用该命令。而且 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 不限于程序代码，可以用它来描述任何任务，只要是需要自动判断部分文件更新的情况就可以。&lt;/p&gt;

&lt;p&gt;以 Tarball 方式发布的软件，通常使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令进行编译。&lt;/p&gt;

&lt;h3 id=&quot;1621-makefile&quot;&gt;16.2.1 makefile&lt;/h3&gt;

&lt;p&gt;makefile 是用于自动编译和链接的，可以看成是一个 &lt;strong&gt;配置文件&lt;/strong&gt;，专门给 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令使用。&lt;/p&gt;

&lt;p&gt;一个工程有很多文件组成，每一个文件的改变都会导致工程的重新链接，但不是所有的文件都需要重新编译，makefile 中记录着文件的信息，在 make 时会决定在链接的时候需要重新编译哪些文件。&lt;/p&gt;

&lt;p&gt;makefile 的宗旨就是：让编译器知道要编译一个文件需要依赖其他的哪些文件。当那些依赖文件有了改变，编译器会自动的发现最终的生成文件已经过时，而重新编译相应的模块。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 必须配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 一起使用，它会在当前目录搜索 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;，然后根据文件的设定运行特定目标。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中，可以调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 等工具，把源代码转换成可执行文件。&lt;/p&gt;

&lt;h4 id=&quot;规则&quot;&gt;规则&lt;/h4&gt;

&lt;p&gt;程序构建的规则都写在 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中。每条规则的形式如下：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;&amp;lt;target&amp;gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;&amp;lt;prerequisites&amp;gt;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;[tab]&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;&amp;lt;commands&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;  &lt;strong&gt;目标&lt;/strong&gt;，必需，不可省略&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prerequisites&lt;/code&gt;  &lt;strong&gt;前置条件&lt;/strong&gt;，可选&lt;/p&gt;

&lt;p&gt;第二行必须由 tab 开头，后面跟着 &lt;strong&gt;命令&lt;/strong&gt;，可选。&lt;/p&gt;

&lt;p&gt;前置条件和命令至少要有一个。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;每条规则是为了明确：构建目标的 &lt;strong&gt;前置条件&lt;/strong&gt; 是什么，&lt;strong&gt;如何构建&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;目标&quot;&gt;目标&lt;/h5&gt;

&lt;p&gt;一个目标（target）就构成一条规则。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标通常是 &lt;strong&gt;文件名&lt;/strong&gt;，指明 make 命令所要构建的对象，可以是 &lt;strong&gt;一个&lt;/strong&gt; 文件名，也可以是 &lt;strong&gt;多个&lt;/strong&gt; 文件名，之间用 &lt;strong&gt;空格&lt;/strong&gt; 分隔。&lt;/li&gt;
  &lt;li&gt;目标还可以是某个 &lt;strong&gt;操作&lt;/strong&gt; 的名字，这称为 “&lt;strong&gt;伪目标&lt;/strong&gt;”（phony target）。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的目标是 clean，它不是文件名，而是一个操作的名字，属于 “伪目标”，作用是删除对象文件。&lt;/p&gt;

&lt;p&gt;以目标为参数运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，如果当前目录中，正好有一个文件叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;clean&lt;/code&gt;，那么这个命令不会执行。因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;clean&lt;/code&gt; 文件已经存在，会认为没有必要重新构建了，就不会执行指定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;为了避免这种情况，可以使用内置目标 &lt;code class=&quot;highlighter-rouge&quot;&gt;.PHONY&lt;/code&gt; 来显示声明 clean 是 “伪目标”，写法如下：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;temp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;声明 clean 是 “伪目标” 之后，make 就不会去检查是否存在一个叫做 clean 的文件，而是每次运行都执行对应的命令。像 &lt;code class=&quot;highlighter-rouge&quot;&gt;.PHONY&lt;/code&gt; 这样的 &lt;strong&gt;内置目标名&lt;/strong&gt; 还有不少，可以查看&lt;a href=&quot;http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets&quot;&gt;手册&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果 make 命令运行时没有指定目标，默认会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 文件的第一个目标。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 文件的第一个目标。&lt;/p&gt;

&lt;h5 id=&quot;前置条件&quot;&gt;前置条件&lt;/h5&gt;

&lt;p&gt;前置条件通常是 &lt;strong&gt;一组文件名&lt;/strong&gt;，之间用 &lt;strong&gt;空格&lt;/strong&gt; 分隔。它指定了 “目标” 是否重新构建的 &lt;strong&gt;判断标准&lt;/strong&gt;：只要有一个前置文件不存在，或前置文件的 mtime 比目标的新，目标就需要重新构建。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;result.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;source.txt&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;source.txt&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;result.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，构建 &lt;code class=&quot;highlighter-rouge&quot;&gt;result.txt&lt;/code&gt; 的前置条件是 &lt;code class=&quot;highlighter-rouge&quot;&gt;source.txt&lt;/code&gt; 。如果当前目录中，&lt;code class=&quot;highlighter-rouge&quot;&gt;source.txt&lt;/code&gt; 已经存在，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;make result.txt&lt;/code&gt; 可以正常运行，否则必须再写一条规则，来生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;source.txt&lt;/code&gt; 。将以下代码加在上面代码之后：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;source.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this is the source&quot;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;source.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，source.txt 后面 &lt;strong&gt;没有前置条件&lt;/strong&gt;，就意味着它 &lt;strong&gt;跟其他文件都无关&lt;/strong&gt;，只要这个文件还不存在，每次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make source.txt&lt;/code&gt;，它都会生成。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make result.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make result.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面命令连续执行两次 &lt;code class=&quot;highlighter-rouge&quot;&gt;make result.txt&lt;/code&gt;。第一次执行会先新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;source.txt&lt;/code&gt;，然后再新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;result.txt&lt;/code&gt;。第二次执行，Make 发现 source.txt 没有变动，就不会执行任何操作，result.txt 也不会重新生成。&lt;/p&gt;

&lt;p&gt;如果需要生成多个文件，往往采用下面的写法。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;file1 file2 file3&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;file1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this is the file1&quot;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;file1&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;file2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this is the file2&quot;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;file2&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;file3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this is the file3&quot;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;file3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make source&lt;/code&gt; 命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。&lt;/p&gt;

&lt;h5 id=&quot;命令&quot;&gt;命令&lt;/h5&gt;

&lt;p&gt;命令（commands）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建目标的具体指令，它的运行结果通常就是生成目标文件。&lt;/p&gt;

&lt;p&gt;每行命令之前 &lt;strong&gt;必须&lt;/strong&gt; 有一个 &lt;strong&gt;tab&lt;/strong&gt; 键。如果想用其他键，可以用内置变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;.RECIPEPREFIX&lt;/code&gt; 声明。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;.RECIPEPREFIX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Hello,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;world&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码用 &lt;code class=&quot;highlighter-rouge&quot;&gt;.RECIPEPREFIX&lt;/code&gt; 指定，大于号（&amp;gt;）替代 tab 键。所以，每一行命令的起首变成了大于号，而不是 tab 键。&lt;/p&gt;

&lt;p&gt;需要注意的是，每行命令在一个 &lt;strong&gt;单独的 shell&lt;/strong&gt; 中执行，属于不同的进程。这些 Shell 之间 &lt;strong&gt;没有继承关系&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;var-lost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;bar
    &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;foo=[$$foo]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码执行后 &lt;code class=&quot;highlighter-rouge&quot;&gt;make var-lost&lt;/code&gt;，取不到 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; 的值。&lt;/p&gt;

&lt;p&gt;一个解决办法是将两行命令写在一行，中间用 &lt;strong&gt;分号&lt;/strong&gt; 分隔：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;var-kept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;bar&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;foo=[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$$&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;foo]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另一个解决办法是在换行符前加反斜杠 &lt;strong&gt;转义&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;var-kept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;bar&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;foo=[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$$&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;foo]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一个方法是使用内置目标 &lt;code class=&quot;highlighter-rouge&quot;&gt;.ONESHELL:&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.ONESHELL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;var-kept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;bar&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;foo=[$$foo]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;makefile-文件的语法&quot;&gt;makefile 文件的语法&lt;/h4&gt;

&lt;h5 id=&quot;注释&quot;&gt;注释&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 在 makefile 中表示注释，用法与 bash 中的注释一样。&lt;/p&gt;

&lt;h5 id=&quot;回显&quot;&gt;回显&lt;/h5&gt;

&lt;p&gt;echoing&lt;/p&gt;

&lt;p&gt;正常情况下，make 会回显每条命令及注释，然后再执行，如果在命令前加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;，就可以关闭该条命令的回显。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# comment&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;TODO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于在构建过程中，需要了解当前在执行哪条命令，所以通常只会关闭注释和 echo 的回显。&lt;/p&gt;

&lt;h5 id=&quot;通配符&quot;&gt;通配符&lt;/h5&gt;

&lt;p&gt;通配符用来指定一组符合条件的文件名。makefile 的通配符与 Bash 一致，主要有 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;？&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;[...]&lt;/code&gt; 。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;模式匹配&quot;&gt;模式匹配&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令允许对文件名，进行类似正则运算的匹配，使用匹配符 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;，可以将大量同类型的文件，只用一条规则就完成构建。&lt;/p&gt;

&lt;p&gt;比如，假定当前目录下有 &lt;code class=&quot;highlighter-rouge&quot;&gt;f1.c&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;f2.c&lt;/code&gt; 两个源码文件，需要将它们编译为对应的对象文件。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;%.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;f1.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f1.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;f2.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f2.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;变量和赋值符&quot;&gt;变量和赋值符&lt;/h5&gt;

&lt;p&gt;makefile 允许使用等号 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;&lt;/strong&gt; 为变量赋值。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;txt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Hello World
&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;@echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(txt)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。&lt;/p&gt;

&lt;p&gt;调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 make 命令会对美元符号转义。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;@echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$$HOME&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有时，变量的值可以是另一个变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v1 = $(v2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（&lt;strong&gt;静态扩展&lt;/strong&gt;），还是在运行时扩展（&lt;strong&gt;动态扩展&lt;/strong&gt;）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。&lt;/p&gt;

&lt;p&gt;为了解决类似问题，Makefile一共提供了四个 &lt;strong&gt;赋值运算符&lt;/strong&gt; ：&lt;/p&gt;

&lt;h6&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE = value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;strong&gt;执行时扩展&lt;/strong&gt;，允许递归扩展。&lt;/p&gt;

&lt;h6 id=&quot;-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE := value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;strong&gt;定义时扩展&lt;/strong&gt;。&lt;/p&gt;

&lt;h6 id=&quot;-2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?=&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE ?= value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;只有在该变量 &lt;strong&gt;为空时才赋值&lt;/strong&gt;。&lt;/p&gt;

&lt;h6 id=&quot;-3&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+=&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE += value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将值 &lt;strong&gt;追加&lt;/strong&gt; 到变量的尾端。&lt;/p&gt;

&lt;h5 id=&quot;内建变量&quot;&gt;内建变量&lt;/h5&gt;

&lt;p&gt;Implicit Variables&lt;/p&gt;

&lt;p&gt;make 命令提供一系列内建变量，比如，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(CC)&lt;/code&gt; 指向当前使用的编译器，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(MAKE)&lt;/code&gt; 指向当前使用的 make 工具。这主要是为了跨平台的兼容性。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;input.c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;自动变量&quot;&gt;自动变量&lt;/h5&gt;

&lt;p&gt;Automatic Variables&lt;/p&gt;

&lt;p&gt;make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。&lt;/p&gt;

&lt;h6 id=&quot;-4&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 指代 &lt;strong&gt;当前目标&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;a.txt b.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;a.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;a.txt&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;b.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;-5&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt; 指代 &lt;strong&gt;第一个前置条件&lt;/strong&gt;。比如，规则为 &lt;code class=&quot;highlighter-rouge&quot;&gt;t: p1 p2&lt;/code&gt;，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt; 就指代 p1。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;a.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b.txt c.txt&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;a.txt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b.txt c.txt&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;b.txt&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;a.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;-6&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt; 指代 &lt;strong&gt;比目标更新的所有前置条件&lt;/strong&gt;，之间以空格分隔。比如，规则为 &lt;code class=&quot;highlighter-rouge&quot;&gt;t: p1 p2&lt;/code&gt;，其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;p2&lt;/code&gt; 的时间戳比 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 新，&lt;code class=&quot;highlighter-rouge&quot;&gt;$?&lt;/code&gt; 就指代 &lt;code class=&quot;highlighter-rouge&quot;&gt;p2&lt;/code&gt;。&lt;/p&gt;

&lt;h6 id=&quot;-7&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt; 指代 &lt;strong&gt;所有前置条件&lt;/strong&gt;，之间以空格分隔。比如，规则为 &lt;code class=&quot;highlighter-rouge&quot;&gt;t: p1 p2&lt;/code&gt;，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;$^&lt;/code&gt; 就指代 &lt;code class=&quot;highlighter-rouge&quot;&gt;p1 p2&lt;/code&gt; 。&lt;/p&gt;

&lt;h6 id=&quot;-8&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 指代匹配符 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; &lt;strong&gt;匹配的部分&lt;/strong&gt;， 比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; 匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;f1.txt&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;f1&lt;/code&gt; ，&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 就表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;f1&lt;/code&gt;。&lt;/p&gt;

&lt;h6 id=&quot;d--f&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@D)&lt;/code&gt; ， &lt;code class=&quot;highlighter-rouge&quot;&gt;$(@F)&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@D)&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(@F)&lt;/code&gt; 分别指向 &lt;strong&gt;当前目标&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 的 &lt;strong&gt;目录名&lt;/strong&gt; 和 &lt;strong&gt;文件名&lt;/strong&gt;。比如，&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;src/input.c&lt;/code&gt;，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(@D)&lt;/code&gt; 的值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; ，&lt;code class=&quot;highlighter-rouge&quot;&gt;$(@F)&lt;/code&gt; 的值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;input.c&lt;/code&gt;。&lt;/p&gt;

&lt;h6 id=&quot;d--f-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;D)&lt;/code&gt; ， &lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;F)&lt;/code&gt;&lt;/h6&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;D)&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(&amp;lt;F)&lt;/code&gt; 分别指向 &lt;strong&gt;第一个前置条件&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt; 的 &lt;strong&gt;目录名&lt;/strong&gt; 和 &lt;strong&gt;文件名&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;判断和循环&quot;&gt;判断和循环&lt;/h5&gt;

&lt;p&gt;makefile 使用 Bash 语法完成判断和循环。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(CC),gcc)&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;libs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(libs_for_gcc)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;libs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(normal_libs)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;LIST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; one two three
&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(LIST);&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$$i;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行结果为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;one
two
three
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;函数&quot;&gt;函数&lt;/h5&gt;

&lt;p&gt;makefile 还可以使用函数，格式如下。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(function arguments)&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;${function arguments}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;makefile 提供了许多内置函数，可供调用。下面是几个常用的内置函数。&lt;/p&gt;

&lt;h6 id=&quot;shell-函数&quot;&gt;shell 函数&lt;/h6&gt;

&lt;p&gt;shell 函数用来 &lt;strong&gt;执行 shell 命令&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;srcfiles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;src/&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;00..99&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;.txt&lt;span class=&quot;nv&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;wildcard-函数&quot;&gt;wildcard 函数&lt;/h6&gt;

&lt;p&gt;wildcard 函数用来 &lt;strong&gt;替换 Bash 的通配符&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;srcfiles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wildcard src/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.txt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;subst-函数&quot;&gt;subst 函数&lt;/h6&gt;

&lt;p&gt;subst 函数用来 &lt;strong&gt;文本替换&lt;/strong&gt;，格式如下：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$(subst&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;from,to,text)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的例子将字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;feet on the street&lt;/code&gt; 替换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;fEEt on the strEEt&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$(subst&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ee,EE,feet&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;street)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是一个稍微复杂的例子：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;comma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ,
&lt;span class=&quot;nv&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# space 变量用两个空变量作为标识符，用空格分隔
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;space&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(empty)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(empty)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; a b c
&lt;span class=&quot;nv&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;subst &lt;span class=&quot;nv&quot;&gt;$(space)&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$(comma)&lt;/span&gt;,&lt;span class=&quot;nv&quot;&gt;$(foo)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# bar is now `a,b,c'.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;patsubst-函数&quot;&gt;patsubst 函数&lt;/h6&gt;

&lt;p&gt;patsubst 函数用于 &lt;strong&gt;模式匹配的替换&lt;/strong&gt;，格式如下：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$(patsubst&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;pattern,replacement,text)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的例子将文件名 &lt;code class=&quot;highlighter-rouge&quot;&gt;x.c.c bar.c&lt;/code&gt;，替换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;x.c.o bar.o&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$(patsubst&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%.c,%.o,x.c.c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bar.c)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;替换后缀名&quot;&gt;替换后缀名&lt;/h6&gt;

&lt;p&gt;替换后缀名函数的写法是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;变量名 + 冒号 + 后缀名替换规则&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;它实际上是 &lt;code class=&quot;highlighter-rouge&quot;&gt;patsubst&lt;/code&gt; 函数的一种简写形式。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(OUTPUT:.js=.min.js)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的意思是，将变量 OUTPUT 中的后缀名 &lt;code class=&quot;highlighter-rouge&quot;&gt;.js&lt;/code&gt; 全部替换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;.min.js&lt;/code&gt; 。&lt;/p&gt;

&lt;h4 id=&quot;makefile-范例&quot;&gt;makefile 范例&lt;/h4&gt;

&lt;h5 id=&quot;执行多个目标&quot;&gt;执行多个目标&lt;/h5&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cleanall cleanobj cleandiff&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;cleanall &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cleanobj cleandiff&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;program&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;cleanobj &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;cleandiff &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.diff&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;编译-c-语言项目&quot;&gt;编译 C 语言项目&lt;/h5&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;edit &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.o kbd.o command.o display.o&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;main.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main.c defs.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;kbd.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kbd.c defs.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;command.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;command.c defs.h command.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.c&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;display.o &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;display.c defs.h&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.c&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;clean &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;err&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;edit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;main.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;kbd.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;command.o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;display.o&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;edit clean&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另一个：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;TARGET&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; prog
&lt;span class=&quot;nv&quot;&gt;LIBS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-lm&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;CC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; gcc
&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;default all clean&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(TARGET)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;default&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;OBJECTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;patsubst %.c, %.o, &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wildcard &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.c&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;HEADERS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wildcard &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.h&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;%.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.c $(HEADERS)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PRECIOUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(TARGET) $(OBJECTS)&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;$(TARGET)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(OBJECTS)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$(CC)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(OBJECTS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(LIBS)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;-rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*.o&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;-rm&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(TARGET)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;注：最后两行的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-rm&lt;/code&gt; 中的减号 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 表示如果该命令返回错误，不要停止，继续运行下一条命令。如果不加该修饰符，make 遇到错误会中止运行。&lt;/p&gt;

&lt;h3 id=&quot;1622-configure&quot;&gt;16.2.2 configure&lt;/h3&gt;

&lt;p&gt;上面提到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 这么有用，每次都要手动编写吗？不用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 是指一个 &lt;strong&gt;可执行脚本&lt;/strong&gt;，它是专门为了帮助程序开发而设计的，在编译之前，它会检查编译环境，判断哪些库是可以用的。作为惯例，所有的这种脚本都命名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt;，通常是为 Bourne Shell 编写的，基本上可以在任何 shell 中执行。&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 用于 &lt;strong&gt;生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;&lt;/strong&gt;，以便使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 来实现自动化构建程序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 脚本有成千上万条代码，也无需手动编写，它是由名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;autotools&lt;/code&gt; 的一系列程序产生的，其中包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;autoconf&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;automake&lt;/code&gt; 及其它程序，它们为软件的维护带来很大的便利，最终的使用用户基本上看不到这些工具，但这些工具却最终帮助他们在不同发行版上可以顺利地安装软件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 脚本会 &lt;strong&gt;检查&lt;/strong&gt; 当前系统，使用它收集到的信息把 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile.in&lt;/code&gt; &lt;strong&gt;模板&lt;/strong&gt; 文件 &lt;strong&gt;转换&lt;/strong&gt; 成一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 所检查的内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译器&lt;/li&gt;
  &lt;li&gt;函数库或其他信赖&lt;/li&gt;
  &lt;li&gt;操作系统，Linux 内核版本&lt;/li&gt;
  &lt;li&gt;内核的表头定义文件（header include）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1623-使用-make&quot;&gt;16.2.3 使用 make&lt;/h3&gt;

&lt;p&gt;只有简单的软件才会使用一个比较通用的、简单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;，更加复杂的安装需要根据库、头文件及其它资源的位置来裁剪 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;make-如何解析参数&quot;&gt;make 如何解析参数&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make shit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 首先会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中查找名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit&lt;/code&gt; 的 &lt;strong&gt;目标&lt;/strong&gt; 及其规则，如果没找到，它会在其内置规则中查找，其中有一条内置规则会告诉 make，如果在当前目录发现了名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit&lt;/code&gt;、&lt;strong&gt;扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt; 的文件&lt;/strong&gt;，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.o&lt;/code&gt;，可以运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt; 等链接器，用其构建可执行文件。&lt;/p&gt;

&lt;p&gt;如果找到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.o&lt;/code&gt;，make 还要确认它是否是最新的，即其 mtime 是否比源文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.c&lt;/code&gt; 新。&lt;/p&gt;

&lt;p&gt;如果 make 也发现了源文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.c&lt;/code&gt;，它会检查其时间戳，以确保 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.o&lt;/code&gt; 比较新一些。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.o&lt;/code&gt; 不存在，或比 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.c&lt;/code&gt; 要旧，make 会使用另一个内置的规则，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 等工具把 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.c&lt;/code&gt; 编译成一个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shit.o&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;于是 make 运行的结果，就是保证构建可执行文件，并是最新版的。&lt;/p&gt;

&lt;h4 id=&quot;make-常用参数&quot;&gt;make 常用参数&lt;/h4&gt;

&lt;p&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 时如果不使用任何参数，通常会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中第一个目标。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 还可以完成许多其他任务：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt;  把文件安装到正确的路径，此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中的一个目标。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt;  删除无用的目标文件，同样 &lt;code class=&quot;highlighter-rouge&quot;&gt;clean&lt;/code&gt; 也是一个目标&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make -n&lt;/code&gt;  预览构建过程，会把所有将要运行的命令全部打印出来&lt;/p&gt;

&lt;h2 id=&quot;163-tarball-程序的构建与安装流程&quot;&gt;16.3 Tarball 程序的构建与安装流程&lt;/h2&gt;

&lt;p&gt;以上所有文字都是为了帮助理解程序构建的过程，但实际工作中空间要如何一步步地操作呢？&lt;/p&gt;

&lt;p&gt;许多软件包是以源代码压缩包的形式传递的，同一个软件包在生成程序以后，可以运行于多种不同的主机上，节省了作者的精力，不用花时间去对不同的系统做不同的版本。只不过这个任务落在了你我的身上。&lt;/p&gt;

&lt;h3 id=&quot;1631-tarball&quot;&gt;16.3.1 Tarball&lt;/h3&gt;

&lt;p&gt;Tar 是压缩打包工具，可以将多个文件合并为一个文件，打包后的后缀为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar&lt;/code&gt;。已压缩的 tar 文件也叫 “&lt;strong&gt;Tarball&lt;/strong&gt;”。大部分开源软件的源代码采用 tarball 的形式发布。被压缩的 tar 文件则追加压缩文件的扩展名，如经过 gzip 压缩后的 tar 文件，扩展名为 “.tar.gz”，其它的如 &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar.bz2&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt; .tar.xz&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;开源软件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Tarball&lt;/code&gt; 中通常有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;源代码文件&lt;/li&gt;
  &lt;li&gt;检测程序文件（configure 脚本）&lt;/li&gt;
  &lt;li&gt;简介与安装说明（INSTALL 或README）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以 Tarball 方式发布的软件，通常使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 命令进行编译。&lt;/p&gt;

&lt;h3 id=&quot;1632-经典的安装三步曲&quot;&gt;16.3.2 经典的安装三步曲&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多数人习惯性地用了多年，也不明白这三步曲的意义所在，现在我们都懂了：&lt;/p&gt;

&lt;p&gt;首先，如果 Tarball 中提供了帮助文档 README 或 INSTALL，可以先阅读一下。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;  是为了生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;如果帮助文档中有说明，此时可能需要运行一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt; 来删除现有的目标文件，以便下一步生成新的目标文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;  不带参数地执行 make，默认会执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中的第一个目标，通常会进行一系列的编译、链接的操作，生成可执行文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt;  install 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 中的一个目标。编译生成的可执行文件和相关配置文件与源代码在同一目录，install 目标的命令会把这些文件安装（移动）到正确的目录。&lt;/p&gt;

&lt;h3 id=&quot;1633-安装路径&quot;&gt;16.3.3 安装路径&lt;/h3&gt;

&lt;p&gt;发行版安装的软件大多在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/&lt;/code&gt; 目录中，用户自行安装的软件建议位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;以软件名 ABC 为例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;总目录：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;源代码：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/src/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;配置文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/etc/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可执行文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/bin/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;函数库：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/lib/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;说明文档：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/man/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;man&lt;/code&gt; 程序会检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/&lt;/code&gt; 中的说明文档。&lt;/p&gt;

&lt;p&gt;需要把 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ABC/man&lt;/code&gt; 加入 man page 的查找路径中。&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/man_db.conf&lt;/code&gt; 中约 40~50 行处，插入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MANPATH_MAP /usr/local/software/bin /usr/local/software/man
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1624-更新源代码&quot;&gt;16.2.4 更新源代码&lt;/h3&gt;

&lt;p&gt;很多软件开发商在更新了源代码之后，会发布更新文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;patch -pN &amp;lt; patch_file&lt;/code&gt;&lt;/p&gt;</content><author><name></name></author><category term="构建" /><category term="编译" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 15. 日志</title><link href="/linux/linux.log/" rel="alternate" type="text/html" title="Linux 基础 - 15. 日志" /><published>2015-01-15T00:00:00+08:00</published><updated>2015-01-15T00:00:00+08:00</updated><id>/linux/linux.log</id><content type="html" xml:base="/linux/linux.log/">&lt;h2 id=&quot;151-syslog&quot;&gt;15.1 SYSLOG&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/syslog_daemon.gif&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;syslog 是计算机系统中 &lt;strong&gt;消息日志的标准&lt;/strong&gt;，通过该标准，允许把生成日志的软件、保存日志的系统、报告及分析日志的软件分离开来。每条消息都打上标签，以表明生成日志的软件类别及严重级别。&lt;/p&gt;

&lt;p&gt;syslog 可用于系统管理及安全审计，也可用于生成、分析、调试信息。多种硬件平台都使用该标准，如打印机、路由器等。于是，在一个中央信息库中，完全可以把来自不同系统的日志数据合并到一起。&lt;/p&gt;

&lt;p&gt;syslog 存在于多种操作系统中，并且成为类 Unix 系统中日志系统的标准配置，同时也普遍存在于网络设备中，如路由器。&lt;/p&gt;

&lt;p&gt;系统日志消息的发起者提供的信息包括 &lt;strong&gt;设施代码&lt;/strong&gt; 和 &lt;strong&gt;严重性级别&lt;/strong&gt;。在将条目传递给 syslog 接收器之前，syslog 软件将信息添加到信息头中，包括发起者进程 ID，时间戳以及设备的主机名或 IP 地址。&lt;/p&gt;

&lt;p&gt;syslog 是 UNIX 的标准日志解决方案。&lt;code class=&quot;highlighter-rouge&quot;&gt;syslog&lt;/code&gt; 这个术语可以表示 syslog 这个协议，也可以表示一个 C API，不过更普遍的还是表示二者的实施。&lt;/p&gt;

&lt;h3 id=&quot;1511-logger&quot;&gt;15.1.1 Logger&lt;/h3&gt;

&lt;p&gt;日志消息可以被定向到各种目标，如控制台、文件、远程 syslog 服务器、中继器等。&lt;/p&gt;

&lt;p&gt;大多数 syslog 实施方案都提供一个命令行工具，称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;logger&lt;/code&gt;，也会提供一个链接库，用于把消息发送给日志，一些实施方案会包含报告程序，可以用于过虑消息，以及消息的显示。&lt;/p&gt;

&lt;h3 id=&quot;1512-网络协议&quot;&gt;15.1.2 网络协议&lt;/h3&gt;

&lt;p&gt;在网络上操作时，syslog 实施方案可以 client-server 方式部署，服务器在预定的端口上侦听来自客户端的协议请求。用于网络日志的应用最广泛的传输层协议为 UDP，其服务器侦听的端口为 514。&lt;/p&gt;

&lt;h2 id=&quot;152-rsyslog&quot;&gt;15.2 RSYSLOG&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog&lt;/code&gt; 是一个开源的 &lt;strong&gt;软件&lt;/strong&gt;，用于在 IP 网络中转发日志消息。在部署基础 syslog 协议的同时，rsyslog 将其扩展，使用基于内容的过滤，&lt;strong&gt;丰富的过滤功能，灵活的配置方式&lt;/strong&gt;，并增加了诸如使用 &lt;strong&gt;TCP 来传输&lt;/strong&gt; 的功能。&lt;/p&gt;

&lt;p&gt;RSYSLOG 的官网将其定义为 “the &lt;strong&gt;r&lt;/strong&gt;ocket-fast &lt;strong&gt;sys&lt;/strong&gt;tem for &lt;strong&gt;log&lt;/strong&gt; processing”&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog&lt;/code&gt; 系统仅能记录较为简单的事件格式，并非所有应用程序都会使用 syslog 记录。&lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog&lt;/code&gt; 是负责收集 syslog 的程序，可以用来取代 syslogd 或 syslog-ng。&lt;/p&gt;

&lt;p&gt;以前用 &lt;code class=&quot;highlighter-rouge&quot;&gt;syslogd&lt;/code&gt;，从 CentOS 6 开始，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslogd&lt;/code&gt; 来管理日志。&lt;/p&gt;

&lt;h3 id=&quot;1521-配置文件&quot;&gt;15.2.1 配置文件&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其配置文件会指定 rsyslog 需要记录 &lt;strong&gt;哪些服务&lt;/strong&gt;、&lt;strong&gt;什么等级&lt;/strong&gt; 以及 &lt;strong&gt;需要记录在什么设备或文件&lt;/strong&gt; 的信息。&lt;/p&gt;

&lt;p&gt;配置文件中的每条规则由两个字段组成：&lt;strong&gt;选择字段，行为字段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;服务名称[.=!]信息等级        信息记录的文件名或设备或主机&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mail.info            /var/log/maillog_info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解释：mail 服务产生的 info 等级以上的信息，都记录到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/maillog_info&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;p&gt;每种服务产生的数据量差异很大，可以在配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.conf&lt;/code&gt; 中为每种服务指定各自的日志保存位置，以便 &lt;strong&gt;将不同服务的日志，保存在各自的日志文件中&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;选择字段&quot;&gt;选择字段&lt;/h4&gt;

&lt;p&gt;选择字段由两部分组成：服务类别（facility）、优先级（priority），均为大小写敏感。&lt;/p&gt;

&lt;p&gt;虽然二者均可用数字表示，但通常使用名字来表示，更容易理解和使用。&lt;/p&gt;

&lt;h5 id=&quot;服务类别&quot;&gt;服务类别&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog&lt;/code&gt; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;facility&lt;/code&gt; 来指定生成消息的子系统。&lt;/p&gt;

&lt;p&gt;多数情况下，任何人可以保存任何类别的日志，但只有内核才可以保存内核类别的日志。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;相对序号&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;服务类别&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kern&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;内核&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;user&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户级&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mail&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;邮件系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;daemon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统守护进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;auth&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;安全、认证&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;syslog&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;syslogd 内部产生的消息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;lpr&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;打印服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;news&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;新闻组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uucp&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Unix to Unix Copy Protocol，unix 主机间的程序数据交换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;cron&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;计划任务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;authpriv&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ssh，ftp 等登录信息的验证信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ftp&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FTP 服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16~23&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;local0 ~ local7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用户自定义&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;可以用星号 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/strong&gt; 表示所有类别的服务&lt;/li&gt;
  &lt;li&gt;一条规则中，针对一个优先级，可以同时指定多个服务类别，用逗号 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;&lt;/strong&gt; 分隔&lt;/li&gt;
  &lt;li&gt;针对一个行为，可以指定多个选择字段，中间用分号 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;&lt;/strong&gt; 分隔。这些选择字段从左至右依次处理，每个字段都可以覆盖前面的字段。用这种方法可以排除一些优先级。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;优先级&quot;&gt;优先级&lt;/h5&gt;

&lt;p&gt;决定日志信息的重要性。同一个服务所产生的信息，按照重要性分为八个等级：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;等级&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;名称&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;none&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;什么都不记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;debug&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;info&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一般&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;notice&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;需要注意&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;warning&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;警告&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;err&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;crit&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;危急&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;alert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;严重警告，需立即采取行动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;emerg&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;紧急，系统不可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以用星号 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 表示所有优先级。用 &lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt; 表示无优先级。&lt;/p&gt;

&lt;h5 id=&quot;条件语句&quot;&gt;条件语句&lt;/h5&gt;

&lt;p&gt;选择字段中，服务类别与优先级用句点 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;/strong&gt; 连接起来，形成一个日志生成的条件语句。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;/strong&gt; xxx：&lt;strong&gt;小于等于&lt;/strong&gt; xxx 级别的日志信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.=&lt;/code&gt;&lt;/strong&gt; xxx：&lt;strong&gt;等于&lt;/strong&gt; xxx 级别的日志信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.!&lt;/code&gt;&lt;/strong&gt; xxx：&lt;strong&gt;大于等于&lt;/strong&gt; xxx 的等级的日志信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.!=&lt;/code&gt;&lt;/strong&gt; xxx：&lt;strong&gt;非&lt;/strong&gt; xxx 的等级的日志信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.*&lt;/code&gt;&lt;/strong&gt; ：&lt;strong&gt;所有&lt;/strong&gt; 等级的日志信息&lt;/p&gt;

&lt;h4 id=&quot;行为字段&quot;&gt;行为字段&lt;/h4&gt;

&lt;p&gt;行为字段用于描述日志文件，这里，日志文件是一个 &lt;strong&gt;抽象的概念&lt;/strong&gt;。它不一定非要是个真实的文件。&lt;/p&gt;

&lt;h5 id=&quot;普通文件&quot;&gt;普通文件&lt;/h5&gt;

&lt;p&gt;日志消息通常是保存到实体文件中的，需用绝对路径表示。&lt;/p&gt;

&lt;p&gt;如 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.info;mail.none;authpriv.none;cron.none  /var/log/messages&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;命名的管道&quot;&gt;命名的管道&lt;/h5&gt;

&lt;p&gt;命名的管道，即 FIFO 文件。文件名前必须加上 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/strong&gt; 前缀。而且该 FIFO 文件必须在 &lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslogd&lt;/code&gt; 启动之前使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mkfifo&lt;/code&gt; 命令提前创建好。&lt;/p&gt;

&lt;h5 id=&quot;终端或控制台&quot;&gt;终端或控制台&lt;/h5&gt;

&lt;p&gt;可以把日志文件指定为一个 tty 终端。&lt;/p&gt;

&lt;h5 id=&quot;远程主机&quot;&gt;远程主机&lt;/h5&gt;

&lt;p&gt;syslogd 支持 &lt;strong&gt;远程日志&lt;/strong&gt;。可以向远程主机 &lt;strong&gt;发送&lt;/strong&gt; 消息，也可以从其 &lt;strong&gt;接收&lt;/strong&gt;，远程主机不会继续转发消息，而会将其保存在本地日志。&lt;/p&gt;

&lt;p&gt;如果需要将日志继续转发给其它主机，可以指定日志文件为一个主机名，主机名前面要加上 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;&lt;/strong&gt; 前缀。&lt;/p&gt;

&lt;p&gt;如果多个主机可以远程保存日志到当前主机，利用这个功能，可以在一个 &lt;strong&gt;中央主机&lt;/strong&gt; 上收集所有的 syslog 消息。&lt;/p&gt;

&lt;p&gt;来自远程主机的消息可以被发送给一个日志程序，通过逐行读取日志消息，该程序有能力在中央日志主机中根据主机名或程序名来整理日志。借此能力，完全可以把日志分割到多个单独的文件中去。&lt;/p&gt;

&lt;h5 id=&quot;用户列表&quot;&gt;用户列表&lt;/h5&gt;

&lt;p&gt;重要的消息通常也会给当前主机的 root 转发一份，可以指定一个需要在终端收到日志消息的用户列表。&lt;/p&gt;

&lt;p&gt;多个用户可以用 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;&lt;/strong&gt; 分隔。&lt;/p&gt;

&lt;p&gt;用户登陆后，就会在终端收到日志信息。如 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.alert root,joey&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;所有登陆者&quot;&gt;所有登陆者&lt;/h5&gt;

&lt;p&gt;紧急事件消息需要发给所有在线的人，使用星号 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/strong&gt; 表示。&lt;/p&gt;

&lt;h3 id=&quot;1522-配置文件范例&quot;&gt;15.2.2 配置文件范例&lt;/h3&gt;

&lt;h4 id=&quot;普通日志&quot;&gt;普通日志&lt;/h4&gt;

&lt;p&gt;将 mail 日志写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/maillog&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mail.info　　　/var/log/maillog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;任何严重等级小于等于 info 的信息，都会被写入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/maillog&lt;/code&gt; 。&lt;/p&gt;

&lt;h4 id=&quot;同一程序不同级别消息分开保存&quot;&gt;同一程序不同级别消息分开保存&lt;/h4&gt;

&lt;p&gt;新闻组及计划任务的日志写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/cronnews&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外还要求，&lt;code class=&quot;highlighter-rouge&quot;&gt;news&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;cron&lt;/code&gt; 的警告信息单独记录到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/cronnews.warn&lt;/code&gt; 中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;news.*;cron.*　　　　　/var/log/cronnews
news.=warn;cron.=warn　/var/log/cronnews.warn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;排除特定程序&quot;&gt;排除特定程序&lt;/h4&gt;

&lt;p&gt;cron，mail，news 的日志不要记录到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*.*;news,cron,mail.none　　　　　　/var/log/messages
*.*;news.none;cron.none;mail.none　/var/log/messages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用逗号 “,” 分隔日志名称时，意味着这些服务要使用同一个优先级，因此只需在最后一个名称后指定等级即可。&lt;/p&gt;

&lt;p&gt;如果用分号 “;” 来分隔，意味着不同服务、不同优先级要使用同一个日志文件，每个服务名称后都要指定各自的等级。&lt;/p&gt;

&lt;h4 id=&quot;rsyslogconf-默认配置分析&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog.conf&lt;/code&gt; 默认配置分析&lt;/h4&gt;

&lt;p&gt;以下为 CetnOS 7 默认配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#kern.*    /dev/console
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只要是核心产生的日志，全部发送到控制台接口（console），即计算机的 &lt;code class=&quot;highlighter-rouge&quot;&gt;RS-232&lt;/code&gt; 串口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*.info;mail.none;authpriv.none;cron.none  /var/log/messages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于 mail, authpriv, cron 产生的日志较多，而且已经单独保存到各自的日志文件，因此在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt; 里面就不再记录。除此之外的其他信息都写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;因此这个文件很重要。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;authpriv.*    /var/log/secure
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;认证相关的日志写入&lt;code class=&quot;highlighter-rouge&quot;&gt; /var/log/secure &lt;/code&gt;文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mail.*    -/var/log/maillog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;邮件服务日志写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/maillog&lt;/code&gt; 文件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/maillog&lt;/code&gt; 前面的减号 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/strong&gt; 的作用：
由于邮件所产生的信息比较多，因此我们希望这些信息暂存在内存中，等数据量足够多时才一次性将其存入磁盘，有助于提升日志文件的存取性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cron.*    /var/log/cron
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;计划任务日志写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/cron&lt;/code&gt; 文件；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*.emerg   :omusrmsg:*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当产生最严重的错误时，将该等级的日志以 wall 的方式广播给所有在线用户，以便在线用户立即通知系统管理员。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uucp,news.crit    /var/log/spooler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;uucp 是早期类 Unix 系统进行数据传递的通讯协议，后来常用在新闻组。当新闻组有严重错误日志时写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/spooler&lt;/code&gt; 文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local7.*   /var/log/boot.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将本机启动时应显示到屏幕的信息写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/boot.log&lt;/code&gt; 文件。&lt;/p&gt;

&lt;h4 id=&quot;自定义日志文件&quot;&gt;自定义日志文件&lt;/h4&gt;

&lt;p&gt;通过单独指定日志文件来另存一个日志文件。&lt;/p&gt;

&lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.conf&lt;/code&gt; 配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*.info  /var/log/admin.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重启 &lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslogd&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# systemctl restart rsyslog.service
~]# ll /var/log/admin.log
-rw-r--r--. 1 root root 325 Aug 20 00:54 /var/log/admin.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1523-日志文件的格式&quot;&gt;15.2.3 日志文件的格式&lt;/h3&gt;

&lt;p&gt;rsyslog 生成的日志其格式为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;日期与时间&lt;/li&gt;
  &lt;li&gt;主机名&lt;/li&gt;
  &lt;li&gt;服务、指令或函数&lt;/li&gt;
  &lt;li&gt;具体信息&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@study ~]# cat /var/log/secure | tail -4
Nov  5 19:33:27 zion sshd[1140]: Server listening on 0.0.0.0 port 22.
Nov  5 19:33:27 zion sshd[1140]: Server listening on :: port 22.
Nov  5 19:34:56 zion sshd[1407]: Accepted password for root from 192.168.1.5 port 5318 ssh2
Nov  5 19:34:57 zion sshd[1407]: pam_unix(sshd:session): session opened for user root by (uid=0)
# 日期	时间	主机名	服务/函数	详细说明
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1524-日志文件的安全性设置&quot;&gt;15.2.4 日志文件的安全性设置&lt;/h3&gt;

&lt;p&gt;基于安全考虑，日志文件应该 &lt;strong&gt;只可追加，不能删除&lt;/strong&gt;。可通过 chattr &lt;strong&gt;修改隐藏属性&lt;/strong&gt; 来实现。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# chattr +a /var/log/admin.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，root 仍然是突破隐藏属性的最后一道关卡。&lt;/p&gt;

&lt;p&gt;另外，使用 logrotate 进行日志文件滚动时，必须修改 logrotate 的配置文件，以确认其有权操作日志文件。&lt;/p&gt;

&lt;h3 id=&quot;1525-logger-命令&quot;&gt;15.2.5 LOGGER 命令&lt;/h3&gt;

&lt;p&gt;logger 是 syslog 提供的一个 shell 命令接口，借此使用 syslog 的系统日志模块。&lt;/p&gt;

&lt;p&gt;可以从命令行直接向系统日志文件 &lt;strong&gt;写入&lt;/strong&gt; 日志条目。&lt;/p&gt;

&lt;p&gt;可以将文件，或者自定义的字符串信息通过 syslog 的方式打印到预设的日志文件中，还可以设置日志级别，打印进程 PID 等。&lt;/p&gt;

&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;logger [-p 服务名称.等级] &quot;信息&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以当前用户身份直接把字符串写入日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# logger -p user.info &quot;I will check logger command&quot;

~]# journalctl SYSLOG_FACILITY=1 -n 3
-- Logs begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 18:03:17 CST. --
Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29710]: starting 0yum-hourly.cron
Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29714]: finished 0yum-hourly.cron
Aug 19 18:03:17 study.centos.vbird dmtsai[29753]: I will check logger command
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;范例&quot;&gt;范例&lt;/h4&gt;

&lt;p&gt;把前面自定义的备份服务脚本更新一下，允许在备份前和备份后在日志加加注释文字。&lt;/p&gt;

&lt;p&gt;运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;/backups/backup.sh log&lt;/code&gt; 命令，手动在日志中增加备份开始和结束的注释，从而可以追溯备份的开始结束时间。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# vim /backups/backup.sh
#!/bin/bash

if [ &quot;${1}&quot; == &quot;log&quot; ]; then
        logger -p syslog.info &quot;backup.sh is starting&quot;
fi
source=&quot;/etc /home /root /var/lib /var/spool/{cron,at,mail}&quot;
target=&quot;/backups/backup-system-$(date +%Y-%m-%d).tar.gz&quot;
[ ! -d /backups ] &amp;amp;&amp;amp; mkdir /backups
tar -zcvf ${target} ${source} &amp;amp;&amp;gt; /backups/backup.log
if [ &quot;${1}&quot; == &quot;log&quot; ]; then
        logger -p syslog.info &quot;backup.sh is finished&quot;
fi

[root@study ~]# /backups/backup.sh log
[root@study ~]# journalctl SYSLOG_FACILITY=5 -n 3
Aug 19 18:09:37 study.centos.vbird dmtsai[29850]: backup.sh is starting
Aug 19 18:09:54 study.centos.vbird dmtsai[29855]: backup.sh is finished
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1526-日志文件服务器&quot;&gt;15.2.6 日志文件服务器&lt;/h3&gt;

&lt;p&gt;rsyslogd 本身具有日志文件服务器的功能，默认没有开启。开启后，该服务的监听端口为 UDP 514 或 TCP 514。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rsyslog.server.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，服务器会启动监听的端口，客户端则将日志文件转存一份，传送到服务器。&lt;/p&gt;

&lt;h4 id=&quot;配置文件&quot;&gt;配置文件&lt;/h4&gt;

&lt;h5 id=&quot;服务端&quot;&gt;服务端&lt;/h5&gt;

&lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.conf&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ModLoad imtcp
$InputTCPServerRun 514
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重启 rsyslog 服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# systemctl restart rsyslog.service
~]# netstat -ltnp | grep syslog
Proto Recv-Q Send-Q Local Address  Foreign Address   State    PID/Program name
tcp        0      0 0.0.0.0:514    0.0.0.0:*         LISTEN   2145/rsyslogd
tcp6       0      0 :::514         :::*              LISTEN   2145/rsyslogd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;客户端&quot;&gt;客户端&lt;/h5&gt;

&lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.conf&lt;/code&gt;，新增一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*.*       @@192.168.1.100
#*.*       @192.168.1.100  # 若用 UDP
~]# systemctl restart rsyslog.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1527-rsyslog-的缺点&quot;&gt;15.2.7 RSYSLOG 的缺点&lt;/h3&gt;

&lt;p&gt;基本上就是 syslog 的缺点。&lt;/p&gt;

&lt;h4 id=&quot;缺乏结构&quot;&gt;缺乏结构&lt;/h4&gt;

&lt;p&gt;rsyslog 会把日志消息写入纯文本文件中。虽然 UNIX 有很多优秀的工具可以处理纯文本文件，但 &lt;strong&gt;结构的缺乏&lt;/strong&gt; 是几乎所有 syslog 问题的根源。&lt;/p&gt;

&lt;h4 id=&quot;查找困难&quot;&gt;查找困难&lt;/h4&gt;

&lt;p&gt;在一个巨大的纯文本文件中 &lt;strong&gt;查找信息非常困难&lt;/strong&gt;，因为其中存在着大量的不相关信息。rsyslog 通常允许管理员根据预定义的主题来切割文件，但随之而来的是一些小文件，又要考虑如何把所有文件的相关部分组织到一起。&lt;/p&gt;

&lt;h4 id=&quot;管理成本&quot;&gt;管理成本&lt;/h4&gt;

&lt;p&gt;另外，syslog 协议无法按程序定义的标签把消息分开，syslog 无法处理这些元信息。比如，web 服务器通常保存自己的访问日志，以避免其状态信息充斥整个系统日志。 这样一来，类似的程序都要保存自己的日志，而这些独立的配置文件、独立的消息源都要靠管理员来 &lt;strong&gt;手动管理&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;滚动问题&quot;&gt;滚动问题&lt;/h4&gt;

&lt;p&gt;纯文本的日志文件也需要日志滚动（rotation），以防止它们变的太大。在日志滚动时，现有的日志文件会被重命名、压缩。任何需要通过 syslog 消息来查看问题的程序，都要面对 “&lt;strong&gt;日志滚动期间无法查看日志&lt;/strong&gt;” 的问题，通常需要另外的工具帮忙来告知所有程序，何时日志在滚动，何时重新可用。&lt;/p&gt;

&lt;h4 id=&quot;多行消息&quot;&gt;多行消息&lt;/h4&gt;

&lt;p&gt;因为日志文件写入消息时会以换行符做为结尾，因此 &lt;strong&gt;日志消息中无法包含换行符&lt;/strong&gt;。这一点让程序无法生成多行信息，但有时程序会需要这样的信息来追溯错误。同样，日志解析软件需要额外付出很大的精力来合并多行消息。&lt;/p&gt;

&lt;h4 id=&quot;本地时间戳&quot;&gt;本地时间戳&lt;/h4&gt;

&lt;p&gt;使用本地时间戳，本地设置不对的话，将导致不同服务器上的日志时间不一致。&lt;/p&gt;

&lt;h4 id=&quot;无进程验证&quot;&gt;无进程验证&lt;/h4&gt;

&lt;p&gt;不对写入进程进行验证，任何一个进程不需要任何权限都可以伪装成其它进程来生成日志。&lt;/p&gt;

&lt;h4 id=&quot;无权限控制&quot;&gt;无权限控制&lt;/h4&gt;

&lt;p&gt;任何进程都可以读写其他进程的日志。&lt;/p&gt;

&lt;h4 id=&quot;滚动功能弱&quot;&gt;滚动功能弱&lt;/h4&gt;

&lt;p&gt;只支持定时滚动，不支持根据日志大小进行滚动，被攻击后会导致磁盘写满。&lt;/p&gt;

&lt;h4 id=&quot;无法记录启动日志&quot;&gt;无法记录启动日志&lt;/h4&gt;

&lt;p&gt;由于 rsyslogd 必须要在启动完成后，再执行 rsyslogd 守护进程，日志才会开始记录。内核不得不自己用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;klogd&lt;/code&gt; 的服务，来专门记录启动过程、启动服务过程中的日志，然后等 rsyslogd 启动后再传递给它处理。&lt;/p&gt;

&lt;h2 id=&quot;153-journald&quot;&gt;15.3 JOURNALD&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-journald.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;systemd-journald 是一个收集并存储 &lt;strong&gt;各类日志数据&lt;/strong&gt; 的 &lt;strong&gt;系统服务&lt;/strong&gt;。它基于来自各处的日志信息，创建并维护结构化的、有索引的日志数据库。&lt;/p&gt;

&lt;p&gt;journald 是为 Linux 服务器打造的新系统日志方式，它标志着 &lt;strong&gt;文本日志文件的终结&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;journald 最大的不同就是抛弃了纯文本日志文件，改为使用为日志消息优化过的 &lt;strong&gt;特殊文件格式&lt;/strong&gt;，该格式允许管理员更高效地访问所需消息，它把 “由数据库驱动的中央日志系统的” 某些能力也带到了独立的系统中。&lt;/p&gt;

&lt;p&gt;但同时，它不包含预定义的远程日志的实施，只是依靠现有的 syslog 实施方案，把消息中转到中央日志主机，从而失去了新系统的大部分优势。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt; 是 systemd 的一个组件，由 journald 处理。它捕获系统日志信息、内核日志信息，以及来自原始 RAM 磁盘的信息，早期启动信息以及所有服务中写入标准输出和标准错误数据流的信息。&lt;/p&gt;

&lt;p&gt;journald 快速改变着服务器处理日志信息与管理员访问日志的方式。&lt;/p&gt;

&lt;h3 id=&quot;1531-日志文件&quot;&gt;15.3.1 日志文件&lt;/h3&gt;

&lt;p&gt;journald 以安全和不可假冒的方式，隐式地为每条日志消息收集 &lt;strong&gt;大量元数据字段&lt;/strong&gt;。搜集来的日志数据主要是基于 &lt;strong&gt;文本&lt;/strong&gt; 的，不过需要时也 &lt;strong&gt;可以包含二进制数据&lt;/strong&gt;。日志中单独字段的大小甚至可以高达 2^64-1 字节。&lt;/p&gt;

&lt;p&gt;journald 可以用持续的方式把日志保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/journal&lt;/code&gt; 目录中，也可以一次性地保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/run/log/journal&lt;/code&gt; 目录中，后者在重启后会丢失。默认情况下，系统启动时只要找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/journal&lt;/code&gt; 目录，就会持续保存日志于其中，如找不到再退而求其次，使用易失性存储 &lt;code class=&quot;highlighter-rouge&quot;&gt;/run/log/journal&lt;/code&gt;。即系统 &lt;strong&gt;优先考虑持续保存日志&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;journald.conf(5)&lt;/code&gt; 中修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;Storage=&lt;/code&gt; 参数，可以 &lt;strong&gt;指定日志数据保存的位置&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;journald 把日志全部保存到日志目录的 &lt;strong&gt;二进制文件&lt;/strong&gt; 中，只能用 &lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 命令来查看，并可使用特定字段 &lt;strong&gt;过滤输出&lt;/strong&gt;，以单独显示某个服务的日志。&lt;/p&gt;

&lt;h3 id=&quot;1532-字节流的保存&quot;&gt;15.3.2 字节流的保存&lt;/h3&gt;

&lt;p&gt;systemd 服务管理器调用所有的服务进程时，会 &lt;strong&gt;默认&lt;/strong&gt; 将其标准输出和标准错误全部 &lt;strong&gt;连接到 journal&lt;/strong&gt;。该行为可以在单元文件中借助 &lt;code class=&quot;highlighter-rouge&quot;&gt;StandardOutput=&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;StandardError=&lt;/code&gt; 参数来修改。journal 将其收到的日志字节流在换行 &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; 和空字符 &lt;code class=&quot;highlighter-rouge&quot;&gt;NUL&lt;/code&gt; 处切割，然后 &lt;strong&gt;转换&lt;/strong&gt; 成单独的日志记录予以保存。&lt;/p&gt;

&lt;h3 id=&quot;1533-访问控制&quot;&gt;15.3.3 访问控制&lt;/h3&gt;

&lt;p&gt;日志文件默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-journal&lt;/code&gt; 系统组所有，并仅对该组开放读取权限，但无写入权限。把用户加入该组，则该用户有权读取日志文件。&lt;/p&gt;

&lt;p&gt;每个登陆用户默认会产生自己的日志文件，但这些文件并不属于他们，为了防止用户直接修改日志，文件系统使用 ACL 来确保用户只可以读取。&lt;/p&gt;

&lt;p&gt;借助 ACL，可以允许附加的用户和组来访问日志文件。如允许 &lt;code class=&quot;highlighter-rouge&quot;&gt;whell&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;adm&lt;/code&gt; 系统组读取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# setfacl -Rnm g:wheel:rx,d:g:wheel:rx,g:adm:rx,d:g:adm:rx /var/log/journal/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1534-文件&quot;&gt;15.3.4 文件&lt;/h3&gt;

&lt;h4 id=&quot;配置文件-1&quot;&gt;配置文件&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/journald.conf&lt;/code&gt;  journald 配置文件&lt;/p&gt;

&lt;h4 id=&quot;日志文件&quot;&gt;日志文件&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/run/log/journal/machine-id/*.journal&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/run/log/journal/machine-id/*.journal~&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/journal/machine-id/*.journal&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/journal/machine-id/*.journal~&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;journald&lt;/code&gt; 会把条目写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/run/log/journal/machine-id/&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/journal/machine-id&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.journal&lt;/code&gt; 文件，如果 journald 守护进程未彻底暂停，或文件被损坏，日志会被重命名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.journal~&lt;/code&gt;，然后，&lt;code class=&quot;highlighter-rouge&quot;&gt;journald&lt;/code&gt; 会开始写入一个新文件。&lt;/p&gt;

&lt;h4 id=&quot;监听对象&quot;&gt;监听对象&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/kmsg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/log&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/run/systemd/journal/dev-log&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/run/systemd/journal/socket&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/run/systemd/journal/stdout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上是 &lt;code class=&quot;highlighter-rouge&quot;&gt;journald&lt;/code&gt; 会监听的对象，除了这些套接字和路径，它还可以使用网络链接来监听审计事件。&lt;/p&gt;

&lt;h3 id=&quot;1535-用-journalctl-查看日志&quot;&gt;15.3.5 用 &lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 查看日志&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 命令用于查询由 journald 生成的日志。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl [-nrpf] [--since TIME] [--until TIME] _optional&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;默认会列出全部内容，可以用参数过滤。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt;  	列出最近几行&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;  	反向输出，旧的排最后&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;  	用优先级过滤，只显示重要性大于等于指定优先级的日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;  	实时监测&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--since --until&lt;/code&gt;	设置开始时间与结束时间，可以分开使用，也可同时使用&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_SYSTEMD_UNIT=&lt;/code&gt; 	查看指定单元的日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_COMM=&lt;/code&gt; 		查看指定命令的日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_PID=&lt;/code&gt;   		查看指定 PID 的日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_UID=&lt;/code&gt;   		查看指定 UID 的日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SYSLOG_FACILITY=[0-23]&lt;/code&gt; 		用服务类型序号过滤&lt;/p&gt;

&lt;h4 id=&quot;查看所有日志&quot;&gt;查看所有日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本次系统启动以来的所有日志。&lt;/p&gt;

&lt;h4 id=&quot;查看-指定日期-的日志&quot;&gt;查看 &lt;strong&gt;指定日期&lt;/strong&gt; 的日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl --since &quot;2015-08-18 00:00:00&quot; --until &quot;2015-08-19 00:00:00&quot;
~]# journalctl --since today
~]# journalctl --since yesterday --until today
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;查看-指定单元-的日志&quot;&gt;查看 &lt;strong&gt;指定单元&lt;/strong&gt; 的日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl _SYSTEMD_UNIT=crond.service -n 10   # 最近10行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;查看-指定命令-的日志&quot;&gt;查看 &lt;strong&gt;指定命令&lt;/strong&gt; 的日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl _COMM=su _COMM=login -n 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查看 su 和 login 的日志。&lt;/p&gt;

&lt;h4 id=&quot;查看-指定等级-的日志&quot;&gt;查看 &lt;strong&gt;指定等级&lt;/strong&gt; 的日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl -p err
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;查看-指定程序类型-的日志&quot;&gt;查看 &lt;strong&gt;指定程序类型&lt;/strong&gt; 的日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl SYSLOG_FACILITY=4 SYSLOG_FACILITY=10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序类型用日志设备的 &lt;strong&gt;相对序号&lt;/strong&gt; 表示，4 为 pam产生的日志，10 为登录信息的验证信息。&lt;/p&gt;

&lt;h4 id=&quot;实时监控日志&quot;&gt;实时监控日志&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# journalctl -f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1536-journald-的优势&quot;&gt;15.3.6 JOURNALD 的优势&lt;/h3&gt;

&lt;h4 id=&quot;结构化日志文件&quot;&gt;结构化日志文件&lt;/h4&gt;

&lt;p&gt;journald 尝试解决 syslog 的历史问题，于是用一个更加结构化的格式来替代纯文本文件。同时，通过提供相同的 C API，journald 与 syslog 完全兼容，它不仅提供相同的协议，而且还会把消息的纯文本版本转发给现有的 syslog 系统。&lt;/p&gt;

&lt;p&gt;journald 的 API 支持结构化的数据，日志消息不仅包含固定的字段列表，而且 &lt;strong&gt;允许程序定义自己的消息字段&lt;/strong&gt;。新的日志格式实现了针对任何字段都能进行快速的访问和读取。通过直接使用空间优化格的式，消除了日志滚动，不再需要重命名文件来存档条目。同时，还会自动限制磁盘上日志文件的大小。这些让程序处理日志时变得更加轻松。&lt;/p&gt;

&lt;p&gt;对于这种特殊的日志文件格式，journald 提供一个专门的工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 来处理。该程序可以快速地访问条目，并且支持用日期、发起程序、程序 PID、UID、服务或其它要素来过滤。&lt;/p&gt;

&lt;p&gt;有了这种快速访问的格式，现在可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl&lt;/code&gt; 来随时快速查看状态，同时在返回的信息中会包含该服务 &lt;strong&gt;最近的几个日志条目&lt;/strong&gt;，甚至可以实现类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;tail -f&lt;/code&gt; 的效果，&lt;strong&gt;实时地观察&lt;/strong&gt; 特定类型的新的日志条目。另外，&lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 不仅能访问当前系统的日志文件，还可以访问其它系统的备份日志文件。&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;简言之，新的日志格式使 &lt;strong&gt;程序更容易找到自己想要的信息&lt;/strong&gt;，而且是以 &lt;strong&gt;结构化&lt;/strong&gt; 的方式，同时还可以轻松地 &lt;strong&gt;实时追踪新日志&lt;/strong&gt; 消息流。&lt;/p&gt;

&lt;h4 id=&quot;journald-安全机制&quot;&gt;JOURNALD 安全机制&lt;/h4&gt;

&lt;h5 id=&quot;封印保护&quot;&gt;封印保护&lt;/h5&gt;

&lt;p&gt;如果系统被攻破，攻击者会尝试掩盖自己的行踪，以便不被管理员发现。攻击者掩盖行踪的一种方法就是删除日志条目。journald 带来的一个新功能称为 &lt;strong&gt;封印保护&lt;/strong&gt;，Forward Secure Sealing，FSS，用来 &lt;strong&gt;检测对日志文件的篡改&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;网络日志系统能够轻易地防止日志的篡改，但 journald 至少提供了一个在单一系统中检测日志篡改的方法，虽然它无法提供外部日志可提供的所有保障。&lt;/p&gt;

&lt;p&gt;启用封印保护之后，日志中的所有条目都是加密哈希过的，文件中包含先前条目的哈希值。这样的结果是一个条目链，每一个条目都可以认证之前的全部。如果最顶端的哈希通常都保存在一个只读的位置，整个链条都可以通过它认证。检测攻击者的修改将变得十分容易。&lt;/p&gt;

&lt;h6 id=&quot;密钥&quot;&gt;密钥&lt;/h6&gt;

&lt;p&gt;封印保护是基于两个密钥，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl --setup-keys&lt;/code&gt; 产生。&lt;/p&gt;

&lt;p&gt;一个密钥是封印密钥，保存在系统中，另一个为验证密钥，应安全地保存在别处。&lt;/p&gt;

&lt;p&gt;新的封印密钥会按一定频率以不可逆方式生成，旧密钥会被删除。&lt;/p&gt;

&lt;p&gt;验证密钥可以用于计算任何时间段内的封印密钥。这意味着攻击者只能访问当前的封印密钥，而管理员则可以可靠地生成任何封印密钥，以验证之前的日志文件封印。如果有人修改了上一个封印之前的日志条目，就会返回验证失败。&lt;/p&gt;

&lt;h6 id=&quot;封印频率&quot;&gt;封印频率&lt;/h6&gt;

&lt;p&gt;封印保护的基本概念是，可以对 journald 的二进制日志 &lt;strong&gt;以一定的频率进行封印&lt;/strong&gt;，封印是对日志数据进行一种加密操作，任何先于封印的篡改会被检测到。只要在攻击者取得机会篡改之前进行了封印，他们的足迹就会与其它日志数据一起被封印。他们仍然可以删除日志文件条目，但照样会被注意到。&lt;/p&gt;

&lt;p&gt;封印保护默认每 15 分钟封印日志一次。该频率可以在生成密钥时使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--interval=10s&lt;/code&gt; 来修改。生成封印密钥时，会使用系统时钟时间，&lt;/p&gt;

&lt;h6 id=&quot;缺陷&quot;&gt;缺陷&lt;/h6&gt;

&lt;p&gt;攻击者入侵系统之后，完全可以重新生成整个日志，导致该检测毫无意义。&lt;/p&gt;

&lt;p&gt;唯一保证日志安全性的方法是使用一个 &lt;strong&gt;物理的、只追加的设备&lt;/strong&gt; 来保存日志（如网卡）。并且一旦系统被入侵，后续追加的日志都是无法保证可靠性的。&lt;/p&gt;

&lt;h4 id=&quot;稳定性&quot;&gt;稳定性&lt;/h4&gt;

&lt;h5 id=&quot;内存存储&quot;&gt;内存存储&lt;/h5&gt;

&lt;p&gt;日志默认保存在内存文件系统 &lt;code class=&quot;highlighter-rouge&quot;&gt;/run/systemd/journal&lt;/code&gt; 中，&lt;strong&gt;可以在磁盘损坏的情况下工作&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;日志滚动&quot;&gt;日志滚动&lt;/h5&gt;

&lt;p&gt;通过监测日志文件大小进行日志滚动。&lt;/p&gt;

&lt;h4 id=&quot;不错的性能&quot;&gt;不错的性能&lt;/h4&gt;

&lt;p&gt;使用新的二进制格式的日志文件，通过偏移来定位日志位置，避免了文本型日志遍历的低性能。&lt;/p&gt;

&lt;p&gt;通过引用相同日志来压缩何种，尽管 journal 记录了更多的元数据信息，但磁盘占用却无明显变化。&lt;/p&gt;

&lt;h4 id=&quot;权限控制&quot;&gt;权限控制&lt;/h4&gt;

&lt;p&gt;可以控制用户对日志的访问。从非特权登陆用户发来的消息，用户的日志文件被分别独立保存。使用 POSIX ACL 进行读取权限的控制，保证用户可以访问自己的日志文件。默认情况下，普通用户无权访问系统服务生成的日志条目，除非用户加入特权组。&lt;/p&gt;

&lt;h4 id=&quot;客户端认证&quot;&gt;客户端认证&lt;/h4&gt;

&lt;p&gt;systemd 在生成日志时，会在日志中添加元数据信息，由 journald 显式生成的元信息其字段名都有下划线 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;&lt;/strong&gt; 做前缀，这些字段称为 &lt;strong&gt;可信字段&lt;/strong&gt;。这些字段的信息无法被客户端修改。因此，普通权限的应用再也无法伪造身份了。&lt;/p&gt;

&lt;h3 id=&quot;1537-journald-的劣势&quot;&gt;15.3.7 JOURNALD 的劣势&lt;/h3&gt;

&lt;p&gt;远程日志。&lt;/p&gt;

&lt;p&gt;来自多个不同系统的日志被发送到一个中央日志主机，通常保存在数据库中，这种方式逐渐成为了日志管理的标准。这些中央日志主机解决了许多与 journald 一样的 syslog 问题。通过特定的规范，实现了快速访问日志消息，以及追踪新日志并生成报告。&lt;/p&gt;

&lt;p&gt;因为这些中央日志系统使用基于文本的 syslog 守护进程，它们必须用正则表达式，从单行纯文本日志消息中提取程序的自定义字段，journald 允许应用程序发送中央系统能直接使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;键-值&lt;/code&gt;字段，而无需使用表达式。可惜的是，journald 没有提供远程日志解决方案。&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-journal-remote&lt;/code&gt; 只是一个概念，并不是一个实用的工具，缺少良好的认证机制。有一些尚处于试验阶段的第三方程序包，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;journald-forwarder&lt;/code&gt;。基于此原因，远程日志管理仍然要信赖于现有的 syslog 体系及协议，因此 &lt;strong&gt;在远程日志方面，无法使用 journald 的结构化的数据&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;虽然可以把结构化的数据发送给 syslog，但对其功能少有支持。&lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog&lt;/code&gt; 的当前版本提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;imjournal&lt;/code&gt; 模块，可以导入一些结构化的数据，但仅对一部分的数据进行了映射，而且不支持应用程序自定义的字段。而且就性能表现来看，rsyslog 也不建议使用该模块。&lt;/p&gt;

&lt;h2 id=&quot;154-logrotate&quot;&gt;15.4 LOGROTATE&lt;/h2&gt;

&lt;p&gt;日志滚动的设计是为了简化日志管理的工作，控制无休止生成的大量日志。&lt;/p&gt;

&lt;p&gt;日志滚动可以实现自动滚动、压缩、删除、发邮件。滚动的频率要么是按日、周、月，要么是日志过大时立即处理。&lt;/p&gt;

&lt;p&gt;logrotate 程序是依靠 cron 实现计划任务的。&lt;/p&gt;

&lt;h3 id=&quot;1541-日志滚动如何实现&quot;&gt;15.4.1 日志滚动如何实现&lt;/h3&gt;

&lt;p&gt;系统一般把日志滚动作为计划任务来运行，通常每天进行一次。脚本大多位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.daily/logrotate&lt;/code&gt;。如果需要更高的滚动频率，也可以把脚本放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.hourly&lt;/code&gt; 目录。&lt;/p&gt;

&lt;p&gt;当 logrotate 运行时，它会读取配置文件，以了解日志文件的位置、滚动频率、保留归档日志的数量。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/logrotate.png&quot; alt=&quot;日志滚动示意图&quot; /&gt;
  
&lt;/figure&gt;

&lt;h3 id=&quot;1542-配置文件&quot;&gt;15.4.2 配置文件&lt;/h3&gt;

&lt;p&gt;在命令行上可以输入任意数量的配置文件，最后一个会覆盖前面所有的参数，因此各个配置文件在列表中的顺序非常重要。&lt;/p&gt;

&lt;p&gt;logrotate 通常由配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/logrotate.conf&lt;/code&gt; 统一管理，它会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; 语句把 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/logrotate.d/&lt;/code&gt; 目录中的所有其它需要的配置文件全部包含进来。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.daily/logrotate&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;配置文件的默认设置&quot;&gt;配置文件的默认设置&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;weekly			# 每周滚动一次
rotate 4		# 保留 4 个日志文件
create			# 原日志更名后新建空日志
dateext			# 旧日志用日期做文件名
#compress	# 压缩旧日志

include /etc/logrotate.d	# 加载该目录下所有配置文件

/var/log/wtmp {			# 针对 /var/log/wtmp 单独设定参数
    monthly						# 每月一次滚动
    create 0664 root utmp		# 新建文件的权限，用户，组
    minsize 1M					# 日志超过 1M 才进行滚动
    rotate 1					# 只保留一个日志文件
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/logrotate.d&lt;/code&gt; 目录是专门为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/logrotate.conf&lt;/code&gt; 规划出来的。每个以 RPM 打包方式创建的服务，都会把其日志的配置文件，放到该目录。每个服务都可以拥有各自的日志滚动设置，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/logrotate.conf&lt;/code&gt; 是做为服务的默认滚动配置存在的.&lt;/p&gt;

&lt;h4 id=&quot;单独配置特定服务&quot;&gt;单独配置特定服务&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;日志的绝对路径文件名  {		# 可以用空格分隔多个日志
    参数设置1
	参数设置2
	执行脚本
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行脚本部分可调用外部指令来执行额外的命令，需用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sharedscripts .... endscript&lt;/code&gt; 标签包围。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prerotate&lt;/code&gt;：启动 logrotate 之前执行的命令，如修改日志属性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;postrotate&lt;/code&gt;：logrotate 操作完成之后要执行的命令，如重启某服务&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prerotate&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;postrotate&lt;/code&gt; 对于已加上隐藏属性的文件特别必要&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;配置范例&quot;&gt;配置范例&lt;/h4&gt;

&lt;p&gt;只对 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/&lt;/code&gt; 内的 cron, maillog, messages, secure, spooler 这几个日志文件有效。&lt;/p&gt;

&lt;p&gt;日志滚动每周一次，保留四个，滚动下来的日志不压缩，滚动完毕后获取 syslog 的 PID，用 kill -HUP 重启 syslogd。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/var/log/cron
/var/log/maillog
/var/log/messages
/var/log/secure
/var/log/spooler
    {
        sharedscripts
        prerotate
        	/usr/bin/chattr -a /var/log/messages
        endscript
        sharedscripts
        postrotate
            /bin/kill -HUP `cat /var/run/syslogd.pid 2&amp;gt; /dev/null` 2&amp;gt; /dev/null || true
            /usr/bin/chattr +a /var/log/messages
        endscript
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/kill -HUP&lt;/code&gt; 会让 rsyslogd 重启并读取其配置文件。&lt;/p&gt;

&lt;h2 id=&quot;155-linux-常用日志&quot;&gt;15.5 Linux 常用日志&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/boot.log&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动的时候系统内核会检测并启动硬件，然后启动内核的功能。这些流程都会记录在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/boot.log&lt;/code&gt; 里。该文件只保留 &lt;strong&gt;本次启动的信息&lt;/strong&gt;，不记录上一次启动的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/cron&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;crontab &lt;strong&gt;计划任务&lt;/strong&gt; 日志。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/dmesg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CentOS 在启动时默认不显示 &lt;strong&gt;内核的硬件检测信息&lt;/strong&gt;，都保存在该日志。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/lastlog&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记录 &lt;strong&gt;所有帐号最近一次登陆系统的信息&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/maillog&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/mail/\*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记录 &lt;strong&gt;邮件的往来信息&lt;/strong&gt;，主要是记录 postfix （SMTP 协议提供者）与 dovecot（POP3 协议提供者）所产生的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于保存有价值的、非调试的、非关键的消息，即系统的普通活动日志。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/secure&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于追踪认证系统，所有与安全相关的消息，sudo login，SSH login 等其它登陆错误&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/wtmp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;成功登陆系统的帐号&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/faillog&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;登陆失败的帐号&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/httpd/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;http 服务日志&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/samba/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;samba 服务日志&lt;/p&gt;

&lt;h2 id=&quot;156-日志解析&quot;&gt;15.6 日志解析&lt;/h2&gt;

&lt;h3 id=&quot;1551-logwatch&quot;&gt;15.5.1 LOGWATCH&lt;/h3&gt;

&lt;p&gt;CentOS 7 内置的 &lt;code class=&quot;highlighter-rouge&quot;&gt;logwatch&lt;/code&gt; 是一个强大的日志解析和分析工具。它的设计目的在于给出一个服务器中所有活动的 &lt;strong&gt;统一的报告&lt;/strong&gt;，可以发送到终端或通过邮件发给管理员。&lt;/p&gt;

&lt;p&gt;logwatch 并不提供实时警告，它会生成一个由系统整理出来的摘要，便于查验。也可以与脚本配合生成更详细的报告。&lt;/p&gt;

&lt;p&gt;logwatch 默认用邮件发送日志摘要。&lt;/p&gt;

&lt;p&gt;如果没有安装，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum install logwatch&lt;/code&gt; 在线安装。安装好以后，会生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.daily/0logwatch&lt;/code&gt; 文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# ll /etc/cron.daily/0logwatch
-rwxr-xr-x. 1 root root 434 Jun 10  2014 /etc/cron.daily/0logwatch
~]# /etc/cron.daily/0logwatch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="日志" /><category term="syslog" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 14. Systemd</title><link href="/linux/linux.systemd/" rel="alternate" type="text/html" title="Linux 基础 - 14. Systemd" /><published>2015-01-14T00:00:00+08:00</published><updated>2015-01-14T00:00:00+08:00</updated><id>/linux/linux.systemd</id><content type="html" xml:base="/linux/linux.systemd/">&lt;h2 id=&quot;141-守护进程与服务&quot;&gt;14.1 守护进程与服务&lt;/h2&gt;

&lt;h3 id=&quot;1411-服务&quot;&gt;14.1.1 服务&lt;/h3&gt;

&lt;p&gt;服务，Service，是一种 &lt;strong&gt;进程&lt;/strong&gt;，它通过进程间通信机制来 &lt;strong&gt;响应其它程序的请求&lt;/strong&gt;，这些请求 &lt;strong&gt;通常来自于网络&lt;/strong&gt;。服务通常是由服务软件提供的。&lt;/p&gt;

&lt;p&gt;服务包括守护进程及其他服务。非守护进程的服务通常由 &lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt; 控制，&lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt; 负责监听请求，必要时会启动相关的服务来处理，请求被处理完成以后，服务会再次被关闭。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;【 xinetd 】 extended internet deamon。&lt;strong&gt;负责管理基于互联网的活动&lt;/strong&gt;。相对于较早的 &lt;code class=&quot;highlighter-rouge&quot;&gt;inetd&lt;/code&gt;，其安全性更好。&lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt; &lt;strong&gt;监听&lt;/strong&gt; 其管理的所有服务的 &lt;strong&gt;端口&lt;/strong&gt;，当发生连接请求时，&lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt; 决定是否允许客户端访问。如果允许，则启动对应的服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1412-守护进程&quot;&gt;14.1.2 守护进程&lt;/h3&gt;

&lt;p&gt;守护进程，Daemon，是一种 &lt;strong&gt;服务进程&lt;/strong&gt;，它们运行于后台，管理系统或为其它进程提供特定的功能。它 &lt;strong&gt;不会与用户发生任何交互&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;早期的守护进程由 &lt;code class=&quot;highlighter-rouge&quot;&gt;SysVinit&lt;/code&gt; 部署，而现代的守护进程遵循一个简单而更强大的方案，由 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 部署，称之为新型守护进程。&lt;/p&gt;

&lt;p&gt;守护进程进程名字均以字母 ‘&lt;strong&gt;d&lt;/strong&gt;’ 结尾，如 syslogd、sshd 等。&lt;/p&gt;

&lt;p&gt;典型的守护进程：&lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache&lt;/code&gt;。典型的非守护进程：&lt;code class=&quot;highlighter-rouge&quot;&gt;rsync&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;vsftpd&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;📕 服务的概念大于守护进程。&lt;/p&gt;

&lt;h3 id=&quot;1413-sysvinit&quot;&gt;14.1.3 sysvinit&lt;/h3&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 之前，一直以来都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;SysVinit&lt;/code&gt; 掌管启动进程。当系统使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SysVint&lt;/code&gt; 时，&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 是加载内核后，第一个执行的进程。 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 会加载一系列的脚本，这些脚本会启动各种系统服务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SysVinit&lt;/code&gt; 的问题在于它 &lt;strong&gt;需要细致的调整&lt;/strong&gt;。&lt;strong&gt;必须确保进程的启动顺序正确&lt;/strong&gt;，以满足进程间的依赖性。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SysVinit&lt;/code&gt; 实现的方式是 &lt;strong&gt;为服务设定严格的启动顺序&lt;/strong&gt;，每个服务都被分配了 &lt;strong&gt;优先级&lt;/strong&gt; 数字，然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 按照优先级的顺序 &lt;strong&gt;依次启动&lt;/strong&gt; 服务。导致 &lt;strong&gt;启动时间较长&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;要想确保服务的启动顺序正确，必须为服务手工配置优先级，为此需花费很大的精力。&lt;/p&gt;

&lt;h4 id=&quot;init-的特点&quot;&gt;init 的特点&lt;/h4&gt;

&lt;p&gt;init 的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;启动时间长&lt;/strong&gt;：init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;启动脚本复杂&lt;/strong&gt;：init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;操作命令&quot;&gt;操作命令&lt;/h5&gt;

&lt;p&gt;所有的服务启动脚本都放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d/apache2 start&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;service apache2 start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;停止命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d/apache2 stop&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;service apache2 stop&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重新启动：/etc/init.d/apache2 restart 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;service apache2 restart&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看状态：/etc/init.d/apache2 status 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;service apache2 status&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;服务启动模式&quot;&gt;服务启动模式&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;独立启动&lt;/strong&gt;：stand alone，服务独立启动，常驻于内存，反应速度快。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;超级守护进程&lt;/strong&gt;：super daemon，做为总管进程，&lt;strong&gt;统一管理所有的守护进程&lt;/strong&gt;。早期的超级守护进程是 &lt;code class=&quot;highlighter-rouge&quot;&gt;inetd&lt;/code&gt;，后来被 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt;&lt;/strong&gt; 取代了。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt; 管理多个网络服务。当没有用户请求套接字或端口时，服务不会启动。有用户请求时，&lt;code class=&quot;highlighter-rouge&quot;&gt;xinetd&lt;/code&gt; 唤醒对应的服务。请求结束，服务也会停止。&lt;/p&gt;

    &lt;p&gt;优点是可以 &lt;strong&gt;管理多个网络服务&lt;/strong&gt;，缺点是 &lt;strong&gt;唤醒服务会有一点延迟&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;服务的依赖关系&lt;/strong&gt;：&lt;/p&gt;

    &lt;p&gt;init 需要管理员根据服务之间的依赖关系，&lt;strong&gt;手动排序&lt;/strong&gt; 优先级。相当费精力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行等级的分类&lt;/strong&gt;： init 可以根据使用者自定义的 &lt;strong&gt;执行等级&lt;/strong&gt; 来唤醒不同的服务，以进入不同的 &lt;strong&gt;服务环境&lt;/strong&gt; 和 &lt;strong&gt;操作界面&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;Linux 提供 7 个执行等级，0 ~ 6， 其中比较重要的是 1，单人维护模式，3，纯文本模式，5，文字加图形界面&lt;/p&gt;

    &lt;p&gt;各个执行等级的启动脚本是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rc.d/rc[0-6]/SXXdaemon&lt;/code&gt; 链接到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d/daemon&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;链接文件名：SXXdaemon。S 表示启动该服务，XX 是优先级。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置执行等级对应的服务：SXXdaemon 这些链接文件不是手动生成的，而是通过以下命令自动生成的：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;开机启动： &lt;code class=&quot;highlighter-rouge&quot;&gt;chkconfig daemon on&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;开机不启动： &lt;code class=&quot;highlighter-rouge&quot;&gt;chkconfig daemon off&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看是否开机启动： &lt;code class=&quot;highlighter-rouge&quot;&gt;chkconfig --list daemon&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行等级的切换：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;init 5&lt;/code&gt; 会从纯命令行（运行等级 3）切换到图形界面（运行等级 5），init 会自动分析 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rc.d/rc[3].d/&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rc.d/rc[5].d/&lt;/code&gt; 目录中的脚本，然后启动转换执行等级所需的服务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1414-systemd&quot;&gt;14.1.4 systemd&lt;/h3&gt;

&lt;h4 id=&quot;systemd-简介&quot;&gt;systemd 简介&lt;/h4&gt;

&lt;p&gt;从 CentOS 7 以后，Red Hat 系列发行版放弃沿用多年的 System V 开机启动服务的流程，改用 systemd 这个启动服务管理机制。&lt;/p&gt;

&lt;p&gt;在系统启动后，做为第一个运行的进程，systemd 扮演初始化系统的角色，负责启动和维护用户空间的服务。&lt;/p&gt;

&lt;p&gt;Systemd 中，&lt;strong&gt;所有的服务都是彼此分离的&lt;/strong&gt;，即使某一个服务的配置文件有问题，也不会影响到其它的服务。&lt;/p&gt;

&lt;p&gt;Systemd 不只是一个初始化的系统，它也 &lt;strong&gt;是一套库和工具&lt;/strong&gt;。可以用来 &lt;strong&gt;替代多种服务和工具&lt;/strong&gt;，包括 sysvinit, pm-utils, inetd, acpid, syslog, watchdog, cron, atd 等。&lt;/p&gt;

&lt;p&gt;Systemd 可以兼容 init 的启动脚本，因此，init 启动脚本也能够通过 systemd 来管理，但无法使用 systemd 的高级功能。&lt;/p&gt;

&lt;h4 id=&quot;systemd-独有的功能&quot;&gt;systemd 独有的功能&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;sysvinit 的执行等级，只有 1, 3, 5 有对应的 target 类型&lt;/li&gt;
  &lt;li&gt;所有服务都用 systemctl 管理，支持的语法有限制，不可自定义参数&lt;/li&gt;
  &lt;li&gt;如果没有用 systemctl 启动服务，而是手动启动的，systemd 将无法管理&lt;/li&gt;
  &lt;li&gt;systemd 启动过程中，不接受任何输入，因此自定义的服务不应在启动期间尝试用标准输入与之互动，因为期间标准输入被设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1415-systemd-与-sysvinit-的区别&quot;&gt;14.1.5 systemd 与 sysvinit 的区别&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;systemd&lt;/th&gt;
      &lt;th&gt;SysVinit&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;服务&lt;/td&gt;
      &lt;td&gt;引入 &lt;strong&gt;单元&lt;/strong&gt;（systemd units）的概念，每个服务为一个单元，这些单元由各自的配置文件控制，这些文件包含了服务启动时需要的所有配置信息，包括进程依赖关系的描述。&lt;/td&gt;
      &lt;td&gt;每个服务对应一个脚本文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;服务启动顺序&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;并行启动多个服务&lt;/strong&gt;，提升启动速度。只需设置少量的文件。&lt;/td&gt;
      &lt;td&gt;依照优先级 &lt;strong&gt;逐个启动&lt;/strong&gt;，需要花费大量精力去手动设置。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;服务的管理&lt;/td&gt;
      &lt;td&gt;按需启动服务，&lt;strong&gt;无需另外的服务来管理&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;按需启动服务，&lt;strong&gt;需要超级守护进程来管理&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;服务依赖&lt;/td&gt;
      &lt;td&gt;服务依赖关系 &lt;strong&gt;自动管理&lt;/strong&gt;，会自动启动相关的服务，防止长时间超时。&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;静态管理&lt;/strong&gt;，需要管理员手动调整各服务启动顺序，需要管理员对各服务关系非常了解&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;服务监控&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;持续监控&lt;/strong&gt; 服务，可以自动重启崩溃的服务&lt;/td&gt;
      &lt;td&gt;需要常常调整监控服务，服务很容易逃避监控&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;记录日志&lt;/td&gt;
      &lt;td&gt;增强了记录日志能力，启动后就可以开始记录&lt;/td&gt;
      &lt;td&gt;启动后一段时间才开始记录日志&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;服务环境&lt;/td&gt;
      &lt;td&gt;按相关性把所有服务 &lt;strong&gt;分组&lt;/strong&gt;（target），通过切换组来切换服务环境&lt;/td&gt;
      &lt;td&gt;使用 &lt;strong&gt;执行等级&lt;/strong&gt; 来切换不同的服务环境&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;142-systemd-简介&quot;&gt;14.2 systemd 简介&lt;/h2&gt;

&lt;p&gt;systemd 是 &lt;strong&gt;一套软件&lt;/strong&gt;，它为 Linux 提供基本的构建块。其中最突出的一个软件就是 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt;&lt;/strong&gt;，是一个 &lt;strong&gt;系统管理和服务管理的工具&lt;/strong&gt;。它是一个 &lt;strong&gt;初始化&lt;/strong&gt; 的系统，负责 &lt;strong&gt;自举用户空间&lt;/strong&gt;，并在 &lt;strong&gt;启动后管理系统进程&lt;/strong&gt;。是 UNIX System V 以及 BSD init 的替代品。&lt;/p&gt;

&lt;p&gt;systemd 项目的主要目标之一是，在所有的 Linux 发行版中 &lt;strong&gt;统一基本配置和服务行为&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;2015 年起，大量的发行版开始把 systemd 做为其默认的初始化系统。&lt;/p&gt;

&lt;p&gt;Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。&lt;/p&gt;

&lt;p&gt;事实上，现在还有很多人反对使用 systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反 “&lt;strong&gt;keep simple, keep stupid&lt;/strong&gt;” 的 Unix 哲学。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/Systemd_components.png&quot; alt=&quot;systemd 的架构&quot; /&gt;
  
&lt;/figure&gt;

&lt;h3 id=&quot;1421-systemd-设计宗旨&quot;&gt;14.2.1 systemd 设计宗旨&lt;/h3&gt;

&lt;p&gt;systemd 的设计目标是，为系统的启动和管理提供一套完整的解决方案。Systemd 这个名字的含义，就是它要守护整个系统。&lt;/p&gt;

&lt;p&gt;使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。&lt;/p&gt;

&lt;p&gt;systemd 的立意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统管理及服务管理：通过应用各种配置，来管理系统和服务&lt;/li&gt;
  &lt;li&gt;软件平台：为其它软件的开发提供服务&lt;/li&gt;
  &lt;li&gt;应用与内核的粘合剂：提供多种接口，便于程序访问各种内核的功能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;systemd 不仅仅是初始化的那个守护进程，它更是代表围绕它的整个的软件包，包括 journald、logind、networkd 等许多其它的底层组件。&lt;/p&gt;

&lt;p&gt;做为一个内置的软件包，systemd &lt;strong&gt;代替了&lt;/strong&gt; 那些由传统初始化守护进程控制的 &lt;strong&gt;启动序列、运行级以及各个脚本&lt;/strong&gt;。同时，它也 &lt;strong&gt;整合&lt;/strong&gt; 了许多 Linux 常见的 &lt;strong&gt;其它的服务&lt;/strong&gt;，如用户登陆、系统控制台、设备热插拔、计划任务、日志、主机名及区域设置。&lt;/p&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 一样，&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 也是一个守护进程，用来管理其它的守护进程，包括它自己。它是系统启动过程中第一个守护进程，也是系统关闭过程中最后一个终止的守护进程。&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 是进程树中的根，Unix 系统中的第一个进程（PID 1）往往扮演着特殊的角色，当某个守护进程从其父进程分离出来以后被终止时，&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 会收到一个 SIGCHLD 信号。因此，第一个进程非常适合用来监控守护进程。传统的管理守护进程的办法是，把守护进程启动之后就不再监控了，而 systemd 尝试在这方面有所改进。&lt;/p&gt;

&lt;p&gt;systemd 是以并行的方式执行启动序列的，比传统的方法要快。对于进程间通信，systemd 使 Unix domain socket 和 D-Bus 对运行中的守护进程变的可用。systemd 自身的状态也可以保存于快照中，便于日后查看。&lt;/p&gt;

&lt;h3 id=&quot;1422-单元&quot;&gt;14.2.2 单元&lt;/h3&gt;

&lt;p&gt;Systemd 可以管理所有 &lt;strong&gt;系统资源&lt;/strong&gt;。不同的资源统称为 Unit（&lt;strong&gt;单元&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;单元一共分成 12 种。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Service unit：系统服务&lt;/li&gt;
  &lt;li&gt;Target unit：多个单元构成的一个组&lt;/li&gt;
  &lt;li&gt;Device Unit：硬件设备&lt;/li&gt;
  &lt;li&gt;Mount Unit：文件系统的挂载点&lt;/li&gt;
  &lt;li&gt;Automount Unit：自动挂载点&lt;/li&gt;
  &lt;li&gt;Path Unit：文件或路径&lt;/li&gt;
  &lt;li&gt;Scope Unit：不是由 Systemd 启动的外部进程&lt;/li&gt;
  &lt;li&gt;Slice Unit：进程组&lt;/li&gt;
  &lt;li&gt;Snapshot Unit：Systemd 快照，可以切回某个快照&lt;/li&gt;
  &lt;li&gt;Socket Unit：进程间通信的套接字&lt;/li&gt;
  &lt;li&gt;Swap Unit：交换文件&lt;/li&gt;
  &lt;li&gt;Timer Unit：定时器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;systemd 把 &lt;strong&gt;每个守护进程的&lt;/strong&gt; 初始化指令都保存在一个 &lt;strong&gt;配置文件&lt;/strong&gt; 中，称之为 &lt;strong&gt;单元文件&lt;/strong&gt;（Unit File），使用的是声明语言，传统方法是每个守护进程用一个脚本文件来配置。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-units&lt;/code&gt;  列出正在运行的单元&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-units --all&lt;/code&gt;  列出所有单元，包括没有找到配置文件的或者启动失败的&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-units --all --state=inactive&lt;/code&gt;  列出所有没有运行的单元&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-units --failed&lt;/code&gt;  列出所有加载失败的单元&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-units --type=service&lt;/code&gt;  列出所有正在运行的、类型为服务的单元&lt;/p&gt;

&lt;h4 id=&quot;单元的状态&quot;&gt;单元的状态&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl status&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令用于查看系统状态和单个单元的状态。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl status&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示系统状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sysystemctl status bluetooth.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示单个单元的状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl -H root@rhel7.example.com status httpd.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示远程主机的某个单元的状态&lt;/p&gt;

&lt;p&gt;除了&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;命令，&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl&lt;/code&gt;还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl is-active application.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示某个单元是否正在运行&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl is-failed application.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示某个单元是否处于启动失败状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl is-enabled application.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示某个单元服务是否建立了启动链接&lt;/p&gt;

&lt;h4 id=&quot;单元管理&quot;&gt;单元管理&lt;/h4&gt;

&lt;p&gt;对于用户来说，最常用的是下面这些命令，用于启动和停止单元（经常用于管理服务）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl start apache.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;立即 &lt;strong&gt;启动&lt;/strong&gt; 一个服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl stop apache.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;立即 &lt;strong&gt;停止&lt;/strong&gt; 一个服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl restart apache.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重启&lt;/strong&gt; 一个服务&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl kill apache.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;杀死&lt;/strong&gt; 一个服务的所有子进程&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl reload apache.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重新加载&lt;/strong&gt; 一个服务的 &lt;strong&gt;配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl daemon-reload&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重新加载所有修改过的配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl show httpd.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示某个单元的 &lt;strong&gt;所有底层参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl show -p CPUShares httpd.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示某个单元的指定属性的值&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl set-property httpd.service CPUShares=500&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置某个单元的指定属性&lt;/p&gt;

&lt;h4 id=&quot;依赖关系&quot;&gt;依赖关系&lt;/h4&gt;

&lt;p&gt;单元之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-dependencies&lt;/code&gt; 命令列出一个单元的所有依赖。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-dependencies nginx.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面命令的输出结果之中，有些依赖是 Target 类型，默认不会展开显示。如果要展开 Target，就需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--all&lt;/code&gt;参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-dependencies --all nginx.service&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;1423-核心组件&quot;&gt;14.2.3 核心组件&lt;/h3&gt;

&lt;p&gt;随着被整合进 Linux，systemd 也提供了各种守护进程和工具的替代品，可以替代启动脚本、pm-utils、inetd、acpid、syslog、watchdog、cron、atd 等。systemd 的核心组件包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;systemd 是系统管理器及服务管理器&lt;/li&gt;
  &lt;li&gt;systemctl 可用于检查和控制 systemd 的状态&lt;/li&gt;
  &lt;li&gt;systemd-analyze 用于确定系统启动性能统计信息，并从 systemd 中检索其他状态和跟踪信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;systemd &lt;strong&gt;不再使用 PID，而是使用内核的 cgroups 子系统来追踪进程&lt;/strong&gt;，因此，守护进程是无法逃脱 systemd 的。system 不仅仅是使用 cgroups，它还用 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-nspawn&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;machinectl&lt;/code&gt;&lt;/strong&gt; 这两个工具来 &lt;strong&gt;强化&lt;/strong&gt; 其功能，这两个工具 &lt;strong&gt;实现了 Linux 容器的创建和管理&lt;/strong&gt;。从 205 版本开始，systemd 也提供了 cgroups 接口。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;【 cgroups 】Control Groups 的缩写，是 Linux 内核的功能，它会 &lt;strong&gt;限制、计算、隔离一组进程的资源使用&lt;/strong&gt;（CPU，内存，磁盘 I/O，网络等）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1424-辅助组件&quot;&gt;14.2.4 辅助组件&lt;/h3&gt;

&lt;h4 id=&quot;journald&quot;&gt;journald&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-journald&lt;/code&gt; 该守护进程负责把事件保存到日志中，使用只可追加的二进制文件做为日志文件。系统管理员可以选择是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-journald&lt;/code&gt; 来保存系统事件的日志，还是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;syslog-ng&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;rsyslog&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;logind&quot;&gt;logind&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-logind&lt;/code&gt; 守护进程以多种方式 &lt;strong&gt;管理用户登陆和座位&lt;/strong&gt;（seats），它是一个集成的登陆管理器，增强了多座位（Multi-Seat）的支持，替代了 ConsoleKit（已不再维护）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;【 Multi-Seat 】一个座位，seat，由分配给特定工作空间的所有硬件设备组成，通常至少要包括键盘、鼠标，也可包含摄像头、声卡等。多座位，Multi-Seat，多座系统允许多个独立的座位，这些座位都能独立地、同时被不同的用户使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;networkd&quot;&gt;networkd&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;networkd&lt;/code&gt; 守护进程用于控制网络接口的配置。&lt;/p&gt;

&lt;h4 id=&quot;tmpfiles&quot;&gt;tmpfiles&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-tmpfiles&lt;/code&gt; 工具用于临时文件和临时目录的创建和清理，这些临时文件和临时目录经常只在启动时运行一次，之后便是以一定的时间间隔来运行了。&lt;/p&gt;

&lt;h4 id=&quot;timedated&quot;&gt;timedated&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-timedated&lt;/code&gt; 守护进程用于控制与时间相关的设置，如系统时间、系统时区，或在 UTC 与本地时间系统时钟之间做出选择。可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;D-Bus&lt;/code&gt; 来访问该守护进程。&lt;/p&gt;

&lt;h4 id=&quot;udevd&quot;&gt;udevd&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 是内核的设备管理器，用于控制 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt; 目录，以及在添加删除设备时用户空间的所有行为，包括固件的加载。&lt;/p&gt;

&lt;h4 id=&quot;libudev&quot;&gt;libudev&lt;/h4&gt;

&lt;p&gt;这是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 的标准库，允许第三方程序查询 &lt;code class=&quot;highlighter-rouge&quot;&gt;udev&lt;/code&gt; 的资源。&lt;/p&gt;

&lt;h4 id=&quot;systemd-boot&quot;&gt;systemd-boot&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemd-boot&lt;/code&gt; 是启动管理器。&lt;/p&gt;

&lt;h2 id=&quot;143-单元的配置文件&quot;&gt;14.3 单元的配置文件&lt;/h2&gt;

&lt;h3 id=&quot;1431-概述&quot;&gt;14.3.1 概述&lt;/h3&gt;

&lt;p&gt;每一个单元都有一个配置文件，告诉 Systemd 怎么启动这个单元。配置文件有时也称为 &lt;strong&gt;单元文件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Systemd &lt;strong&gt;默认从目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/system/&lt;/code&gt; 读取配置文件&lt;/strong&gt;。但是，里面存放的大部分文件都是 &lt;strong&gt;符号链接&lt;/strong&gt;，指向目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/systemd/system/&lt;/code&gt;，真正的配置文件存放在这里。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl enable&lt;/code&gt; 命令用于在上面两个目录之间，&lt;strong&gt;建立符号链接&lt;/strong&gt; 关系。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo systemctl enable clamd@scan.service
# 等同于
$ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果配置文件里面设置了开机启动，&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl enable&lt;/code&gt; 命令相当于 &lt;strong&gt;激活开机启动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;与之对应的，&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl disable&lt;/code&gt; 命令用于在两个目录之间，撤销符号链接关系，相当于 &lt;strong&gt;撤销开机启动&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo systemctl disable clamd@scan.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置文件的 &lt;strong&gt;后缀名&lt;/strong&gt;，就是该 &lt;strong&gt;单元的种类&lt;/strong&gt;，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;sshd.socket&lt;/code&gt;。&lt;strong&gt;如果省略&lt;/strong&gt;，Systemd &lt;strong&gt;默认后缀名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.service&lt;/code&gt;&lt;/strong&gt;，所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;sshd&lt;/code&gt; 会被理解成 &lt;code class=&quot;highlighter-rouge&quot;&gt;sshd.service&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;支持 Systemd 的程序在安装的时候，会自动在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/systemd/system&lt;/code&gt; 目录添加一个配置文件。&lt;/p&gt;

&lt;h3 id=&quot;1432-配置文件的状态&quot;&gt;14.3.2 配置文件的状态&lt;/h3&gt;

&lt;p&gt;列出所有配置文件：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-unit-files&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;列出指定类型的配置文件：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-unit-files --type=service&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systemctl list-unit-files

UNIT FILE              STATE
chronyd.service        enabled
clamd@.service         static
clamd@scan.service     disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;enabled&quot;&gt;enabled&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;启用&lt;/strong&gt;，已建立启动链接，开机自动启动&lt;/p&gt;

&lt;h4 id=&quot;disabled&quot;&gt;disabled&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;禁用&lt;/strong&gt;，没建立启动链接，开机不会自动启动，但可由其他服务激活，也可以手动运行。&lt;/p&gt;

&lt;h4 id=&quot;static&quot;&gt;static&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;静态&lt;/strong&gt;，其配置文件没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt; 部分，所以无法被启用。但可以被其他单元激活，通常作为其它单元的依赖。&lt;/p&gt;

&lt;h4 id=&quot;masked&quot;&gt;masked&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;屏蔽&lt;/strong&gt;，该配置文件被禁止建立启动链接。彻底禁用，任何情况都无法运行。&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;注意，从配置文件的状态无法看出，该单元是否正在运行。必须用 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl status bluetooth.service&lt;/code&gt; 命令查看。一旦 &lt;strong&gt;修改&lt;/strong&gt; 了配置文件，就要让 SystemD &lt;strong&gt;重新加载&lt;/strong&gt; 配置文件，然后 &lt;strong&gt;重新启动单元&lt;/strong&gt;，否则修改不会生效。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo systemctl daemon-reload
$ sudo systemctl restart httpd.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1433-配置文件的格式&quot;&gt;14.3.3 配置文件的格式&lt;/h3&gt;

&lt;p&gt;配置文件就是普通的文本文件，可以用文本编辑器打开。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl cat&lt;/code&gt; 命令可以查看配置文件的内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systemctl cat atd.service
&amp;gt;
[Unit]
Description=ATD daemon
&amp;gt;
[Service]
Type=forking
ExecStart=/usr/bin/atd
&amp;gt;
[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;单元文件的内部结构是由多个区块组成的，每个区块的第一行，是用 &lt;strong&gt;方括号表示的区块名&lt;/strong&gt;，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;[Unit]&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1434-配置文件的区块&quot;&gt;14.3.4 配置文件的区块&lt;/h3&gt;

&lt;p&gt;为表达方便，下文中用 “我” 来代表当前单元。&lt;/p&gt;

&lt;p&gt;修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl daemon-reload&lt;/code&gt;  重新加载配置文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl restart foobar&lt;/code&gt;  重启相关服务&lt;/p&gt;

&lt;h4 id=&quot;通用区块&quot;&gt;通用区块&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;区块的名称&lt;/strong&gt; 是系统预定义的，&lt;strong&gt;区分大小写&lt;/strong&gt;。如果需要增加非标准的区块用于自定义功能，可以在区块名称前加 &lt;code class=&quot;highlighter-rouge&quot;&gt;X-&lt;/code&gt; 前缀。&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;每个区块内部是一些 &lt;strong&gt;等号连接的键值对&lt;/strong&gt;。而且键值对的 &lt;strong&gt;等号两侧不能有空格&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在发生文件覆盖时，通过给指令分配空值，可以重置该变量。如 &lt;code class=&quot;highlighter-rouge&quot;&gt;Requires=&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;systemd 允许在配置文件中使用比较灵活宽松的配置。如对于布尔值，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;yes&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;on&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; 等代表真。&lt;/p&gt;

&lt;h5 id=&quot;unit-区块&quot;&gt;[Unit] 区块&lt;/h5&gt;

&lt;p&gt;通常是配置文件的 &lt;strong&gt;第一个区块&lt;/strong&gt;，用来定义 &lt;strong&gt;单元的元数据&lt;/strong&gt;，以及配置 &lt;strong&gt;与其他单元的关系&lt;/strong&gt;。它的主要字段如下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Description&lt;/code&gt;：简短描述&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Documentation&lt;/code&gt;：文档地址&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Requires&lt;/code&gt;：我 &lt;strong&gt;必须要&lt;/strong&gt; 这些单元，它们不运行，我会启动失败&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Wants&lt;/code&gt;：我 &lt;strong&gt;想要&lt;/strong&gt; 这些单元，没有就算了，我不会启动失败&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BindsTo&lt;/code&gt;：我和它 &lt;strong&gt;绑定&lt;/strong&gt;，它退出，我就停止运行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Before&lt;/code&gt;：我必须在这些单元 &lt;strong&gt;之前启动&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;After&lt;/code&gt;：我必须在这些单元 &lt;strong&gt;之后启动&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Conflicts&lt;/code&gt;：我和它们冲突，&lt;strong&gt;不能同时运行&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Condition...&lt;/code&gt;：这些条件必须满足，否则我 &lt;strong&gt;优雅地忽略&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Assert...&lt;/code&gt;：这些条件必须满足，否则会 &lt;strong&gt;报错&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;install-区块&quot;&gt;[Install] 区块&lt;/h5&gt;

&lt;p&gt;通常是配置文件的 &lt;strong&gt;最后一个区块&lt;/strong&gt;，用来 &lt;strong&gt;定义如何启动&lt;/strong&gt;，以及 &lt;strong&gt;是否开机启动&lt;/strong&gt;。它的主要字段如下。下文中的 “我” 指当前单元。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WantedBy&lt;/code&gt;：这些目标有我更好，没我也行。&lt;/p&gt;

    &lt;p&gt;它的值是一个或多个 &lt;strong&gt;目标&lt;/strong&gt;（target），当前单元激活时（enable）符号链接会放入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/system&lt;/code&gt; 目录下面以 &lt;code class=&quot;highlighter-rouge&quot;&gt;目标名.wants&lt;/code&gt; 后缀命名的子目录中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RequiredBy&lt;/code&gt;：这些目标有我才能运行&lt;/p&gt;

    &lt;p&gt;它的值是一个或多个 &lt;strong&gt;目标&lt;/strong&gt;，当前单元激活时符号链接会放入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/system&lt;/code&gt; 目录下面以 &lt;code class=&quot;highlighter-rouge&quot;&gt;目标名.required&lt;/code&gt; 后缀命名的子目录中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Alias&lt;/code&gt;：我的 &lt;strong&gt;别名&lt;/strong&gt;，可用于诸多 &lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl&lt;/code&gt; 命令中&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Also&lt;/code&gt;：当前单元激活（enable）时，会被同时激活的其他 Unit&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;特定单元的区块&quot;&gt;特定单元的区块&lt;/h4&gt;

&lt;p&gt;夹在 [Unit] 和 [Install] 中间的区块，每种单元有着不同的内容，这些区块大多用于设定其特定种类的参数。&lt;/p&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;device&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;snapshot&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt; 这些区块不属于特定种类。&lt;/p&gt;

&lt;h5 id=&quot;service-区块&quot;&gt;[Service] 区块&lt;/h5&gt;

&lt;p&gt;用于进行 &lt;strong&gt;服务&lt;/strong&gt; 的配置，只有 Service 类型的单元才有这个区块。它的主要字段如下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;：定义 &lt;strong&gt;启动时的进程行为&lt;/strong&gt;。它有以下几种值。
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type=simple&lt;/code&gt;：默认值，执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStart&lt;/code&gt; 指定的命令，启动主进程&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type=forking&lt;/code&gt;：以 fork 方式从父进程创建子进程，创建后父进程会立即退出&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type=oneshot&lt;/code&gt;：一次性进程，Systemd 会等当前服务退出，再继续往下执行&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type=dbus&lt;/code&gt;：当前服务通过 D-Bus 启动&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type=notify&lt;/code&gt;：我启动完毕，会通知 &lt;code class=&quot;highlighter-rouge&quot;&gt;Systemd&lt;/code&gt;，再继续往下执行&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type=idle&lt;/code&gt;：其他所有作业执行完毕才会运行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStart&lt;/code&gt;：&lt;strong&gt;启动我&lt;/strong&gt; 的命令，设置命令的完整路径及参数，文件中只能指定一次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStartPre&lt;/code&gt;：&lt;strong&gt;启动我之前要执行的命令&lt;/strong&gt;，可指定多次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStartPost&lt;/code&gt;：&lt;strong&gt;启动我之后要执行的命令&lt;/strong&gt;，可指定多次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecReload&lt;/code&gt;：&lt;strong&gt;重新加载我的配置文件&lt;/strong&gt; 时要执行的命令&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStop&lt;/code&gt;：&lt;strong&gt;暂停我&lt;/strong&gt; 时要执行的命令，如果不指定，服务被暂停时，服务进程会立即被终止&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecStopPost&lt;/code&gt;：&lt;strong&gt;暂停我之后要执行的命令&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RestartSec&lt;/code&gt;：如果启用了 &lt;strong&gt;间隔自动重启&lt;/strong&gt;，该参数用于设置 &lt;strong&gt;间隔的秒数&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Restart&lt;/code&gt;：定义 &lt;strong&gt;何种情况 Systemd 会自动重启我&lt;/strong&gt;，可用值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;always&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;on-success&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;on-failure&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;on-abnormal&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;on-abort&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;on-watchdog&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutSec&lt;/code&gt;：定义 &lt;strong&gt;Systemd 停止我之前等待的秒数&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Environment&lt;/code&gt;：指定环境变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，对于某些特殊的服务类型，还有一些附加的指令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RemainAfterExit=&lt;/code&gt; 通常用于 &lt;code class=&quot;highlighter-rouge&quot;&gt;oneshot&lt;/code&gt; 类型的服务，即使进程退出了也应该视该服务为激活。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PIDFile=&lt;/code&gt; 服务类别为 &lt;code class=&quot;highlighter-rouge&quot;&gt;forking&lt;/code&gt; 时，被监视的主要子进程 PID 会保存在一个文件中，该命令用于设置该文件的路径。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BusName=&lt;/code&gt; 当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dbus&lt;/code&gt; 服务类型时，该参数用于设置 bus name。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NotifyAccess=&lt;/code&gt; 当服务类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 时，该参数用于指定该服务使用哪个套接字来监听通知消息，可选值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt;。默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;，即忽略所有状态消息。&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 表示监听主进程发出的消息，&lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt; 表示使用该服务 cgroup 中的所有成员来监听。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.unit.html&quot;&gt;【 更多区块介绍 】&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;144-target&quot;&gt;14.4 Target&lt;/h2&gt;

&lt;p&gt;启动计算机的时候，需要启动大量的单元。如果每一次启动，都要一一写明本次启动需要哪些单元，显然非常不方便。Systemd 的解决方案就是 Target。&lt;/p&gt;

&lt;p&gt;简单说，&lt;strong&gt;Target 就是一个单元组&lt;/strong&gt;，包含许多相关的单元 。启动某个 Target 的时候，Systemd 就会启动里面所有的单元。&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;从这个意义上说，Target 这个概念类似于 “状态点”，&lt;strong&gt;启动某个 Target 就好比启动到某种状态&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;传统的 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 启动模式里面，有运行级的概念，跟 Target 的作用很类似。不同的是，运行级是互斥的，&lt;strong&gt;不可能多个运行级同时启动&lt;/strong&gt;，但是 &lt;strong&gt;多个 Target 可以同时启动&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1441-常用命令&quot;&gt;14.4.1 常用命令&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-unit-files --type=target&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看当前系统的所有 Target&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl list-dependencies multi-user.target&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看一个 Target 包含的所有单元&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl get-default&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看启动时的默认 Target&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl set-default multi-user.target&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置启动时的默认 Target&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl isolate multi-user.target&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关闭前一个 Target 里面所有不属于后一个 Target 的进程。切换 Target 时，默认不关闭前一个 Target 启动的进程，&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl isolate&lt;/code&gt; 命令会改变这种行为，&lt;/p&gt;

&lt;h3 id=&quot;1442-target-与-传统运行级的对应关系&quot;&gt;14.4.2 Target 与 传统运行级的对应关系&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;runlevel&lt;/td&gt;
      &lt;td&gt;target&lt;/td&gt;
      &lt;td&gt;符号链接指向&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 0&lt;/td&gt;
      &lt;td&gt;runlevel0.target&lt;/td&gt;
      &lt;td&gt;poweroff.target&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 1&lt;/td&gt;
      &lt;td&gt;runlevel1.target&lt;/td&gt;
      &lt;td&gt;rescue.target&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 2&lt;/td&gt;
      &lt;td&gt;runlevel2.target&lt;/td&gt;
      &lt;td&gt;multi-user.target&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 3&lt;/td&gt;
      &lt;td&gt;runlevel3.target&lt;/td&gt;
      &lt;td&gt;multi-user.target&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 4&lt;/td&gt;
      &lt;td&gt;runlevel4.target&lt;/td&gt;
      &lt;td&gt;multi-user.target&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 5&lt;/td&gt;
      &lt;td&gt;runlevel5.target&lt;/td&gt;
      &lt;td&gt;graphical.target&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Runlevel 6&lt;/td&gt;
      &lt;td&gt;runlevel6.target&lt;/td&gt;
      &lt;td&gt;reboot.target&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;1443-target-与-init-进程的主要差别&quot;&gt;14.4.3 Target 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 进程的主要差别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;默认的运行级（在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt; 文件设置）被默认的 Target 取代，位置是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/system/default.target&lt;/code&gt;，通常软链接到 &lt;code class=&quot;highlighter-rouge&quot;&gt;graphical.target&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;multi-user.target&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;启动脚本的位置，以前是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/init.d&lt;/code&gt; 目录，软链接到不同的运行级目录 （如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rc3.d&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rc5.d&lt;/code&gt; 等），现在则存放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/systemd/system&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/system&lt;/code&gt; 目录。&lt;/li&gt;
  &lt;li&gt;配置文件的位置，以前 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 进程的配置文件是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;，各种服务的配置文件存放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sysconfig&lt;/code&gt; 目录。现在的配置文件主要存放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/systemd&lt;/code&gt; 目录，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd&lt;/code&gt; 目录里面的修改可以覆盖原始设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1444-target-的配置文件&quot;&gt;14.4.4 Target 的配置文件&lt;/h3&gt;

&lt;p&gt;注意，Target 配置文件里面 &lt;strong&gt;没有启动命令&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;145-日志管理&quot;&gt;14.5 日志管理&lt;/h2&gt;

&lt;p&gt;Systemd &lt;strong&gt;统一管理所有单元的启动日志&lt;/strong&gt;。带来的好处就是，可以只用 &lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/systemd/journald.conf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl&lt;/code&gt; 功能强大，用法非常多。&lt;/p&gt;

&lt;h3 id=&quot;常用命令&quot;&gt;常用命令&lt;/h3&gt;

&lt;p&gt;查看所有日志（默认情况下 ，只保存本次启动的日志）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看内核日志（不显示应用日志）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -k&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看系统本次启动的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -b -0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看上一次启动的日志（需更改设置）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -b -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看指定时间的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --since &quot;20 min ago&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --since yesterday&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示尾部的最新 10 行日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -n&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示尾部指定行数的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -n 20&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实时滚动显示最新日志&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -f&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看指定服务的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl /usr/lib/systemd/systemd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看指定进程的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl _PID=1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看某个路径的脚本的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl /usr/bin/bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看指定用户的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl _UID=33 --since today&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看某个单元 的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -u nginx.service&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -u nginx.service --since today&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实时滚动显示某个单元的最新日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -u nginx.service -f&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;合并显示多个单元的日志：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;journalctl -u nginx.service -u php-fpm.service --since today&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看指定优先级（及其以上级别）的日志，共有8级：&lt;/p&gt;

&lt;p&gt;0: emerg&lt;/p&gt;

&lt;p&gt;1: alert&lt;/p&gt;

&lt;p&gt;2: crit&lt;/p&gt;

&lt;p&gt;3: err&lt;/p&gt;

&lt;p&gt;4: warning&lt;/p&gt;

&lt;p&gt;5: notice&lt;/p&gt;

&lt;p&gt;6: info&lt;/p&gt;

&lt;p&gt;7: debug&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -p err -b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;日志默认分页输出，–no-pager 改为正常的标准输出：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --no-pager&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以 JSON 格式（单行）输出：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -b -u nginx.service -o json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以 JSON 格式（多行）输出，可读性更好：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl -b -u nginx.serviceqq -o json-pretty&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示日志占据的硬盘空间：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --disk-usage&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定日志文件占据的最大空间：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --vacuum-size=1G&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定日志文件保存多久：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo journalctl --vacuum-time=1years&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;145-centos-7x-默认启动的服务简易说明&quot;&gt;14.5 CentOS 7.x 默认启动的服务简易说明&lt;/h2&gt;

&lt;p&gt;CentOS 7 默认启动的服务&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;服务名称&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;可关闭&lt;/th&gt;
      &lt;th&gt;服务类别&lt;/th&gt;
      &lt;th&gt;功能简介&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;abrtd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;用于监控应用程序的崩溃。当崩溃发生时，它会收集错误信息，然后根据应用程序的类型及配置文件的参数采取对应的措施。通过插件可以把错误信息通过邮件、FTP 等发给管理员&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;accounts-daemon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关闭&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;是 AccountsService 的一部分，允许程序获取并修改用户帐户信息。有潜在安全风险&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;alsa-X&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关闭&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;与音效有关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;atd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;一次性计划任务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;auditd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;SELinux 依靠它监控授权验证情况，日志为 /var/log/audit/audit.log&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;avahi-daemon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关闭&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;通过部署苹果公司的 Zeroconf 架构，自动的分析与管理网络。常用于移动设备&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;brandbot rhel-*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;开机环境检测，网络启动关闭&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;chronyd ntpd ntpdate&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;通过网络校正时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cpupower&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;一组为辅助 CPU 调频而设计的用户空间工具&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;crond&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;计划任务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cups&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关闭&lt;/td&gt;
      &lt;td&gt;管理打印机，包括网络打印&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dbus&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;提供简便进程间通信的消息总线系统。包含一个能以全系统或者针对一个用户会话运行的守护进程，和一系列提供与 D-Bus 通信的库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dm-event multipathd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;用于监控设备映射&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dmraid-activation mdmonitor&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;用来启动软 RAID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dracut-shutdown&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;与开机过程有关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ebtables&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统/网络&lt;/td&gt;
      &lt;td&gt;防火墙，如果启用了 firewalld，可以关闭&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;emergency rescue&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;进入紧急模式或者是救援模式的服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;firewalld&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统/网络&lt;/td&gt;
      &lt;td&gt;新的防火墙服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;gdm&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;GNOME显示环境的管理器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;getty@&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;命令行服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;hyper_ksm_libvirt* vmtoolsd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;虚拟机相关的一系列服务，不用虚拟机可以关闭&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;irqbalance&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;适用于多核心的硬件，用于自动分配系统中断&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;iscsi*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;挂载网络磁盘&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;kdump&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可关闭&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;记录 Linux 核心的出错信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;lvm2-*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;LVM 相关的多个服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;microcode&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;Intel 的 CPU 提供的微指令集，如果没有下载 Intel 的指令集文件，可以关闭&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ModemManager network NetworkManager*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统/网络&lt;/td&gt;
      &lt;td&gt;Modem、网络设置等服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;quotaon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;Quota 服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;rc-local&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;兼容于 /etc/rc.d/rc.local 的调用方式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;rsyslog&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;记录系统产生的各项信息， 包括 /var/log/messages 等日志&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;smartd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;自动监测硬盘状态，发生问题自动的反馈信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;sysstat&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;一体化的 Linux 系统性能和使用活动监控工具&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;systemd-*&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;系统运行过程所需要的服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;plymount* upower&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保留&lt;/td&gt;
      &lt;td&gt;系统&lt;/td&gt;
      &lt;td&gt;图形界面有关的一些服务&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CentOS 7 默认不会启动的服务&lt;/p&gt;

&lt;p&gt;所有服务均为网络服务：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;服务名称&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dovecot&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提供 POP3/IMAP 邮件服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;httpd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;www server&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;named&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DNS Server&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;nfs nfs-server&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Network Filesystem Server&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;smb nmb&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;模拟 Windows 网络邻居&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;vsftpd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FTP Server&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;sshd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SSH Server&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;rpcbind&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实现 RPC 协议的重要服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;postfix&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;邮件服务器，系统产生的邮件也是通过它发送&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><category term="守护进程" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 13. SELinux</title><link href="/linux/linux.selinux/" rel="alternate" type="text/html" title="Linux 基础 - 13. SELinux" /><published>2015-01-13T00:00:00+08:00</published><updated>2015-01-13T00:00:00+08:00</updated><id>/linux/linux.selinux</id><content type="html" xml:base="/linux/linux.selinux/">&lt;h2 id=&quot;131-安全访问控制机制&quot;&gt;13.1 安全访问控制机制&lt;/h2&gt;

&lt;p&gt;在安全访问中，访问的发起者称为 &lt;strong&gt;主体&lt;/strong&gt;，被访问的资源称为 &lt;strong&gt;客体&lt;/strong&gt;。&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;😈 为了减少输入时中英文切换的次数，偷懒一下，下文中，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SL&lt;/code&gt; 表示 SELinux，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;L 用户&lt;/code&gt; 表示 Linux 用户，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SL 用户&lt;/code&gt; 表示 SELinux 用户。&lt;/p&gt;

&lt;h3 id=&quot;1311-dac&quot;&gt;13.1.1 DAC&lt;/h3&gt;

&lt;p&gt;DAC，Discretionary Access Control，&lt;strong&gt;自主访问控制&lt;/strong&gt;，Linux 传统的访问控制属于这样的机制。&lt;/p&gt;

&lt;p&gt;DAC &lt;strong&gt;控制的主体为用户&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自主&lt;/strong&gt;：访问控制由文件或进程的 &lt;strong&gt;所有者决定&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;只使用 UID、GID 来控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传统文件权限中，帐号分为系统管理员与普通用户，对文件件资源的访问权限决定于 rwx 的设置。根据对象所属的分组来限制对对象的访问。&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;DAC 最大的缺点是它 &lt;strong&gt;无法分离用户和进程&lt;/strong&gt;，进程能够继承用户的访问控制，&lt;strong&gt;授权用户的所有进程会自动获得授权&lt;/strong&gt;，包括侵入该用户名下的恶意程序。&lt;/p&gt;

&lt;p&gt;root 为默认的超级用户，属于它的进程一旦被攻破会极度危险。&lt;/p&gt;

&lt;h3 id=&quot;1312-mac&quot;&gt;13.1.2 MAC&lt;/h3&gt;

&lt;p&gt;MAC，Mandatory Access Control，&lt;strong&gt;强制访问控制&lt;/strong&gt;，操作系统会限制进程对客体的访问或操作，SELinux 属于这样的控制机制。&lt;/p&gt;

&lt;p&gt;主体和客体都有一组安全属性，操作系统会检查这些标签，以决定请求的操作是否允许进行。&lt;/p&gt;

&lt;p&gt;MAC &lt;strong&gt;控制的主体为进程&lt;/strong&gt;，不再是用户。&lt;/p&gt;

&lt;h4 id=&quot;mac-的特性&quot;&gt;MAC 的特性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;系统级别&lt;/strong&gt; 的访问控制，强制实施
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;用户无法超越策略的限制&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;颗粒级别&lt;/strong&gt; 的控制&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;最小权限原则&lt;/strong&gt;：仅授予足够完成具体任务的权限&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客体为系统资源&lt;/strong&gt;，如文件、目录、共享内存、套接字、网络主机等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;任何主体&lt;/strong&gt; 对 &lt;strong&gt;任何客体&lt;/strong&gt; 实施的 &lt;strong&gt;任何操作&lt;/strong&gt; 都会被规则检查，以确定是否有权进行该操作&lt;/li&gt;
  &lt;li&gt;MAC 是近年的主流访问控制方式&lt;/li&gt;
  &lt;li&gt;通过 &lt;strong&gt;对比各自身上的标签&lt;/strong&gt;，决定主体是否有权访问客体。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;决定访问权限的&lt;/strong&gt; 不再是主体和客体，而 &lt;strong&gt;是访问控制策略&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;SELinux 中 &lt;strong&gt;没有默认的超级用户&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 SELinux 来说，安全属性即安全上下文。内核中的安全服务器使用安全策略为访问授权。&lt;/p&gt;

&lt;h4 id=&quot;selinux-支持两种形式的-mac&quot;&gt;SELinux 支持两种形式的 MAC：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;类型强制&lt;/strong&gt;，Type Enforcement，TE：运行在域中的进程及其对客体的行为受策略的控制。与基于角色的访问控制 RBAC 一起作为一般用途使用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;多级安全&lt;/strong&gt;，Multi-Level Security，MLS：基于 Bell-La Padula，BLP 模型，用于特别需要用多级别来控制敏感信息的场景。把多级别加入上下文以后，可以实现策略中对 “向下不能写” 及 “向上不能读” 的高级别控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mls--mcs&quot;&gt;MLS / MCS&lt;/h4&gt;

&lt;p&gt;MLS：Multi-Level Security，多级别安全策略。&lt;/p&gt;

&lt;p&gt;MCS：Multi-Category Security，多类型安全策略。&lt;/p&gt;

&lt;p&gt;SELinux 同时支持 MLS 和 MCS，只需在上下文中增加一个字段即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/security-levels.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图显示的是一个文件服务器中，不同文件的安全级别。安全级别是严格地按层次划分的，并形成一个 BLP 模型，进程只能对同级别的文件进行读取；对更高级别的文件，它只能写入；对更低级别的，它只能读取。即 &lt;strong&gt;向下不能写，向上不能读&lt;/strong&gt;。确保了进程可以向上复制文件，但之后不可从上面读取，除非上到那一级。进程也无法向低级别写入文件，以避免机密信息向下泄漏。&lt;/p&gt;

&lt;p&gt;MLS 和 MCS 的特别之处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以为进程和客体分配一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;最低级别 - 最高级别&lt;/code&gt; 的范围&lt;/li&gt;
  &lt;li&gt;安全级别可以做的更复杂，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;分级的敏感度 + 不分级的类别&lt;/code&gt;，其中类别可省略&lt;/li&gt;
  &lt;li&gt;允许进程访问客体由应用于安全级别的 “显性” 规则管理&lt;/li&gt;
  &lt;li&gt;信任的进程可被授予特权，允许它们绕过 BLP 规则做策略允许的任何操作&lt;/li&gt;
  &lt;li&gt;有些客体不支持单独的读/写功能，因为它们需要在网络等情况下读取/响应&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前，MLS/MCS 服务更多地用于维护应用程序的隔离，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚拟机使用 MCS，可以允许每个虚拟机都在自己的域中运行，让它们彼此隔离&lt;/li&gt;
  &lt;li&gt;安卓设备使用动态生成的 MCS，这样，代表一个用户运行的应用无法读写另一个用户在同一个应用创建的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;mlsmcs-安全范围的表示方法&quot;&gt;MLS/MCS 安全范围的表示方法&lt;/h5&gt;

&lt;p&gt;敏感度是分级的，类别是不分级的。不连续的类别之间可以用逗号分隔，连续的类别可以用句点分隔。&lt;/p&gt;

&lt;h6 id=&quot;单个级别的表示&quot;&gt;单个级别的表示&lt;/h6&gt;

&lt;p&gt;每个级别可以用 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;敏感度:类别&lt;/code&gt;&lt;/strong&gt; 格式来描述，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0:c0&lt;/code&gt;。其中 “类别” 是可选的，如果 &lt;strong&gt;没有类别&lt;/strong&gt;，可以单独用 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;敏感度&lt;/code&gt;&lt;/strong&gt; 来表示某个级别，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0&lt;/code&gt;。&lt;/p&gt;

&lt;h6 id=&quot;级别范围&quot;&gt;级别范围&lt;/h6&gt;

&lt;p&gt;级别范围是用一对级别来描述的，如果是 &lt;strong&gt;多级&lt;/strong&gt;，格式为 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;最低级-最高级&lt;/code&gt;&lt;/strong&gt;，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0:c1,c5-s5:c1,c5&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0:c1.c100-s5:c1.c100&lt;/code&gt;；如果是 &lt;strong&gt;单级&lt;/strong&gt;，格式为 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;最低级&lt;/code&gt;&lt;/strong&gt;，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0:c1,c5&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user:role:type:sensitivity[:category,...]  -  sensitivity [:category,...]
---------------▼------------------------▼-----▼-------------------------▼
               |         level          |  -  |        level            |
               |                                                        |
                                        |range|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;132-selinux-简介&quot;&gt;13.2 SELinux 简介&lt;/h2&gt;

&lt;p&gt;Security Enhanced Linux&lt;/p&gt;

&lt;p&gt;SELinux 是内建在 Linux 中的主要的 MAC 机制。&lt;/p&gt;

&lt;p&gt;SELinux 是对 &lt;strong&gt;进程、文件、用户&lt;/strong&gt; 的权限进行详细设置的 &lt;strong&gt;内核模块&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;SELinux 是通过 MAC 方式来管控进程，控制的 &lt;strong&gt;主体是进程&lt;/strong&gt;，&lt;strong&gt;客体是文件资源&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;SELinux 允许使用不同类型的策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;基于角色&lt;/strong&gt; 的访问控制，Role-Based Access Control (&lt;strong&gt;RBAC&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;基于类型匹配&lt;/strong&gt; 的访问控制，类型强制，Type Enforcement (&lt;strong&gt;TE&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;最细致的 &lt;strong&gt;多级别&lt;/strong&gt; 访问控制，Multi-Level Security (&lt;strong&gt;MLS&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1321-selinux-的优点&quot;&gt;13.2.1 SELinux 的优点&lt;/h3&gt;

&lt;h4 id=&quot;所有的进程和文件都有类型标签&quot;&gt;所有的进程和文件都有类型标签&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt; 为进程定义了一个 &lt;strong&gt;域&lt;/strong&gt;，为文件定义了一个 &lt;strong&gt;类型&lt;/strong&gt;。不同的进程分别运行于各自的域中，SELinux 策略规则定义了进程应如何与文件进行交互，进程间如何交互。只有当 SELinux 规则中有允许放行的条目时，访问才能放行。&lt;/p&gt;

&lt;h4 id=&quot;颗粒化的访问控制&quot;&gt;颗粒化的访问控制&lt;/h4&gt;

&lt;p&gt;传统的 Linux 权限控制是基于 UID 和 GID，用户自己有裁量权，而 SELinux 访问的决策是基于所有的可用信息，如 SL 用户、角色、类型、级别等。&lt;/p&gt;

&lt;h4 id=&quot;selinux-策略是全局强制性的&quot;&gt;SELinux 策略是全局强制性的&lt;/h4&gt;

&lt;p&gt;策略在系统全局强制实施，不是由用户自行决定的。&lt;/p&gt;

&lt;h4 id=&quot;减少特权升级攻击的漏洞&quot;&gt;减少特权升级攻击的漏洞&lt;/h4&gt;

&lt;p&gt;因为进程运行于域中，因此彼此隔离，因为 SELinux 策略规则定义了进程应如何访问文件及其它进程，如果某个进程被攻破，攻击者仅能访问该进程的普通功能，仅能访问该进程有权访问的文件。例如，如果 Apache HTTP Server 被攻破，攻击者无法用该进程来读取用户家目录的文件，除非加入专门的规则来放行。&lt;/p&gt;

&lt;h4 id=&quot;selinux-可用来强化数据机密性和完整性&quot;&gt;SELinux 可用来强化数据机密性和完整性&lt;/h4&gt;

&lt;p&gt;SELinux 可用来强化数据机密性和完整性，也可以避免进程接受不可信的输入。&lt;/p&gt;

&lt;p&gt;虽然有以上优点，SELinux 并非杀毒软件，无法替代密码、防火墙或其它的安全系统，它并非大而全的安全解决方案。&lt;/p&gt;

&lt;p&gt;SELinux 被设计 &lt;strong&gt;用来强化现有的安全解决方案&lt;/strong&gt;，而不是替代它们。&lt;/p&gt;

&lt;h3 id=&quot;1322-selinux-架构&quot;&gt;13.2.2 SELinux 架构&lt;/h3&gt;

&lt;p&gt;SELinux 是 Linux 内核中的一个 &lt;strong&gt;安全模块&lt;/strong&gt;，由 &lt;strong&gt;可加载的策略规则&lt;/strong&gt; 驱动。当发生与安全相关的访问时，如进程尝试打开文件，&lt;strong&gt;操作会被 SELinux 在内核中截获&lt;/strong&gt;。如果 SELinux 的策略规则允许该操作，则继续，否则，会返回给系统一个 &lt;strong&gt;权限被拒绝&lt;/strong&gt;（Permission Denied）的错误，然后给审计子系统（audit subsystem）发送一个拒绝消息。这样，管理员可以研究日志中的拒绝消息，以确认安全规则不会被攻破。&lt;/p&gt;

&lt;p&gt;SELinux 的 &lt;strong&gt;决策&lt;/strong&gt;，如放行还是拒绝访问，是 &lt;strong&gt;会被缓存&lt;/strong&gt; 的。该缓存即访问向量缓存 &lt;strong&gt;AVC&lt;/strong&gt;，有了这些缓存的决策，就无需频繁地检查 SELinux 策略规则，提升了性能。&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;SELinux 的规则是在 DAC 规则之后检查的&lt;/strong&gt;。因此，如果 DAC 规则首先拒绝了访问，则无需再使用 SELinux 策略规则来检查了。&lt;/p&gt;

&lt;h3 id=&quot;1323-selinux-核心要素&quot;&gt;13.2.3 SELinux 核心要素&lt;/h3&gt;

&lt;h4 id=&quot;-selinux-顶层核心要素&quot;&gt;🍬 SELinux 顶层核心要素：&lt;/h4&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/selinux-core.png&quot; alt=&quot;SELinux 顶层核心要素&quot; /&gt;
  
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;主体&lt;/strong&gt;：Subject，对客体实施操作，如读取文件&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客体管理器&lt;/strong&gt;：Object Manager，根据规则 &lt;strong&gt;强制实施&lt;/strong&gt; 对客体的具体操作。他们可以存在于内核空间或用户空间，决定于软件是 Linux 内置的还是第三方的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;安全服务器&lt;/strong&gt;： Security Server，它基于规则，对主体是否有权对客体操作 &lt;strong&gt;做出决策&lt;/strong&gt;。嵌于内核中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;安全策略&lt;/strong&gt;：Security Policy，使用策略语言来描述 &lt;strong&gt;具体的规则&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;访问向量缓存&lt;/strong&gt;：Access Vector Cache，AVC，&lt;strong&gt;缓存&lt;/strong&gt; 所有的安全服务器做出的 &lt;strong&gt;决策&lt;/strong&gt;，以此提升对请求的响应速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-selinux-顶层架构&quot;&gt;🍬 SELinux 顶层架构：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2-high-level-arch.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从下往上分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;安全服务器&lt;/strong&gt; 内嵌于内核中，策略会从用户空间借助一系列函数被加载。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;客体管理器&lt;/strong&gt; 和 &lt;strong&gt;访问向量缓存&lt;/strong&gt; 可以存在于：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;内核空间&lt;/strong&gt;：存在于内核空间的客体管理器用于控制内核的服务，如文件、目录、套接字、进程间通信等，是由一些勾子提供的，这些勾子通过 Linux 安全模块框架挂接到 SELinux 子系统中。内核的 AVC 服务用于缓存安全服务器对基于内核的对象管理器的响应，从而加快未来访问决策的速度。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;用户空间&lt;/strong&gt;：存在于用户空间的客体管理器是与需要支持 MAC 的应用程序或服务一起提供的，这些客体管理器使用内建于 SELinux 函数库的 AVC 服务，然而，如果需要的话，它们也可以提供自己的 AVC，甚至可以不使用 AVC。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SELinux &lt;strong&gt;安全策略及其配置文件&lt;/strong&gt; 位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux&lt;/code&gt; 目录，该目录包含主配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/config&lt;/code&gt;，其中指定了要加载的策略名称（SELINUXTYPE 条目）以及加载时策略初始的强制模式（SELINUX 条目）。&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/&amp;lt;SELINUXTYPE&amp;gt;&lt;/code&gt; 目录包含可激活的策略，以及它们的配置文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SELinux 支持模块化的策略。&lt;strong&gt;模块化的策略&lt;/strong&gt; 由一个 &lt;strong&gt;基本的策略&lt;/strong&gt; 及零或多个 &lt;strong&gt;策略模块&lt;/strong&gt; 组成，基本的策略中包含客体类别、权限等强制信息，&lt;strong&gt;不同的策略模块用于支持不同的程序或服务&lt;/strong&gt;。这些模块被编译、链接以后，保存在一个 “&lt;strong&gt;策略仓库&lt;/strong&gt;” 中，在这里它们可以被集成进一个 &lt;strong&gt;二进制格式&lt;/strong&gt; 文件，然后被加载到 &lt;strong&gt;安全服务器&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;一个策略仓库包含策略包和系统管理员所做的修改，二者被合并到一个单独的逻辑实体中。系统中可以同时存在多个策略仓库，每个仓库的策略完全隔离，可以由管理员切换来部署。切换完毕有时需要重启。仓库位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux&lt;/code&gt; 目录中，以各自仓库的名字命名，如系统默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/targeted&lt;/code&gt; 仓库。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要想制定策略就需要 &lt;strong&gt;策略的源码&lt;/strong&gt;。简单的策略可以用内核策略语言编写的源码，而更常用的方法则是使用具有高级别宏的 “参考策略（Reference Policy）” 来定义策略规则。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;策略源码的编译、链接和加载需要一些工具的帮助。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要想允许系统管理员来管理策略，需要 SELinux 环境、标签文件系统、工具软件以及修改过的 GNU / Linux 命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要想确保安全事件都被记录下来，Linux 使用审计服务来捕获触碰策略的事件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1324-selinux-策略&quot;&gt;13.2.4 SELinux 策略&lt;/h3&gt;

&lt;p&gt;SELinux 安全子系统会通过策略来检查任何的访问企图，它使用 &lt;strong&gt;默认拒绝&lt;/strong&gt; 的设置，因此它寻找针对 SELinux 类型的 &lt;strong&gt;显示允许语句&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;SELinux 策略定义了 SELinux 子系统的行为，不同的策略会导致不同的行为。策略与 SELinux 子系统是分开的，策略的更新不需要重新编译内核，也不需要更新程序，&lt;strong&gt;策略内置于可以动态加载的二进制策略包中&lt;/strong&gt;，与内核模块可以被加载很类似。&lt;/p&gt;

&lt;p&gt;SELinux 支持 &lt;strong&gt;模块化&lt;/strong&gt; 的策略。策略可以分解为具体的规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;策略&lt;/strong&gt; = 一个 &lt;strong&gt;基础策略&lt;/strong&gt; + 零或若干个 &lt;strong&gt;策略模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基础策略&lt;/strong&gt; 包含客体类型、权限等 &lt;strong&gt;强制信息&lt;/strong&gt;，而每个 &lt;strong&gt;策略模块用于控制特定的程序或服务&lt;/strong&gt;。这些模块经过编译、链接后，被统一放置在一个 “策略仓库（Policy Store）” 里，他们可以从这里被转换为二进制格式，然后载入安全服务器。&lt;/p&gt;

&lt;p&gt;SELinux 默认由 RBAC 和 TE 组成，MLS 为可选项。&lt;/p&gt;

&lt;p&gt;SELinux 预置策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Targeted：针对特定的系统进程进行控制&lt;/li&gt;
  &lt;li&gt;Minimum： Targeted 的修改版，只保留一少部分&lt;/li&gt;
  &lt;li&gt;MLS: 多级别安全保护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CentOS 使用的 &lt;strong&gt;默认策略&lt;/strong&gt; 是 &lt;strong&gt;targeted&lt;/strong&gt; ，专门针对 &lt;strong&gt;特定的系统进程&lt;/strong&gt; 进行控制。targeted 策略在设计时考虑尽量保护最多的主要进程，同时又不会影响用户的体验。&lt;/p&gt;

&lt;p&gt;系统内其它一切系统进程、用户程序和所有自制应用程序都在 &lt;strong&gt;unconfined&lt;/strong&gt; 域运行，并且不纳入 SELinux 的保护范围内。&lt;/p&gt;

&lt;h3 id=&quot;1325-selinux-决策流程&quot;&gt;13.2.5 SELinux 决策流程&lt;/h3&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/selinux.process.png&quot; alt=&quot;SELinux 决策流程&quot; /&gt;
  
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;主体发出访问客体的请求&lt;/li&gt;
  &lt;li&gt;内核中的客体管理器查看 AVC
    &lt;ul&gt;
      &lt;li&gt;如果缓存中有该主体与客体的 AVC 规则，按规则执行，放行或拒绝。&lt;/li&gt;
      &lt;li&gt;如果没有，该请求继续传递到安全服务器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安全服务器在策略中查找主体和客体的上下文，找到后在 AVC 中缓存，从而决定是否有权访问。
    &lt;ul&gt;
      &lt;li&gt;规则允许，放行&lt;/li&gt;
      &lt;li&gt;规则拒绝或不存在，拒绝。拒绝的消息保存在 /var/log/mesages，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;133-selinux-上下文&quot;&gt;13.3 SELinux 上下文&lt;/h2&gt;

&lt;p&gt;SELinux Contexts，或 Security Context，为陈述方便以下简称上下文。&lt;/p&gt;

&lt;p&gt;SELinux 要求每个主体和每个客体都要有关联的上下文，以便安全服务器（security server）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程和文件&lt;/strong&gt; 都用 SELinux 上下文打上了 &lt;strong&gt;标签&lt;/strong&gt;，其中包含多个附加信息，如 SL 用户、角色、类型、级别（可选）。在使用 SELinux 期间，所有的这些信息都被 &lt;strong&gt;用来进行访问控制的决策&lt;/strong&gt;。CentOS 提供的是基于角色访问控制、类型强制、多级别安全的组合。&lt;/p&gt;

&lt;p&gt;SELinux 上下文在 &lt;strong&gt;进程、L 用户和文件&lt;/strong&gt; 中使用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -Z&lt;/code&gt; 可以查看文件和目录的上下文。&lt;/p&gt;

&lt;p&gt;同 rwx 一样，文件的 SELinux 上下文保存在文件的 &lt;strong&gt;inode&lt;/strong&gt; 中。&lt;/p&gt;

&lt;h3 id=&quot;1331-上下文的内容&quot;&gt;13.3.1 上下文的内容&lt;/h3&gt;

&lt;p&gt;SELinux &lt;code class=&quot;highlighter-rouge&quot;&gt;User : Role : Type : Level&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SELinux &lt;code class=&quot;highlighter-rouge&quot;&gt;用户：角色：类型：级别&lt;/code&gt;&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;每个字段都用来决定访问控制，但实际上大多数规则是针对上下文中的 &lt;strong&gt;SELinux 类型&lt;/strong&gt; 来制定的，因此上下文经常简化成只有类型。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/SELinux_context.png&quot; alt=&quot;SELinux 上下文&quot; /&gt;
  
&lt;/figure&gt;

&lt;p&gt;在命令后加 &lt;code class=&quot;highlighter-rouge&quot;&gt;-Z&lt;/code&gt; 参数可以查看上下文：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对文件：	&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -Z&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;针对进程：	&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -Z&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;针对用户：	&lt;code class=&quot;highlighter-rouge&quot;&gt;id -Z&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sl-用户&quot;&gt;SL 用户&lt;/h4&gt;

&lt;p&gt;Linux 中的用户通常是与人类用户相关联的，如 Alice，Bob，或是系统功能，如 admin。而 SELinux 的用户通常是一组或一类用户，比如，所有的标准系统用户都可能都会被分配给 SL 用户名  &lt;code class=&quot;highlighter-rouge&quot;&gt;user_u&lt;/code&gt;，而行政人员可能都分配给 &lt;code class=&quot;highlighter-rouge&quot;&gt;staff_u&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在参考策略（Reference Policy）中，有一个特殊的 SL 用户永远不会与 L 用户关联，因为它的身份对于系统进程和客体来说太特殊了，这个用户就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;system_u&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;按照习惯，SL 用户名后面都会加后缀 &lt;code class=&quot;highlighter-rouge&quot;&gt;_u&lt;/code&gt;，非强制的。&lt;/p&gt;

&lt;p&gt;SL 用户标识对于策略来说，它是 &lt;strong&gt;被特定的规则集合授权&lt;/strong&gt; 的，&lt;strong&gt;应用于特定的 MLS/MCS 范围&lt;/strong&gt;。每个 &lt;strong&gt;L 用户&lt;/strong&gt; 都通过 SELinux 策略被 &lt;strong&gt;映射到一个 SL 用户&lt;/strong&gt;，使得 L 用户得以 &lt;strong&gt;继承&lt;/strong&gt; 施加在 SL 用户身上的 &lt;strong&gt;限制&lt;/strong&gt;。被映射的 SL 用户标识被使用于会话中各进程的 SELinux 上下文中，从而定义这些 SL 用户能够进入什么角色和什么级别。&lt;/p&gt;

&lt;p&gt;对于进程来说，SL 用户限制了其角色和可访问的级别。&lt;/p&gt;

&lt;h4 id=&quot;selinux-角色&quot;&gt;SELinux 角色&lt;/h4&gt;

&lt;p&gt;为了能对 TE 域能做进一步的控制，SELinux 也会使用 RBAC，它允许 SL 用户关联到一个或多个角色中，每个角色于是被关联到一个或多个域类型中。&lt;/p&gt;

&lt;p&gt;SELinux 角色习惯加后缀 &lt;code class=&quot;highlighter-rouge&quot;&gt;_r&lt;/code&gt;，非强制。&lt;/p&gt;

&lt;p&gt;SL 用户被授权担任角色，而角色又授权给域，&lt;strong&gt;角色做为媒介服务于域和 SL 用户之间&lt;/strong&gt;。&lt;strong&gt;可进入的角色决定了可进入的域&lt;/strong&gt;，最终，&lt;strong&gt;决定了允许访问哪种客体类型&lt;/strong&gt;。这有助于减少特权升级攻击的漏洞。&lt;/p&gt;

&lt;h4 id=&quot;selinux-类型&quot;&gt;SELinux 类型&lt;/h4&gt;

&lt;p&gt;是 &lt;strong&gt;TE&lt;/strong&gt; 的属性之一。&lt;/p&gt;

&lt;p&gt;对于 &lt;strong&gt;进程&lt;/strong&gt; 来说，类型用于定义 &lt;strong&gt;域&lt;/strong&gt;，对于 &lt;strong&gt;文件&lt;/strong&gt; 来说，用于定义 &lt;strong&gt;类型&lt;/strong&gt;。策略的规则中会定义类型之间可以如何互访，是域访问类型（进程访问文件），还是域访问另一个域（进程间沟通）。&lt;/p&gt;

&lt;p&gt;只有 &lt;strong&gt;特定的显示放行的 SELinux 策略规则存在&lt;/strong&gt; 时，才会允许访问。&lt;/p&gt;

&lt;p&gt;SELinux 使用一种特别风格的 TE 来强制实施访问控制。它意味着所有的主体和客体都有一个与它们相关联的类型标签，可以用来执行策略规定的规则。&lt;/p&gt;

&lt;h4 id=&quot;selinux--级别&quot;&gt;SELinux  级别&lt;/h4&gt;

&lt;p&gt;级别是 &lt;strong&gt;MLS&lt;/strong&gt; 及 &lt;strong&gt;MCS&lt;/strong&gt; 的属性之一。&lt;/p&gt;

&lt;p&gt;该内容为可选，SELinux 支持 MLS 及 MCS，如果使用其中的一种，则在上下文中第四个位置增加 &lt;strong&gt;级别&lt;/strong&gt; 或 &lt;strong&gt;级别范围&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;CentOS 中，&lt;strong&gt;targeted 策略强制实施的是 MCS&lt;/strong&gt;，其中只有一级敏感度 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S0&lt;/code&gt;&lt;/strong&gt;，支持 1024 个不同类别（c0.c1023），因此所有类别可以表示为 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0-s0:c0.c1023&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1332-域的转换&quot;&gt;13.3.2 域的转换&lt;/h3&gt;

&lt;p&gt;对于进程来说，SL &lt;strong&gt;类型就是域&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;域的转换是指：&lt;strong&gt;进程在另一个域中启动一个新进程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;要想发生域的转换，策略必须满足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;源域有权限转换到目标域&lt;/li&gt;
  &lt;li&gt;程序的二进制文件在源域中有执行权限&lt;/li&gt;
  &lt;li&gt;程序的二进制文件有到目标域的入口点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过执行具有新域的入口点类型的应用程序，一个域中的进程可以转换到另一个域。SELinux 策略中会使用 &lt;strong&gt;入口点权限&lt;/strong&gt;，该权限 &lt;strong&gt;可控制哪些程序可用来进入一个域&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一位用户想修改自己的密码，他运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 程序，&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin/passwd&lt;/code&gt; 可执行文件标签中的类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_exec_t&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 程序会访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt;，其类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;有一条 SELinux 策略规则写道：&lt;strong&gt;运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域的进程可以读写 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt; 类型的文件&lt;/strong&gt;。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt; 类型只会应用于密码修改时需要访问的文件上，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/gshadow&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt;，及它们的备份文件。&lt;/li&gt;
  &lt;li&gt;有一条 SELinux 策略规则写道：&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_exec_t&lt;/code&gt; 域有到 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 哉的入口点权限&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;用户执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 时，用户的 shell 进程转换到 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域，因为有规则允许运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域的进程访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt; 类型的文件，所以允许 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 程序访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt; 来更新密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此例中，类型强制确保了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域只能通过执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_exec_t&lt;/code&gt; 类型的程序来进入，只能从授权的共享库来执行，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;lib_t&lt;/code&gt; 类型，不能执行任何其它的程序。&lt;/li&gt;
  &lt;li&gt;只有授权的域，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 才能写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt; 类型的文件，即便其它进程是用超级用户权限来运行的，那些进程也无法写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt; 类型的文件，因为它们没有在 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域中运行。&lt;/li&gt;
  &lt;li&gt;只有授权的域才能转换到 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域。&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd_t&lt;/code&gt; 域运行的进程只能读取授权的类型，如含有 &lt;code class=&quot;highlighter-rouge&quot;&gt;etc_t&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;shadow_t&lt;/code&gt; 标签的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1333-进程的上下文&quot;&gt;13.3.3 进程的上下文&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;类型对于进程来说就是域&lt;/strong&gt;，对文件来说才是类型。&lt;/p&gt;

&lt;h3 id=&quot;1334-用户的上下文&quot;&gt;13.3.4 用户的上下文&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id -Z&lt;/code&gt; 可以查看当前 L 用户的上下文&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;CentOS 中，&lt;strong&gt;Linux 用户默认是不受限的&lt;/strong&gt;（unconfined）。&lt;/p&gt;

&lt;h2 id=&quot;134-targeted-策略&quot;&gt;13.4 Targeted 策略&lt;/h2&gt;

&lt;p&gt;Targeted Policy 是 CentOS 中默认的 SELinux 策略。使用该策略时，&lt;strong&gt;被针对的进程会在一个受限的域中运行&lt;/strong&gt;，未被针对的进程会运行于未受限的域。如，默认情况下，登陆进来的用户运行于非受限域 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_t&lt;/code&gt;，而被 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 启动的系统进程则会运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;initrc_t&lt;/code&gt; 域，所有这些域都是不受限的。&lt;/p&gt;

&lt;p&gt;可执行和可写内存检查适用于受限和非受限域。但是，默认情况下，运行在非限制域中的主体不能分配可写内存并执行它。这减少了缓冲区溢出攻击的隐患。这些内存检查可以通过设置布尔值来禁用，这允许在运行时修改 SELinux 策略。&lt;/p&gt;

&lt;p&gt;类型强制是 SELinux Targeted 策略中主要使用的权限控制手段。大部分时间，SL 用户和角色都可以被忽略。&lt;/p&gt;

&lt;h3 id=&quot;1341-受限进程&quot;&gt;13.4.1 受限进程&lt;/h3&gt;

&lt;p&gt;几乎所有的 &lt;strong&gt;在网络上倾听的服务&lt;/strong&gt;，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;sshd&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 都 &lt;strong&gt;是受限的&lt;/strong&gt;。同时，&lt;strong&gt;大部分作为超级用户运行，为用户执行任务的进程&lt;/strong&gt;，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 也都 &lt;strong&gt;是受限的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当一个进程受限时，它会 &lt;strong&gt;在自己的域中运行&lt;/strong&gt;，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_t&lt;/code&gt; 域。如果某个受限进程被攻破，取决于 SELinux 策略的配置，攻击者对资源的访问及可能造成的损失是有限的。&lt;/p&gt;

&lt;h4 id=&quot;范例如何确认-selinux-状态&quot;&gt;范例：如何确认 SELinux 状态&lt;/h4&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# sestatus
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Max kernel policy version:      28

~]# &lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; /var/www/html/testfile
&lt;span class=&quot;c&quot;&gt;# 创建测试文件 testfile&lt;/span&gt;
~]# &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; /var/www/html/testfile
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/testfile
&lt;span class=&quot;c&quot;&gt;#      SELinux        |    用户   | 角色   |        类型       |级别&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;用户：默认情况下，&lt;strong&gt;L 用户是非受限的&lt;/strong&gt;，因此文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;testfile&lt;/code&gt; 的用户是 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;角色：RBAC 是用于进程的，而非文件，因此 &lt;strong&gt;文件的角色没什么意义&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;object_r&lt;/code&gt; 对文件来说是一个普通的角色（在持续存储和网络文件系统中）。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/&lt;/code&gt; 目录中，与进程相关的文件会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;system_r&lt;/code&gt; 角色。&lt;/li&gt;
  &lt;li&gt;类型：&lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_sys_content_t&lt;/code&gt; 类型允许 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程访问该文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;范例受限的进程&quot;&gt;范例：受限的进程&lt;/h4&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# systemctl start httpd  &lt;span class=&quot;c&quot;&gt;# 启动 Apache HTTP Server&lt;/span&gt;
~]# wget http://localhost/testfile  &lt;span class=&quot;c&quot;&gt;# 下载刚生成的文件&lt;/span&gt;
......
2018-03-21 16:05:47 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 B/s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; - ‘testfile’ saved &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0/0]
&lt;span class=&quot;c&quot;&gt;# 可以正常下载&lt;/span&gt;
~]# &lt;span class=&quot;nb&quot;&gt;chcon&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; samba_share_t /var/www/html/testfile
&lt;span class=&quot;c&quot;&gt;# 修改测试文件的类型为   ^^^^^^^^^^^^&lt;/span&gt;
~]# &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; /var/www/html/testfile
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; root root unconfined_u:object_r:samba_share_t:s0 /var/www/html/testfile
&lt;span class=&quot;c&quot;&gt;# 确认修改类型成功                           ^^^^^^^^^^^^&lt;/span&gt;
~]# wget http://localhost/testfile  &lt;span class=&quot;c&quot;&gt;# 再次尝试下载&lt;/span&gt;
......
2018-03-21 16:09:44 ERROR 403: Forbidden.  &lt;span class=&quot;c&quot;&gt;# 失败，被拒绝&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即便在 DAC 规则允许 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程访问测试文件时，因为文件的类型标签决定了 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程无法访问该文件，于是 SELinux 拒绝了访问，即使是超级用户也无权下载文件文件。&lt;/p&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;auditd&lt;/code&gt; 服务在运行，错误会记录到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt; 日志中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type=AVC msg=audit(1521620178.016:565): avc:  denied  { getattr } for  pid=6086 comm=&quot;httpd&quot; path=&quot;/var/www/html/testfile&quot; dev=&quot;dm-0&quot; ino=10492580 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时也会有错误记录到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/httpd/error_log&lt;/code&gt; 日志中:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Wed Mar 21 16:16:18.017784 2018] [core:error] [pid 6086] (13)Permission denied: [client ::1:56072] AH00035: access to /testfile denied (filesystem path '/var/www/html/testfile') because search permissions are missing on a component of the path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1342-非受限进程&quot;&gt;13.4.2 非受限进程&lt;/h3&gt;

&lt;p&gt;非受限进程运行于非受限域中，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 程序运行于非受限域 &lt;code class=&quot;highlighter-rouge&quot;&gt;initrc_t&lt;/code&gt; 中，非受限内核进程运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel_t&lt;/code&gt; 域中，非受限 L 用户运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_t&lt;/code&gt; 域中。对于非受限进程来说，其实是应用了 SELinux 的策略的，只不过策略规则说 “允许运行于非受限域的进程访问几乎所有资源”。在效果上，这些非受限进程相当于只使用 DAC 规则。如果非受限进程被攻破，SELinux 无法避免攻击者获取系统资源和数据，不过当然，DAC 规则仍有效。SELinux 毕竟是覆盖在 DAC 规则之上的一个安全强化措施，它无法代替 DAC 规则。&lt;/p&gt;

&lt;h4 id=&quot;范例非受限进程&quot;&gt;范例：非受限进程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chcon&lt;/code&gt; 命令会修改文件的标签，然而，在文件系统标签被 &lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 修复时，这种修改就会丢失。&lt;/p&gt;

    &lt;p&gt;修改文件类型为 Samba 使用的类型：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# &lt;span class=&quot;nb&quot;&gt;chcon&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; samba_share_t /var/www/html/testfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;确认修改成功：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; /var/www/html/testfile
 &lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;  root root unconfined_u:object_r:samba_share_t:s0 /var/www/html/testfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;暂停 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# systemctl stop httpd.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 程序的类型为不会产生域转换的类型&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 的初始类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_exec_t&lt;/code&gt;，修改为 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin_t&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# &lt;span class=&quot;nb&quot;&gt;chcon&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; bin_t /usr/sbin/httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认修改成功：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; /usr/sbin/httpd
 &lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; root root system_u:object_r:bin_t:s0       /usr/sbin/httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 服务&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# systemctl start httpd.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程的类型&lt;/p&gt;

    &lt;p&gt;修改之前，&lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程的域为 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_t&lt;/code&gt;，修改之后变为 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_service_t&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# ps &lt;span class=&quot;nt&quot;&gt;-eZ&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;httpd
 system_u:system_r:unconfined_service_t:s0 5680 ? 00:00:00 httpd
 system_u:system_r:unconfined_service_t:s0 5681 ? 00:00:00 httpd
 system_u:system_r:unconfined_service_t:s0 5682 ? 00:00:00 httpd
 system_u:system_r:unconfined_service_t:s0 5684 ? 00:00:00 httpd
 system_u:system_r:unconfined_service_t:s0 5686 ? 00:00:00 httpd
 system_u:system_r:unconfined_service_t:s0 5687 ? 00:00:00 httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以普通用户身份在家目录下载测试文件：&lt;/p&gt;

    &lt;p&gt;在范例二中下载失败的情况，此时消失了，普通用户可以顺利下载。&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget http://localhost/testfile
 ......
 2018-03-22 17:56:52 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 B/s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; - ‘testfile’ saved &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0/0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;虽然 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程无权访问类型标签为 &lt;code class=&quot;highlighter-rouge&quot;&gt;samba_share_t&lt;/code&gt; 的文件，但 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 进程运行于非限制域中，因此又落回了 DAC 的规则，于是 &lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt; 命令成功执行。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 运行于受限域 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_t&lt;/code&gt; 中，&lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt; 就会失败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 命令会为文件恢复默认的上下文&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# restorecon &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /usr/sbin/httpd
 restorecon reset /usr/sbin/httpd context system_u:object_r:bin_t:s0-&amp;gt;system_u:object_r:httpd_exec_t:s0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认修改成功后，重启 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 服务&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# systemctl restart httpd.service

 ~]# ps &lt;span class=&quot;nt&quot;&gt;-eZ&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;httpd
 system_u:system_r:httpd_t:s0      6001 ?        00:00:00 httpd
 system_u:system_r:httpd_t:s0      6002 ?        00:00:00 httpd
 system_u:system_r:httpd_t:s0      6003 ?        00:00:00 httpd
 system_u:system_r:httpd_t:s0      6004 ?        00:00:00 httpd
 system_u:system_r:httpd_t:s0      6005 ?        00:00:00 httpd
 system_u:system_r:httpd_t:s0      6006 ?        00:00:00 httpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进程域成功恢复到 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_t&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1343-受限及非受限用户&quot;&gt;13.4.3 受限及非受限用户&lt;/h3&gt;

&lt;p&gt;每个 L 用户都会用 SELinux 策略被映射到一个 SL 用户，这允许 L 用户继承对 SL 用户的限制。&lt;/p&gt;

&lt;p&gt;CentOS 中，&lt;strong&gt;L 用户默认全部被映射到 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;seinfo -u&lt;/code&gt; 可以查看当前 SL 用户列表。&lt;/p&gt;

&lt;p&gt;受限和非受限的 L 用户是可执行、可写内存检测的主体，他们也会受到 MLS 或 MCS 的限制。&lt;/p&gt;

&lt;h4 id=&quot;对新建-l-用户的限制&quot;&gt;对新建 L 用户的限制&lt;/h4&gt;

&lt;p&gt;当 Linux 中新用户第一次登陆时，&lt;code class=&quot;highlighter-rouge&quot;&gt;pam_selinux&lt;/code&gt; 这个 PAM 模块会自动把该用户映射到 SELinux &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 用户上，并设置其上下文，该用户的 shell 就会用该上下文启动。&lt;/p&gt;

&lt;h4 id=&quot;非受限用户运行程序也能保证安全&quot;&gt;非受限用户运行程序也能保证安全&lt;/h4&gt;

&lt;p&gt;当 L 用户运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_t&lt;/code&gt; 时，SL 策略是生效的，只不过是策略的规则说，允许运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_t&lt;/code&gt; 域的 L 用户几乎可以访问任何资源。如果一个非受限的 L 用户执行一个程序，SELinux 策略说该程序可以从 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_t&lt;/code&gt; 域转换到它自己的受限域，则该非受限的 L 用户仍然是该受限域限制的主体。这样做带来的好处是，即使 L 用户是非受限的，而程序依然保持受限，从而，要想利用应用程序的缺陷就会受到策略的限制。&lt;/p&gt;

&lt;h4 id=&quot;对受限用户运行程序的限制&quot;&gt;对受限用户运行程序的限制&lt;/h4&gt;

&lt;p&gt;类似的，我们也可以对受限用户进行这些检查。每个受限的 L 用户被限制在自己的域中，SL 策略也可以定义一个 “从一个受限用户的域到其目标受限域” 的转换，此时，受限的 L 用户是目标受限域所限制的主体。根据其角色的定义，特殊权限是与受限用户相关联的。&lt;/p&gt;

&lt;h4 id=&quot;sl-用户限制域及能力限制&quot;&gt;SL 用户限制域及能力限制&lt;/h4&gt;

&lt;p&gt;下表仅举例说明不同的 SL 用户可以如何被限制具体的能力：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;用户&lt;/th&gt;
      &lt;th&gt;角色&lt;/th&gt;
      &lt;th&gt;域&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;X Window&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;su 或 sudo&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;在家目录及 /tmp 执行（默认）&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;网络&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sysadm_u&lt;/td&gt;
      &lt;td&gt;sysadm_r&lt;/td&gt;
      &lt;td&gt;sysadm_t&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;su&lt;/strong&gt; 及 &lt;strong&gt;sudo&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;staff_u&lt;/td&gt;
      &lt;td&gt;staff_r&lt;/td&gt;
      &lt;td&gt;staff_t&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;仅 &lt;strong&gt;sudo&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;user_u&lt;/td&gt;
      &lt;td&gt;user_r&lt;/td&gt;
      &lt;td&gt;user_t&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;guest_u&lt;/td&gt;
      &lt;td&gt;guest_r&lt;/td&gt;
      &lt;td&gt;guest_t&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xguest_u&lt;/td&gt;
      &lt;td&gt;xguest_r&lt;/td&gt;
      &lt;td&gt;xguest_t&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;仅 Firefox&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;如果 SELinux 规则允许，&lt;code class=&quot;highlighter-rouge&quot;&gt;user_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;guest_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;xguest_t&lt;/code&gt; 域中的 L 用户只能运行 SUID 程序，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;passwd&lt;/code&gt;。这些用户无法运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;su&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;，因此无法借助它们变身为超级用户。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sysadm_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;staff_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;user_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;xguest_t&lt;/code&gt; 域中的 L 用户可以用 X Window 登陆，也可以从终端登陆&lt;/li&gt;
  &lt;li&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;guest_t&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;xguest_t&lt;/code&gt; 域中的 L 用户无法在家目录或 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmp&lt;/code&gt; 目录执行程序，即使他们对目录有写权限。可以避免恶意程序修改用户的文件。&lt;/li&gt;
  &lt;li&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;staff_t&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_t&lt;/code&gt; 域中的 L 用户可以在其家目录及 &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt; 目录执行程序&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xguest_t&lt;/code&gt; 域中的 L 用户唯一拥有的网络访问权限是用 Firefox 连接到网页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，对于系统进程和客体来说，&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;system_u&lt;/code&gt; 是一个特殊的用户标识，它永远不可以与 L 用户关联&lt;/strong&gt;。同样的，&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 是非受限用户&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;特殊-sl-角色&quot;&gt;特殊 SL 角色&lt;/h4&gt;

&lt;p&gt;以下举例说明一些特殊的 SL 角色，这些角色决定了用户能做什么：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webadm_r&lt;/code&gt;：只能管理与 Apache HTTP Server 相关的 SL 类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dbadm_r&lt;/code&gt;：只能管理与 MariaDB 数据库、PostgreSQL 数据库相关的 SL 类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;logadm_r&lt;/code&gt;：只能管理与 &lt;code class=&quot;highlighter-rouge&quot;&gt;syslog&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;auditlog&lt;/code&gt; 相关的 SL 类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;secadm_r&lt;/code&gt;：只能管理 SELinux&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;auditadm_r&lt;/code&gt;：只能管理与 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit&lt;/code&gt; 子系统相关的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;seinfo -r&lt;/code&gt; 查看所有角色。&lt;/p&gt;

&lt;h4 id=&quot;sudo-转换和-sl-角色&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 转换和 SL 角色&lt;/h4&gt;

&lt;p&gt;某些时候，受限用户可能会需要完成一个需要超级用户权限的管理任务，他必须用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 命令来获得一个受限的管理员角色。当受限用户用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 执行命令时，他们的角色会发生改变，空间如何改变则取决于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers&lt;/code&gt; 中的规则或 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers.d/&lt;/code&gt; 目录中的某个文件。&lt;/p&gt;

&lt;h5 id=&quot;范例为现有-sl-用户配置受限的管理员角色&quot;&gt;范例：为现有 SL 用户配置受限的管理员角色&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新的 SL 用户，并指定其默认角色及附加的受限管理员角色&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# semanage user &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; s0-s0:c0.c1023 &lt;span class=&quot;nt&quot;&gt;-R&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;staff_r webadm_r&quot;&lt;/span&gt; neo_u
 &lt;span class=&quot;c&quot;&gt;#                                         默认角色| 附加角色 | 新 SL 用户名&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新建用户的上下文直接参照原 SL 用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;staff_u&lt;/code&gt; 的上下文，所以直接复制其上下文文件。&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# &lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /etc/selinux/targeted/contexts/users/staff_u /etc/selinux/targeted/contexts/users/neo_u
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把新建 SL 用户映射给现有 L 用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;neo&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; semanage login &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; neo_u &lt;span class=&quot;nt&quot;&gt;-rs0&lt;/span&gt;:c0.c1023 neo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers.d/&lt;/code&gt; 目录中创建一个与 &lt;code class=&quot;highlighter-rouge&quot;&gt;neo&lt;/code&gt; 同名的配置文件：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;linux_user ALL=(ALL) TYPE=webadm_t ROLE=webadm_r /bin/sh &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /etc/sudoers.d/neo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rstorecon&lt;/code&gt; 修复 L 用户家目录&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# restorecon &lt;span class=&quot;nt&quot;&gt;-FR&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /home/neo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新登陆 &lt;code class=&quot;highlighter-rouge&quot;&gt;neo&lt;/code&gt;，用户的标签被更新为其默认的 SL 角色，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;staff_r&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]# &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt;
 neo_u:staff_r:staff_t:s0:c0.c1023
 &lt;span class=&quot;c&quot;&gt;#             ^^^^^^^&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;而当该 L 用户运行完 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 以后，其 SL 上下文会变成 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers.d/neo&lt;/code&gt; 中指定的附加角色：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
 ~]# &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt;
 SELinux_user_u:webadm_r:webadm_t:s0-s0:c0.c1023
 &lt;span class=&quot;c&quot;&gt;#              ^^^^^^^^&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;135-对用户的限制&quot;&gt;13.5 对用户的限制&lt;/h2&gt;

&lt;p&gt;L 用户被默认映射到 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 用户，所有由 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 启动的进程都处于 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_t&lt;/code&gt; 域中，这意味着在 DAC 策略的控制之下，用户可以在系统内任意访问。然而，也存在一些受限的用户，他们就会被限制能力。借助策略，每个 L 用户被映射到一个 SL 用户，实现了 L 用户可以继承 SL 用户的限制。这些限制可能是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运行 X 窗口&lt;/li&gt;
  &lt;li&gt;使用网络&lt;/li&gt;
  &lt;li&gt;运行 SUID 程序&lt;/li&gt;
  &lt;li&gt;运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;su&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如，由 SL 用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_u&lt;/code&gt; 启动的进程运行于 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_t&lt;/code&gt; 域中，这类进程可以连网，但无法使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;su&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 命令，这有助于保护系统免于用户的恶意操作（被劫持）带来的危险。&lt;/p&gt;

&lt;h3 id=&quot;1351-linux-和-sl-用户映射&quot;&gt;13.5.1 Linux 和 SL 用户映射&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;semanage login -l&lt;/code&gt;  查看 L 用户和 SL 用户的映射：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@zion ~]# semanage login &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;

Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         s0-s0:c0.c1023       &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
root                 unconfined_u         s0-s0:c0.c1023       &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
system_u             system_u             s0-s0:c0.c1023       &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所有的 L 用户先是被映射到 L 用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;__default__&lt;/code&gt; ，然后再统一被映射到 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 用户。&lt;/p&gt;

&lt;h3 id=&quot;1352-限制-linux-新用户useradd&quot;&gt;13.5.2 限制 Linux 新用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;useradd&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;useradd&lt;/code&gt; 创建用户时，如果不指定参数，该用户会被映射到 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 用户，使用的是如下的默认映射：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__default__          unconfined_u         s0-s0:c0.c1023       *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果用 &lt;code class=&quot;highlighter-rouge&quot;&gt;useradd&lt;/code&gt; 创建用户时，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-Z&lt;/code&gt; 参数可以指定该用户要映射要被映射到哪个 SL 用户身上。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;useradd -Z user_u user&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;1353-限制现有-l-用户semanage-login&quot;&gt;13.5.3 限制现有 L 用户：&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage login&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;新建 L 用户默认被映射到 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt; 上，如果你想改变映射，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;semanage login&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semange login -a -s neo_u neo&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;1354-修改默认映射&quot;&gt;13.5.4 修改默认映射&lt;/h3&gt;

&lt;p&gt;默认 L 用户都会先被映射给 &lt;code class=&quot;highlighter-rouge&quot;&gt;__default__&lt;/code&gt; 用户，然后再把该用户映射到 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfined_u&lt;/code&gt;，如果希望修改这个默认映射，如希望把 L 用户默认映射给 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_u&lt;/code&gt;，可以这样做：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage login -m -S targeted -s &quot;user_u&quot; -r s0 __default__&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;1355-xguestkiosk-模式&quot;&gt;13.5.5 &lt;code class=&quot;highlighter-rouge&quot;&gt;xguest&lt;/code&gt;：kiosk 模式&lt;/h3&gt;

&lt;p&gt;kiosk，报刊厅，意指公共场所，信息不安全地带。kiosk user account，访客用户。随来随用，用完就走。&lt;/p&gt;

&lt;p&gt;在安装过 xguest 包以后就会产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;xguest&lt;/code&gt; 这个访客用户，它的权限非常有限：登陆、用 firefox 浏览网页。&lt;/p&gt;

&lt;p&gt;所有的访客用户都分配给 &lt;code class=&quot;highlighter-rouge&quot;&gt;xguest_u&lt;/code&gt;，该用户登陆后发生的所有改变在他退出后都会丢失，如登陆期间创建的文件，或其它设置的修改等。&lt;/p&gt;

&lt;p&gt;为了照顾各类使用人群，该用户不用密码保护，因此，它只能由 SELinux 来强制保护。而且该用户只能用 GDM 登陆系统。&lt;/p&gt;

&lt;h3 id=&quot;1356-用户执行程序的布尔值&quot;&gt;13.5.6 用户执行程序的布尔值&lt;/h3&gt;

&lt;p&gt;应用程序会继承用户的权限，因此，在家目录及 &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt; 等用户有写权限的目录中，禁止 L 用户执行程序可以避免有缺陷或恶意程序修改用户文件。&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;setsebool&lt;/code&gt; 命令来配置布尔值，可以改变用户的行为，&lt;code class=&quot;highlighter-rouge&quot;&gt;setsebool -P&lt;/code&gt; 做出的改变会持续生效，因此如果不希望在重启后还有效，就不要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setsebool -P guest_exec_content off&lt;/code&gt;  禁止 &lt;code class=&quot;highlighter-rouge&quot;&gt;guest_t&lt;/code&gt; 域中的 L 用户在其家目录及 &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt; 运行程序&lt;/p&gt;

&lt;h2 id=&quot;136-使用-selinux&quot;&gt;13.6 使用 SELinux&lt;/h2&gt;

&lt;h3 id=&quot;1361-日志&quot;&gt;13.6.1 日志&lt;/h3&gt;

&lt;p&gt;CentOS 中，dbus 和 audit 包是默认安装的，setroubleshoot-server 需要手动安装。&lt;/p&gt;

&lt;p&gt;在 audit 服务运行的情况下，SELinux 拒绝消息会被写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt;，消息内容类似下面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type=AVC msg=audit(1223024155.684:49): avc:  denied  { getattr } for  pid=2000 comm=&quot;httpd&quot; path=&quot;/var/www/html/file1&quot; dev=dm-0 ino=399185 scontext=unconfined_u:system_r:httpd_t:s0 tcontext=system_u:object_r:samba_share_t:s0 tclass=file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外还会有一条消息被写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/message&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;May 7 18:55:56 localhost setroubleshoot: SELinux is preventing httpd (httpd_t) &quot;getattr&quot; to /var/www/html/file1 (samba_share_t). For complete SELinux messages. run sealert -l de7e30d6-5488-466d-a606-92c9f40d316d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshootd&lt;/code&gt; 过去经常被用于分析 AVC 消息，但现在它不再以服务的形式运行了。有两个新的程序可以在需要的时候间接启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshoot&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sedispatch&lt;/code&gt; 作为 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit&lt;/code&gt; 子系统的一分部运行，当返回一条 AVC 拒绝消息时，&lt;code class=&quot;highlighter-rouge&quot;&gt;sedispatch&lt;/code&gt; 会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dbus&lt;/code&gt; 发送一条消息，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshootd&lt;/code&gt; 此时在运行，消息会直接发送给它，如果没有运行，&lt;code class=&quot;highlighter-rouge&quot;&gt;sedispatch&lt;/code&gt; 会自动启动它。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;seapplet&lt;/code&gt; 运行于系统工具栏，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshootd&lt;/code&gt; 中等待 &lt;code class=&quot;highlighter-rouge&quot;&gt;dbus&lt;/code&gt; 传来的消息，它会开启通知气泡，把 AVC 消息传递给用户查看。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1362-配置文件&quot;&gt;13.6.2 配置文件&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/config&lt;/code&gt; 是 SELinux 的主要配置文件，它控制着 SELinux 启动还是禁用，以及当前使用哪个 SELinux 模式、哪个策略。&lt;/p&gt;

&lt;h3 id=&quot;1363-状态与模式&quot;&gt;13.6.3 状态与模式&lt;/h3&gt;

&lt;h4 id=&quot;selinux-状态&quot;&gt;SELinux 状态&lt;/h4&gt;

&lt;p&gt;SELinux 的状态要么是 &lt;strong&gt;启用&lt;/strong&gt;（Enabled），要么是 &lt;strong&gt;禁用&lt;/strong&gt;（Disabled），这两种状态 &lt;strong&gt;不能在线热切换&lt;/strong&gt;，切换之后 &lt;strong&gt;必须重启&lt;/strong&gt; 系统。&lt;/p&gt;

&lt;p&gt;通过编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/config&lt;/code&gt; 配置文件，来切换 SELinux 状态或模式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELINUX=enforcing/permissive/disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;selinux-工作模式&quot;&gt;SELinux 工作模式&lt;/h4&gt;

&lt;p&gt;在开启状态下，SELinux 有两种工作模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;强制模式&lt;/strong&gt;：enforcing，默认值。会在系统上强制实施，SELinux 根据安全策略来拒绝访问。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;宽容模式&lt;/strong&gt;：permissive。不强制实施，不会拒绝访问，但会把强制模式下会生成的拒绝访问的信息记录到日志。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两种工作模式可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;setenforce&lt;/code&gt; 命令随时在线切换，但该命令造成的变化，在重启后会自己消失。&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/assets/images/selinux.modes.png&quot; alt=&quot;SELinux 工作模式&quot; /&gt;
  
&lt;/figure&gt;

&lt;h5 id=&quot;常用命令&quot;&gt;常用命令&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getenforce&lt;/code&gt;  查看 SELinux 当前工作模式&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setenforce 0&lt;/code&gt;  切换到宽容模式&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setenforce 1&lt;/code&gt;  切换到强制模式&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;当系统运行于宽容模式时，允许用户给文件打错误的标签。当 SELinux 禁用时创建的文件是不会被打标签的，如果此时切换到强制模式就会造成问题，因为文件标签是错的，或是根本没标签。为了避免错误标签及无标签文件造成问题，&lt;strong&gt;从禁用状态切换到启用状态时&lt;/strong&gt;，文件系统会 &lt;strong&gt;自动重新打标签&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;启动时修改-selinux-模式&quot;&gt;启动时修改 SELinux 模式&lt;/h5&gt;

&lt;p&gt;系统启动时，可以设置几个内核参数来改变 SELinux 的运行方式：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enforcing=0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该参数会让系统 &lt;strong&gt;以宽容模式启动&lt;/strong&gt;，便于排查问题。&lt;/p&gt;

&lt;p&gt;如果文件系统被严重干扰，使用该模式可能是唯一的排查办法了。而且，该模式下，系统会继续正确地创建标签。在该模式下产生的 AVC 消息会与强制模式略有不同。在宽容模式中，只有第一次拒绝会被报告，然而在强制模式中，每当读取一次目录或程序暂停时都会收到一次拒绝。在宽容模式中，你收到的是相同的 AVC 消息，但实际上当程序继续读取目录中的各个文件时，你会额外收到不同的拒绝。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;selinux=0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该参数会使内核在启动时不加载 SELinux 架构的任何部分，即 &lt;strong&gt;禁用 SELinux&lt;/strong&gt;。当 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 脚本发现系统是携带 &lt;code class=&quot;highlighter-rouge&quot;&gt;selinux=0&lt;/code&gt; 参数启动时，它会 &lt;strong&gt;创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;/.autorelabel&lt;/code&gt; 文件&lt;/strong&gt;，在下次系统启动并启用 SELinux 时，这会促使系统 &lt;strong&gt;自动重新打标签&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;不推荐使用该模式来排查问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelabel=1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该参数会促使系统先创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;/.autorelabel&lt;/code&gt; 文件，然后重启。即相当于连续运行以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# touch /.autorelabel
~]# reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1364-布尔值&quot;&gt;13.6.4 布尔值&lt;/h3&gt;

&lt;p&gt;为了在运行时（runtime）能够灵活地启用、禁用某些 SELinux 策略，系统创建了布尔值这个概念。&lt;/p&gt;

&lt;p&gt;在实际使用中，有时会发现一些活动被拒绝了，然而明明在逻辑上有充分的理由放行的。当这些理由信赖于特定的因素或选择时，SELinux 策略的编写者就会被鼓励 &lt;strong&gt;将这些策略变为可选&lt;/strong&gt;。在 SELinux 世界里，可选就意味着可以 &lt;strong&gt;通过 SELinux 布尔值来开、关特定的访问控制&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;查看布尔值列表&quot;&gt;查看布尔值列表&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage boolean -l&lt;/code&gt;  查看布尔值名称、描述、开关状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getsebool -a&lt;/code&gt;  查看布尔值名称、开关状态&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getsebool boolean-name1 boolean-name2&lt;/code&gt;  查看指定名称的布尔值状态&lt;/p&gt;

&lt;h4 id=&quot;修改布尔值&quot;&gt;修改布尔值&lt;/h4&gt;

&lt;p&gt;通过设置布尔值来 &lt;strong&gt;开启或关闭某项规则&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setsebool  [-P]  boolean_name on/off&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;  持续生效，重启后不会丢失&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;on/off&lt;/code&gt;  开关状态，可以用 1/0 或 true/false 来替换&lt;/p&gt;

&lt;p&gt;如果不加 -P 参数，只在当前有效，系统重启后失效。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# getsebool httpd_enable_homedirs
httpd_enable_homedirs --&amp;gt; off  # 当前是为关闭状态
~]# setsebool -P httpd_enable_homedirs 1  # 打开
~]# getsebool httpd_enable_homedirs
httpd_enable_homedirs --&amp;gt; on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1365-给文件打标签&quot;&gt;13.6.5 给文件打标签&lt;/h3&gt;

&lt;p&gt;在使用 SELinux 的系统中，所有的进程和文件都会被打上标签，以此来标示安全相关的信息，即 SELinux 上下文，以此来制定决策。在 DAC 系统中，访问控制是基于 L 的 UID 与 GID。SELinux 的策略规则检查是在 DAC 规则检查之后进行的，如果 DAC 规则已经拒绝了访问，则 SELinux 策略规则就无需使用。&lt;/p&gt;

&lt;p&gt;默认情况下，新创建的文件和目录会 &lt;strong&gt;继承父目录的 SL 类型&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;临时修改标签&quot;&gt;临时修改标签&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chcon&lt;/code&gt; 命令用于 &lt;strong&gt;临时修改&lt;/strong&gt; 文件的上下文，但它造成的变化会在 &lt;strong&gt;文件系统重打标签时被覆盖&lt;/strong&gt;，也会 &lt;strong&gt;被 &lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 命令的执行给覆盖&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;SELinux 策略决定了是否允许用户修改给定文件的上下文。经常发生的事情是，类型标签打错了，导致拒绝访问。&lt;/p&gt;

&lt;h5 id=&quot;chcon-手动修改文件的上下文&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chcon&lt;/code&gt; 手动修改文件的上下文&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chcon [-R] [-t type] [-u user] [-r role] 文件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chcon [-R] --reference=参考文件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;  显示对每个文件的操作过程，必须放在 &lt;strong&gt;所有参数之前&lt;/strong&gt; 🌟&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt;  遍历子目录及其文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;  修改类型&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt;  修改用户&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;  修改角色&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--reference=&lt;/code&gt;	参考指定文件&lt;/p&gt;

&lt;p&gt;【 范例 】修改指定文件的类型&lt;/p&gt;

&lt;p&gt;先查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 的类型，将之用于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.d/checktime&lt;/code&gt; 文件上。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# ll &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; /etc/hosts
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; root root system_u:object_r:net_conf_t:s0  /etc/hosts
&lt;span class=&quot;c&quot;&gt;#              参考文件的类型           ^^^^^^^^^^&lt;/span&gt;

~]# &lt;span class=&quot;nb&quot;&gt;chcon&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; net_conf_t /etc/cron.d/checktime
&lt;span class=&quot;c&quot;&gt;#               ^^^^^^^^^^  &lt;/span&gt;
changing security context of ‘/etc/cron.d/checktime’

~]# ll &lt;span class=&quot;nt&quot;&gt;-Z&lt;/span&gt; /etc/cron.d/checktime
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; root root unconfined_u:object_r:net_conf_t:s0 /etc/cron.d/checktime
&lt;span class=&quot;c&quot;&gt;#                                           ^^^^^^^^^^ 修改成功&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;【 范例 】指定参考文件，自动修改文件标签&lt;/p&gt;

&lt;p&gt;参考文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt;，自动修改文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.d/checktime&lt;/code&gt; 的上下文，修改之后该文件的所有标签与参考文件完全一致。&lt;/p&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--reference&lt;/code&gt; 参数来 &lt;strong&gt;指定参考文件&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# chcon -v --reference=/etc/shadow /etc/cron.d/checktime
~]# ll -Z /etc/shadow /etc/cron.d/checktime
-rw-r--r--. root root system_u:object_r:shadow_t:s0    /etc/cron.d/checktime
----------. root root system_u:object_r:shadow_t:s0    /etc/shadow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;持久修改&quot;&gt;持久修改&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 命令用于 &lt;strong&gt;持久修改文件的上下文&lt;/strong&gt;，不会受文件系统重打标签（Relabel）的影响，即文件系统被重打标签之后，之前用 &lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 修改的标签依然会保持原标签不变。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Relabel 即指文件系统重新打标签的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;如何免于-relabel&quot;&gt;如何免于 RELABEL&lt;/h5&gt;

&lt;p&gt;要想让 SL 上下文的修改能够避免于 relabel，需要在使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;semanage&lt;/code&gt; 修改完标签之后，再用 &lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 来实际应用该修改才行。&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 后面必须接 &lt;strong&gt;文件的绝对路径&lt;/strong&gt;，否则不会生效。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# semanage fcontext &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; options file-name|directory-name
~]# restorecon &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; file-name|directory-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--primary&quot;&gt;😈 为什么在 &lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 之后还要再多做一步 &lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 呢？&lt;/p&gt;

&lt;p&gt;事情是这样婶儿的：&lt;/p&gt;

&lt;p&gt;在使用 targeted 策略时，&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 所做的修改会保存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/targeted/contexts/files/&lt;/code&gt; 目录中的两个文件中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;file_contexts&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 所做的修改首先会检查该文件，如果在该文件中找到了要修改上下文的文件或目录的名称，则在此文件更新。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;file_contexts.local&lt;/code&gt;：如果上一步中，没有找到目标文件或目录的名称，则把修改记录添加到此文件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个文件生成、更新之后，会有两个工具来读它们：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setfiles&lt;/code&gt;：当文件系统要重打标签（relabel）时，会用该工具来执行打标签的任务。它打的时候会先读取上面的文件，以将其排除在外，因此，这样一来，&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext&lt;/code&gt; 所做的修改才能免于重打标签的毒手。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt;：它可以随时拿来修复默认上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;修复上下文&quot;&gt;修复上下文&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 命令会根据当前所在目录查找对应的规则，以确定其默认的上下文。如果当前文件的上下文与所在目录默认上下文不匹配，则将其纠正。有了这个命令，便无需用 &lt;code class=&quot;highlighter-rouge&quot;&gt;chcon&lt;/code&gt; 手动修改了。&lt;/p&gt;

&lt;p&gt;文件被移动后，往往会携带原目录的上下文，因此在存取中会造成上下文不匹配，用该命令来予以纠正。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon [-Rv] 文件或目录&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt;  遍历子目录&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;  显示过程&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon -Rv /etc/cron.d&lt;/code&gt;  修复指定目录中所有文件的 SL 类型&lt;/p&gt;

&lt;h3 id=&quot;1366-file_t-及-default_t类型&quot;&gt;13.6.6 &lt;code class=&quot;highlighter-rouge&quot;&gt;file_t&lt;/code&gt; 及 &lt;code class=&quot;highlighter-rouge&quot;&gt;default_t&lt;/code&gt;类型&lt;/h3&gt;

&lt;p&gt;当使用支持 &lt;strong&gt;扩展属性&lt;/strong&gt; 的文件系统时，如果一个文件尚未分配扩展属性，其默认 SL 类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;file_t&lt;/code&gt;，该类型仅仅是做这个用的，并不会存在于正确打标签的文件系统中，因为在使用 SELinux 的系统中，所有文件都应该有正确的上下文，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;fiel_t&lt;/code&gt; 类型是永远不会在上下文的配置中使用的。&lt;/p&gt;

&lt;p&gt;在文件上下文配置过程中，那些不匹配任何特征的文件，会被分配 &lt;code class=&quot;highlighter-rouge&quot;&gt;default_t&lt;/code&gt; 类型，以便能与没有标签的文件区别开来，通常这些文件在受限域中是拒绝访问的。&lt;/p&gt;

&lt;h3 id=&quot;1367-挂载文件系统&quot;&gt;13.6.7 挂载文件系统&lt;/h3&gt;

&lt;p&gt;默认情况下，当一个 &lt;strong&gt;支持扩展属性的文件系统&lt;/strong&gt; 被挂载时，每个文件的上下文是 &lt;strong&gt;从文件的扩展属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;security.selinux&lt;/code&gt; 获得&lt;/strong&gt; 的。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mount -o context&lt;/code&gt; 命令可以覆盖现有的扩展属性。&lt;/p&gt;

&lt;p&gt;而在 &lt;strong&gt;不支持扩展属性的文件系统&lt;/strong&gt; 中，会按照文件系统的类型，依照策略为文件分配 &lt;strong&gt;单一的、默认的上下文&lt;/strong&gt;。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mount -o context&lt;/code&gt; 命令可以指定一个不同的默认上下文。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mount -o context&lt;/code&gt; 的使用场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不信任某个文件系统能提供正确的属性，如在多个系统中使用的可移动磁盘，通常用 &lt;code class=&quot;highlighter-rouge&quot;&gt;context=&quot;system_u:object_r:removable_t&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在不支持扩展属性的文件系统中支持文件打标签，如 FAT 或 NFS 驱动器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;context&lt;/code&gt; 参数指定的上下文不会被写到磁盘中，原始的上下文还是被保留的，当你不用 &lt;code class=&quot;highlighter-rouge&quot;&gt;context&lt;/code&gt; 挂载磁盘时就会看到了，前提是支持扩展属性的文件系统。&lt;/p&gt;

&lt;h4 id=&quot;挂载文件系统时使用上下文参数&quot;&gt;挂载文件系统时使用上下文参数&lt;/h4&gt;

&lt;p class=&quot;notice--success&quot;&gt;在挂载文件系统时，通过特定的 &lt;strong&gt;挂载参数&lt;/strong&gt;，实现特定的访问控制。&lt;/p&gt;

&lt;p&gt;要想以指定的上下文挂载文件系统，&lt;strong&gt;覆盖现有的上下文&lt;/strong&gt; 的话，或是为不支持扩展属性的文件系统 &lt;strong&gt;指定默认上下文&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mount -o context=SELinux_user:role:type:level&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;挂载驱动器时对文件系统上下文的改变 &lt;strong&gt;不会被写入磁盘&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;范例用挂载参数控制服务对-nfs-的访问&quot;&gt;范例：用挂载参数控制服务对 NFS 的访问&lt;/h5&gt;

&lt;p&gt;NFS 驱动器在客户端挂载时，使用的是针对 NFS 的策略定义的默认标签。在一般的策略中，该默认上下文使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;nfs_t&lt;/code&gt; 类型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;希望 &lt;strong&gt;禁止&lt;/strong&gt; 其它服务访问挂载的 NFS：挂载时 &lt;strong&gt;不附带额外参数&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;希望 &lt;strong&gt;允许&lt;/strong&gt; 网页服务访问挂载的 NFS，可以为其 &lt;strong&gt;指定网页服务专用的类型&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# mount server:/export /local/mount/point -o \
context=&quot;system_u:object_r:httpd_sys_content_t:s0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，在挂载的文件系统中新创建的文件和目录 &lt;strong&gt;看上去&lt;/strong&gt; 就有了 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o context&lt;/code&gt; 指定的上下文了，因为这些改变不会保存到磁盘中，所以为了维持这个上下文，&lt;strong&gt;每次挂载&lt;/strong&gt; 该文件系统时必须使用 &lt;strong&gt;相同的上下文参数&lt;/strong&gt; 才行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型强制是 SELinux Targeted 策略中主要的权限控制手段&lt;/strong&gt;。大部分时间，SL 用户和角色都可以被忽略。因此，当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o context&lt;/code&gt; 覆盖原上下文时，会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;system_u&lt;/code&gt; 用户和 &lt;code class=&quot;highlighter-rouge&quot;&gt;object_r&lt;/code&gt; 角色，再配合类型使用。如果没有使用 MLS 或 MCS，可使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;s0&lt;/code&gt; 级别。&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;当文件系统 &lt;strong&gt;挂载时使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;context&lt;/code&gt; 参数&lt;/strong&gt; 时，系统会 &lt;strong&gt;禁止用户和进程修改上下文&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;chcon&lt;/code&gt; 会返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;Operation not supported&lt;/code&gt; 错误。&lt;/p&gt;

&lt;h4 id=&quot;修改默认上下文&quot;&gt;修改默认上下文&lt;/h4&gt;

&lt;p&gt;在支持扩展属性的文件系统中，磁盘中缺少上下文的文件会被看作它有策略指定的默认的上下文。在普通的策略中，这个默认的上下文使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;file_t&lt;/code&gt; 类型。如果想使用不同的默认上下文，挂载文件系统时可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;defcontext&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;下面范例为在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 目录上挂载一个新建的文件系统 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/sda2&lt;/code&gt;，假设在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/selinux/targeted/contexts/files/&lt;/code&gt; 目录中不存在为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 定义的上下文：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# mount /dev/sda2 /test/ -o defcontext=&quot;system_u:object_r:samba_share_t:s0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本例中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;defcontext&lt;/code&gt; 参数为未打标签的文件指定了默认上下文&lt;/li&gt;
  &lt;li&gt;挂载时，文件系统的根目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 被视为有 &lt;code class=&quot;highlighter-rouge&quot;&gt;defcontext&lt;/code&gt; 指定的上下文（标签不会保存在磁盘上），这会影响为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 目录中创建的文件打标签：新文件会继承 &lt;code class=&quot;highlighter-rouge&quot;&gt;samba_share_t&lt;/code&gt; 类型，这些标签是会保存在磁盘上的。&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 目录中创建的文件会保存其标签&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;同一-nfs-的多次挂载&quot;&gt;同一 NFS 的多次挂载&lt;/h4&gt;

&lt;p&gt;NFS 的导出目录的同一子目录，虽然支持多次被挂载，但会导致叠加挂载，文件在两个不同的上下文中都能被访问，会造成混乱。&lt;/p&gt;

&lt;p&gt;而同一 NFS 导出目录的不同子目录，可以同时用不同的上下文分别挂载，使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o nosharecache,context&lt;/code&gt; 参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# mount server:/export/web /local/web \
-o nosharecache,context=&quot;system_u:object_r:httpd_sys_content_t:s0&quot;
#                                          ^^^^^^^^^^^^^^^^^^^

~]# mount server:/export/database /local/database \
-o nosharecache,context=&quot;system_u:object_r:mysqld_db_t:s0&quot;
#                                          ^^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;etcfstab-中指定挂载参数&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/fstab&lt;/code&gt; 中指定挂载参数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server:/export /local/mount/ nfs context=&quot;system_u:object_r:httpd_sys_content_t:s0&quot; 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1368-标签的维护&quot;&gt;13.6.8 标签的维护&lt;/h3&gt;

&lt;p&gt;当复制、移动、归档文件和目录时，上下文发生了什么？如何在复制和归档时保留上下文？&lt;/p&gt;

&lt;h4 id=&quot;复制文件和目录&quot;&gt;复制文件和目录&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;复制文件和目录时&lt;/strong&gt;，如果不指定参数，&lt;strong&gt;不会保留原上下文&lt;/strong&gt;。产生的新文件和目录的上下文是基于默认标签规则的，而不是原文件和目录的上下文。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果向另一目录复制文件，不加参数复制，则目标文件的上下文会根据目标目录的默认上下文创建&lt;/li&gt;
  &lt;li&gt;如果目标文件已存在，不加参数复制，覆盖后，已存在文件的上下文会保留&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--preserve=context&lt;/code&gt; 参数来保留原上下文&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;cp --context=system_u:object_r:samba_share_t:s0&lt;/code&gt; 来指定目标文件的上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据以上特性，建议尽量用复制替代移动，这样能更好地保证标签的正确性。&lt;/p&gt;

&lt;h4 id=&quot;移动文件和目录&quot;&gt;移动文件和目录&lt;/h4&gt;

&lt;p&gt;文件和目录被 &lt;strong&gt;移动时会保留原始的上下文&lt;/strong&gt;，但在许多情况下，目标目录的上下文往往与其不同。&lt;/p&gt;

&lt;h4 id=&quot;检查上下文&quot;&gt;检查上下文&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;matchpathcon&lt;/code&gt; 可以用来 &lt;strong&gt;检查文件和目录的上下文是否正确&lt;/strong&gt;，所谓正确的标准就是系统策略中该路径的默认上下文。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;matchpathcon -V /var/www/html/*&lt;/code&gt;  检查该目录中所有文件的上下文是否正确&lt;/p&gt;

&lt;p&gt;检查出来的错误可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon&lt;/code&gt; 来修正。&lt;/p&gt;

&lt;h4 id=&quot;用-tar-归档文件&quot;&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tar&lt;/code&gt; 归档文件&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar&lt;/code&gt; 默认不会保留扩展属性，而因为 SL 上下文是保存在扩展属性中的，所以归档时文件上下文会丢失。&lt;/p&gt;

&lt;p&gt;可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tar --selinux&lt;/code&gt; 参数来保留上下文。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打包时使用该参数，包里的文件上下文保留原始标签&lt;/li&gt;
  &lt;li&gt;解包时使用该参数，解开的文件会保留原始上下文&lt;/li&gt;
  &lt;li&gt;解包时不使用该参数，则解开的文件会继承当前目录的上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1369-信息分析&quot;&gt;13.6.9 信息分析&lt;/h3&gt;

&lt;h4 id=&quot;avcstat-查看-avc-统计&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;avcstat&lt;/code&gt; 查看 AVC 统计&lt;/h4&gt;

&lt;p&gt;该命令会显示 &lt;strong&gt;本次开机以来 AVC 的简要统计&lt;/strong&gt; 信息，可以指定实时显示时刷新的频率。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# avcstat
   lookups       hits     misses     allocs   reclaims      frees
  47517410   47504630      12780      12780      12176      12275
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;sestatus-查询系统状态&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sestatus&lt;/code&gt; 查询系统状态&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sestatus&lt;/code&gt; 可 &lt;strong&gt;查询 SELinux 当前状态信息&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SELinux 当前状态，启动或关闭&lt;/li&gt;
  &lt;li&gt;SELinux 关键目录的位置，/etc/selinux&lt;/li&gt;
  &lt;li&gt;当前已载入的策略名称&lt;/li&gt;
  &lt;li&gt;SELinux 的挂载点&lt;/li&gt;
  &lt;li&gt;当前工作模式&lt;/li&gt;
  &lt;li&gt;配置文件中指定的工作模式&lt;/li&gt;
  &lt;li&gt;MLS 状态&lt;/li&gt;
  &lt;li&gt;对于未定义操作，是否默认采取拒绝&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sestatus [-vb]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;   查看 /etc/sestatus.conf 中记录的文件与进程的安全上下文&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt;   查看布尔值列表，左侧为布尔值，右侧为开关状态&lt;/p&gt;

&lt;h4 id=&quot;seinfo-查询策略中要素&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;seinfo&lt;/code&gt; 查询策略中要素&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;seinfo&lt;/code&gt; 用于 &lt;strong&gt;查询 SELinux 策略中的各要素&lt;/strong&gt;，身份、角色、类型、规则。它使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;policy.conf&lt;/code&gt;、二进制策略文件、策略包的模块化列表或一个策略列表文件做为输入。其输出也会根据不同的输入而有所区别。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;seinfo [-trub]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--all&lt;/code&gt;   查看所有要素：SELinux 状态、规则、身份、角色、类型&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt;		查看所有身份&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;		查看所有角色&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;		查看所有类型&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt;		查看所有规则&lt;/p&gt;

&lt;h4 id=&quot;sesearch-查找特定的规则&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch&lt;/code&gt; 查找特定的规则&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch&lt;/code&gt; 用于在策略中 &lt;strong&gt;查找特定的规则&lt;/strong&gt;。可以在策略源文件中查找，也可以在二进制文件中查找。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch [-A] [-s 主体类型] [-t 客体类型] [-b 规则名称]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt;  仅查看放行的规则&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-C&lt;/code&gt;  显示条件表达式及状态&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch -C&lt;/code&gt; 会在返回结果的开头加上两个字母，第一个字母表示 &lt;strong&gt;本条规则当前状态&lt;/strong&gt;，第二个字母表示 &lt;strong&gt;布尔值的哪个状态会启用本条规则&lt;/strong&gt;。
E D T F 分别为 Enabled, Disabled, True, False 的首字母。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;ET：本规则当前启用，布尔值打开时会启用本规则&lt;/li&gt;
    &lt;li&gt;EF：本规则当前启用，布尔值关闭时会启用本规则&lt;/li&gt;
    &lt;li&gt;DT：本规则当前禁用，布尔值打开时会启用本规则&lt;/li&gt;
    &lt;li&gt;DF：本规则当前禁用，布尔值关闭时会启用本规则&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;  指定主体类型，域&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;  指定客体类型，文件类型&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt;  指定规则名称&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch&lt;/code&gt; 返回的格式是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  allow crond_t setfiles_exec_t : file { read getattr execute open } ;
# 控制 |   域  |     类型       | 客体  |           操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/handbook/handbook-permission/#sesearch&quot;&gt;【 更多… 】&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;13610-禁用-ptrace&quot;&gt;13.6.10 禁用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace()&lt;/code&gt; 系统调用允许一个进程观察并控制另一个进程的执行，可以修改它的内存和寄存器。该调用主要用于策略开发人员做调试。日常使用中应该禁用该调用，以提升系统安全。可以通过启用 &lt;code class=&quot;highlighter-rouge&quot;&gt;deny_ptrace&lt;/code&gt; 布尔值来完成：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setsebool -P deny_ptrace on&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;13611-缩略图保护&quot;&gt;13.6.11 缩略图保护&lt;/h3&gt;

&lt;p&gt;缩略图可能会允许攻击者使用移动介质攻破一个锁定的机器，如 U 盘或光盘。当系统检测到移动介质时，Nautilus 文件管理器会执行缩略图驱动程序代码，在文件资源管理器中显示缩略图，不管主机是否被锁定。这个行为非常危险，因为如果执行缩略图的程序有漏洞的话，很有可能被攻击者利用来绕过锁屏而无需输入密码。&lt;/p&gt;

&lt;p&gt;因此，有一个新的策略用来防止这些攻击的发生，该策略能保证锁屏时也同时锁定所有的缩略图驱动程序。&lt;/p&gt;

&lt;h2 id=&quot;137-selinux-排错&quot;&gt;13.7 SELinux 排错&lt;/h2&gt;

&lt;h3 id=&quot;1371-拒绝访问时都发生了什么&quot;&gt;13.7.1 拒绝访问时都发生了什么？&lt;/h3&gt;

&lt;p&gt;诸如拒绝访问、允许访问这样的 SELinux 的决策会被缓存，即 AVC。发生拒绝访问时，拒绝消息会记录到日志，这些消息也称为 AVC 拒绝。根据当前运行的日志服务，可以把日志保存到以下位置：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;服务&lt;/th&gt;
      &lt;th&gt;日志位置&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;auditd 开启&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;auditd 关闭，rsyslogd 开启&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;setroubleshootd, rsyslogd, auditd 开启&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt;，更易读的拒绝也被另存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# grep &quot;SELinux is preventing&quot; /var/log/messages
~]# grep &quot;denied&quot; /var/log/audit/audit.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1372-常见问题&quot;&gt;13.7.2 常见问题&lt;/h3&gt;

&lt;h4 id=&quot;标签问题&quot;&gt;标签问题&lt;/h4&gt;

&lt;p&gt;使用 SELinux 的系统中，所有的进程和文件都有上下文，标签要是错了，就可能造成访问被拒绝。如果程序的标签错了，就会造成其进程标签也是错的，也会造成拒绝访问，进程又会生成标签错误的文件。&lt;/p&gt;

&lt;p&gt;一个常见的打错标签的原因是，为服务使用非标准目录。例如，本应该为网站使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/html/&lt;/code&gt; 目录，结果管理员使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;/srv/myweb/&lt;/code&gt;。在 CentOS 中，&lt;code class=&quot;highlighter-rouge&quot;&gt;/srv&lt;/code&gt; 目录的类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;var_t&lt;/code&gt;，在该目录中创建的文件和目录也会继承该标签。新建的一级目录（如 &lt;code class=&quot;highlighter-rouge&quot;&gt;myserver/&lt;/code&gt;）会默认使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;default_t&lt;/code&gt; 标签，SELinux 会阻止 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 访问这两种标签。要想允许访问，SELinux 必须知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;/srv/myweb/&lt;/code&gt; 中的文件是可以被 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 访问的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage fcontext -a -t httpd_sys_content_t &quot;/srv/myweb(/.*)?&quot;&lt;/code&gt;  为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/srv/myweb/&lt;/code&gt; 指定新的上下文&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon -R -v /srv/myweb&lt;/code&gt;  应用上面的改变&lt;/p&gt;

&lt;p&gt;如果用 &lt;code class=&quot;highlighter-rouge&quot;&gt;matchpathcon -V /var/www/html/*&lt;/code&gt; 检查出错误的上下文，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;restorecon -R -v /var/www/html/&lt;/code&gt; 来修复。&lt;/p&gt;

&lt;h4 id=&quot;受限服务如何运行&quot;&gt;受限服务如何运行&lt;/h4&gt;

&lt;p&gt;要想控制服务之间的互访，可以通过布尔值的开关来实现。例如，要允许 Apache HTTP Server 与 MariaDB 通信，可以启用布尔值 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_can_netwrok_connect_db&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要想查询某个服务相关的访问，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;getsebool -a | grep ftp&lt;/code&gt; 实现。&lt;/p&gt;

&lt;h5 id=&quot;端口号&quot;&gt;端口号&lt;/h5&gt;

&lt;p&gt;根据策略的配置，可以限制服务只能运行于特定的端口号，如果尝试在策略之外修改服务运行的端口号，会导致服务启动失败。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage port -l | grep http&lt;/code&gt;  查询 http 相关的端口号&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http_port_t&lt;/code&gt; 端口类型定义了 Apache 可以监听的端口。&lt;/p&gt;

&lt;p&gt;要想增加 &lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt; 可以监听的端口，必须使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;semanage port -a http_port_t -p tcp 9876&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;规则的进化与崩溃的程序&quot;&gt;规则的进化与崩溃的程序&lt;/h4&gt;

&lt;p&gt;程序有可能会崩溃，造成 SELinux 的拒绝访问，同时 SELinux 的规则也在进化，SELinux 有可能在某种程度上没有检测到程序的运行，造成了拒绝访问，即便程序是正常运行的。例如一个新版 的PostgreSQL 发布后，它的一些操作可能当前的策略从未见过，导致拒绝访问，可这些访问应该被放行。&lt;/p&gt;

&lt;p&gt;这种情况下，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow&lt;/code&gt; 来创建自定义策略模块，以放行访问。&lt;/p&gt;

&lt;h3 id=&quot;1373-解决问题&quot;&gt;13.7.3 解决问题&lt;/h3&gt;

&lt;h4 id=&quot;linux-权限&quot;&gt;Linux 权限&lt;/h4&gt;

&lt;p&gt;拒绝访问发生时，应该检查标准的 L 权限，毕竟 SL 的策略是在 DAC 规则之后使用的，如果 DAC 规则已经拒绝了，就不会再使用 SL 策略了。&lt;/p&gt;

&lt;p&gt;如果访问拒绝，而日志中没有发现拒绝，应该查看 L 权限是否导致拒绝的原因。如需要可用 &lt;code class=&quot;highlighter-rouge&quot;&gt;chown&lt;/code&gt; 命令修改文件的拥有者和属组。&lt;/p&gt;

&lt;h4 id=&quot;不记录拒绝的可能原因&quot;&gt;不记录拒绝的可能原因&lt;/h4&gt;

&lt;p&gt;在某些情况下，AVC 拒绝消息可能不会被记录，程序和系统库函数经常会过多的检测，有些检测对于任务的完成是不必要的。为了在维持最少特权时，还能尽量减小日志中对无害程序的检测产生的 AVC 拒绝的数量，通过使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dontaudit&lt;/code&gt; 规则，策略无需开放权限就可以减少 AVC 拒绝。这些规则在标准策略中是很常见的。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dontaudit&lt;/code&gt; 的缺点是，虽然 SELinux 拒绝了访问，日志中却没有拒绝消息，给排错增加了难度。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semodule -DB&lt;/code&gt;  可以临时禁用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dontaudit&lt;/code&gt; 规则，以允许日志记录所有拒绝&lt;/p&gt;

&lt;p&gt;其中的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt; 会导致禁用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dontaudit&lt;/code&gt; 规则，&lt;code class=&quot;highlighter-rouge&quot;&gt;-B&lt;/code&gt; 会重建策略。运行该命令以后，再尝试运行之前产生问题的程序，根据日志来排查问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semodule -B&lt;/code&gt;  重新启用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dontaudit&lt;/code&gt; 并重建策略&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch --dontaudit&lt;/code&gt;  查看所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;dontaudit&lt;/code&gt; 规则&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sesearch --dontaudit -s smbd_t | grep squid&lt;/code&gt;  在 &lt;code class=&quot;highlighter-rouge&quot;&gt;smbd_t&lt;/code&gt; 域中筛选 squid 相关的规则&lt;/p&gt;

&lt;h4 id=&quot;服务的说明文档&quot;&gt;服务的说明文档&lt;/h4&gt;

&lt;p&gt;服务的说明文档（man page）包含很多有价值的信息，比如在给定的情况下应该使用什么文件类型，影响服务对客体访问的布尔值有哪些等等。这些信息有的在标准的说明文档中，有的可以从 SELinux 策略中，针对每个服务域，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sepolicy manpage&lt;/code&gt; 来自动生成，这类的说明文档的名称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;service-name-selinux&lt;/code&gt; 格式，通常安装了 &lt;code class=&quot;highlighter-rouge&quot;&gt;selinux-policy-doc&lt;/code&gt; 包就会有。&lt;/p&gt;

&lt;p&gt;例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;httpd_selinux(8)&lt;/code&gt; 的说明文档中包含：在不同情况下应使用哪种文件类型，在家目录要想运行脚本、共享文件、访问目录的话需要哪些布尔值，等等。&lt;/p&gt;

&lt;h4 id=&quot;宽容域&quot;&gt;宽容域&lt;/h4&gt;

&lt;p&gt;当 SELinux 运行于宽容模式时，不会拒绝访问，但对违反规则的访问仍然会记录日志。&lt;/p&gt;

&lt;p&gt;宽容域允许 &lt;strong&gt;某个进程单独以宽容模式运行&lt;/strong&gt;，主要用处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;排错&lt;/li&gt;
  &lt;li&gt;管理员为新程序创建策略&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;启用宽容域&quot;&gt;启用宽容域&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage permissive -a domain&lt;/code&gt;  把一个域切换到宽容模式&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semodule -l | grep permissive&lt;/code&gt;  查询当前所有宽容域&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semanage permissive -d domain&lt;/code&gt;  取消宽容域&lt;/p&gt;

&lt;h5 id=&quot;禁用宽容域&quot;&gt;禁用宽容域&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semodule -d permissivedomains&lt;/code&gt;  禁用所有的宽容域&lt;/p&gt;

&lt;p&gt;一旦使用了该命令，策略模块就不会出现在 &lt;code class=&quot;highlighter-rouge&quot;&gt;semodule -l&lt;/code&gt; 的结果中，要想查看包含被禁用模块在内的所有策略，可以用：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semodule --list-modules=full&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;宽容域的拒绝&quot;&gt;宽容域的拒绝&lt;/h5&gt;

&lt;p&gt;在日志中，强制模式下的 AVC 拒绝所产生的 &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL&lt;/code&gt; 消息中 &lt;code class=&quot;highlighter-rouge&quot;&gt;success=no&lt;/code&gt;，因为访问被拒绝；而在宽容模式下的 AVC 拒绝所产生的 &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL&lt;/code&gt;  消息中 &lt;code class=&quot;highlighter-rouge&quot;&gt;success=yes&lt;/code&gt;，因为访问被放行。&lt;/p&gt;

&lt;p&gt;而 AVC 消息在两种模式下均为 &lt;code class=&quot;highlighter-rouge&quot;&gt;avc:  denied&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;查找查看拒绝&quot;&gt;查找、查看拒绝&lt;/h4&gt;

&lt;p&gt;假设系统已经安装了 setroubleshoot、setroubleshoot-server、dbus、audit，并正在运行。&lt;/p&gt;

&lt;h5 id=&quot;ausearch&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ausearch&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;audit&lt;/code&gt; 安装包提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ausearch&lt;/code&gt; 工具，基于不同的搜索规范，可用来 &lt;strong&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit&lt;/code&gt; 服务的日志中查询事件&lt;/strong&gt;，它会访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt; 日志，因此必须用超级用户运行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ausearch -m avc,user_avc,selinux_err,user_selinux_err&lt;/code&gt;  查找所有拒绝&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ausearch -m avc -ts today&lt;/code&gt;  查找今天发生的拒绝&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ausearch -m avc -ts recent&lt;/code&gt;  查找 10 分钟内发生的拒绝&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ausearch -m avc -c httpd&lt;/code&gt;  查找 httpd 服务产生的拒绝&lt;/p&gt;

&lt;h5 id=&quot;aureport&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aureport&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;audit&lt;/code&gt; 安装包提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;aureport&lt;/code&gt; 工具，它可以 &lt;strong&gt;生成审计系统日志的总结报告&lt;/strong&gt;，它会访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit/log&lt;/code&gt; 日志，因此必须用超级用户运行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aureport -a&lt;/code&gt;  查看 AVC 拒绝列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# aureport -a

AVC Report
========================================================
# date time comm subj syscall class permission obj event
========================================================
1. 05/01/2009 21:41:39 httpd unconfined_u:system_r:httpd_t:s0 195 file getattr system_u:object_r:samba_share_t:s0 denied 2
2. 05/03/2009 22:00:25 vsftpd unconfined_u:system_r:ftpd_t:s0 5 file read unconfined_u:object_r:cifs_t:s0 denied 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;sealert&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sealert&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshoot-server&lt;/code&gt; 安装包提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sealert&lt;/code&gt; 工具，它可以读取由 &lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshoot-server&lt;/code&gt; 翻译过的拒绝消息。每一个拒绝都被分配一个 ID，具体的拒绝保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt;，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setroubleshoot: SELinux is preventing /usr/sbin/httpd from name_bind access on the tcp_socket. For complete SELinux messages. run sealert -l 8c123656-5dda-4e5d-8791-9e3bd03786b7
#                                         ^^^^^^^^  拒绝消息的 ID  ^^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sealert -l 8c123656-5dda-4e5d-8791-9e3bd03786b7&lt;/code&gt;  查看该拒绝的详细分析，为什么拒绝，如何解决&lt;/p&gt;

&lt;p&gt;如果你使用了 X 窗口系统，并且安装了 &lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshoot&lt;/code&gt; 及 &lt;code class=&quot;highlighter-rouge&quot;&gt;setroubleshoot-server&lt;/code&gt; 安装包，而且 &lt;code class=&quot;highlighter-rouge&quot;&gt;dbus&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;auditd&lt;/code&gt; 服务都在运行。当发生拒绝时，系统会弹出一个信息框：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/x.denial.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击 Show 会显示详细信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/sealertgui.png&quot; alt=&quot;image-center&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;audit-原始消息&quot;&gt;audit 原始消息&lt;/h4&gt;

&lt;p&gt;原始的 audit 消息记录在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt; 日志中，以下是 AVC 拒绝消息及相关的 SYSCALL 的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type=AVC msg=audit(1226874073.147:96): avc:  denied  { getattr } for  pid=2465 comm=&quot;httpd&quot; path=&quot;/var/www/html/file1&quot; dev=dm-0 ino=284133 scontext=unconfined_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file

type=SYSCALL msg=audit(1226874073.147:96): arch=40000003 syscall=196 success=no exit=-13 a0=b98df198 a1=bfec85dc a2=54dff4 a3=2008171 items=0 ppid=2463 pid=2465 auid=502 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=6 comm=&quot;httpd&quot; exe=&quot;/usr/sbin/httpd&quot; subj=unconfined_u:system_r:httpd_t:s0 key=(null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该条消息记录的是 Apache HTTP Server 尝试访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/html/files&lt;/code&gt; 时产生的拒绝消息。下面拆开来看看：&lt;/p&gt;

&lt;h5 id=&quot;avc-消息&quot;&gt;AVC 消息&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{ getattr }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;花括号中的项目表明了被拒绝的权限。&lt;code class=&quot;highlighter-rouge&quot;&gt;getattr&lt;/code&gt; 条目表明源进程在 &lt;strong&gt;尝试读取目标文件的状态信息&lt;/strong&gt;，该行为发生于读取文件之前，由于文件的标签错误导致该行为被拒绝。常见的权限包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;getattr&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;comm=&quot;httpd&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动该进程的可执行文件，其完整路径可在 SYSCALL 消息中 &lt;code class=&quot;highlighter-rouge&quot;&gt;exe=&lt;/code&gt; 部分找到，本例为 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec=&quot;/usr/sbin/httpd&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;path=&quot;/var/www/html/file1&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;进程尝试访问的 &lt;strong&gt;客体的路径&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scontext=&quot;unconfined_u:system_r:httpd_t:s0&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;主体（进程）的上下文，source context&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tcontext=&quot;unconfined_u:object_r:samba_share_t:s0&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;客体的上下文，target context&lt;/p&gt;

&lt;h5 id=&quot;syscall-消息&quot;&gt;SYSCALL 消息&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;success=no&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;表明 AVC 为强制模式，SYSCALL 不成功，被拒绝了。反之如果为 &lt;code class=&quot;highlighter-rouge&quot;&gt;success=yes&lt;/code&gt; 为宽容模式，成功，被放行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exe=&quot;/usr/sbin/httpd&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动该进程的可执行文件的完整路径&lt;/p&gt;

&lt;p&gt;错误的文件类型是最常见的导致拒绝的原因，要想排错，先比较源上下文 scontext 与目标上下文 tcontext，进程应该允许访问客体吗？&lt;/p&gt;

&lt;h4 id=&quot;sealert-消息&quot;&gt;sealert 消息&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt; 中的拒绝被分配了 ID，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;sealert -l ID&lt;/code&gt; 即可查看完整消息。&lt;/p&gt;

&lt;p&gt;这是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt; 中的消息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hostname setroubleshoot: SELinux is preventing httpd (httpd_t) &quot;getattr&quot; to /var/www/html/file1 (samba_share_t). For complete SELinux messages. run sealert -l 32eee32b-21ca-4846-a22f-0ba050206786
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查看完整消息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]$ sealert -l 32eee32b-21ca-4846-a22f-0ba050206786
SELinux is preventing httpd from getattr access on the file /var/www/html/file1.

*****  Plugin restorecon (92.2 confidence) suggests   ************************

If you want to fix the label.
/var/www/html/file1 default label should be httpd_sys_content_t.
Then you can run restorecon.
Do
# /sbin/restorecon -v /var/www/html/file1

*****  Plugin public_content (7.83 confidence) suggests   ********************

If you want to treat file1 as public content
Then you need to change the label on file1 to public_content_t or public_content_rw_t.
Do
# semanage fcontext -a -t public_content_t '/var/www/html/file1'
# restorecon -v '/var/www/html/file1'

*****  Plugin catchall (1.41 confidence) suggests   **************************

If you believe that httpd should be allowed getattr access on the file1 file by default.
Then you should report this as a bug.
You can generate a local policy module to allow this access.
Do
allow this access for now by executing:
# ausearch -c 'httpd' --raw | audit2allow -M my-httpd
# semodule -i my-httpd.pp


Additional Information:
Source Context                system_u:system_r:httpd_t:s0
Target Context                unconfined_u:object_r:samba_share_t:s0
Target Objects                /var/www/html/file1 [ file ]
Source                        httpd
Source Path                   httpd
Port                          &amp;lt;Unknown&amp;gt;
Host                          hostname.redhat.com
Source RPM Packages           
Target RPM Packages           
Policy RPM                    selinux-policy-3.13.1-166.el7.noarch
Selinux Enabled               True
Policy Type                   targeted
Enforcing Mode                Enforcing
Host Name                     hostname.redhat.com
Platform                      Linux hostname.redhat.com
                              3.10.0-693.el7.x86_64 #1 SMP Thu Jul 6 19:56:57
                              EDT 2017 x86_64 x86_64
Alert Count                   2
First Seen                    2017-07-20 02:52:11 EDT
Last Seen                     2017-07-20 02:52:11 EDT
Local ID                      32eee32b-21ca-4846-a22f-0ba050206786

Raw Audit Messages
type=AVC msg=audit(1500533531.140:295): avc:  denied  { getattr } for  pid=24934 comm=&quot;httpd&quot; path=&quot;/var/www/html/file1&quot; dev=&quot;vda1&quot; ino=31457414 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file


Hash: httpd,httpd_t,samba_share_t,file,getattr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;audit2allow-允许访问&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow&lt;/code&gt; 允许访问&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow&lt;/code&gt; 工具会从日志中搜集拒绝的信息，然后 &lt;strong&gt;生成 SL 策略的放行规则&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在分析完拒绝消息之后，如果修改标签和布尔值都不能实现放行，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow&lt;/code&gt; 来生成一个本地策略模块，它可以生成类型强制规则，用来放行之前的拒绝。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow -w -a&lt;/code&gt; 会读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/audit/audit.log&lt;/code&gt;，然后把所有的拒绝消息生成人类易读的描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# audit2allow -w -a
type=AVC msg=audit(1226270358.848:238): avc:  denied  { write } for  pid=13349 comm=&quot;certwatch&quot; name=&quot;cache&quot; dev=dm-0 ino=218171 scontext=system_u:system_r:certwatch_t:s0 tcontext=system_u:object_r:var_t:s0 tclass=dir
	Was caused by:
		Missing type enforcement (TE) allow rule.

	You can use audit2allow to generate a loadable module to allow this access.
......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; 参数用来读取所有的审核日志，&lt;code class=&quot;highlighter-rouge&quot;&gt;-w&lt;/code&gt; 参数用来生成人类易读的描述。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow -a&lt;/code&gt; 查看放行的类型强制规则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# audit2allow -a   


#============= gssproxy_t ==============

#!!!! This avc is allowed in the current policy
allow gssproxy_t fs_t:filesystem getattr;

#============= httpd_t ==============

#!!!! The file '/var/www/html/testfile' is mislabeled on your system.  
#!!!! Fix with $ restorecon -R -v /var/www/html/testfile
allow httpd_t samba_share_t:file getattr;

......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要想使用上面命令所显示的规则，可以运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow -a -M TEfilename&lt;/code&gt; &lt;strong&gt;创建自定义模块&lt;/strong&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;-M&lt;/code&gt; 参数用来在当前工作目录创建类型强制文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.te&lt;/code&gt;，后面跟的就是文件名。&lt;/p&gt;

&lt;p&gt;用 grep 把拒绝消息中需要的部分筛选出来，确认没有问题，再用管道交给 &lt;code class=&quot;highlighter-rouge&quot;&gt;audit2allow&lt;/code&gt; 来处理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~]# grep certwatch /var/log/audit/audit.log | audit2allow -R -M mycertwatch2
******************** IMPORTANT ***********************
To make this policy package active, execute:

semodule -i mycertwatch2.pp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行完毕之后，会生成两个文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;*.te&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.pp&lt;/code&gt;，前者为类型强制文件，后者为前者被编译后生成的策略包文件（模块）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;semodule -i mycertwatch.pp&lt;/code&gt;  安装生成的策略包&lt;/p&gt;</content><author><name></name></author><category term="selinux" /><category term="linux" /></entry><entry><title type="html">Linux 基础 - 12. 信号</title><link href="/linux/linux.signal/" rel="alternate" type="text/html" title="Linux 基础 - 12. 信号" /><published>2015-01-12T00:00:00+08:00</published><updated>2015-01-12T00:00:00+08:00</updated><id>/linux/linux.signal</id><content type="html" xml:base="/linux/linux.signal/">&lt;h2 id=&quot;121-信号的概念&quot;&gt;12.1 信号的概念&lt;/h2&gt;

&lt;p&gt;全称为 &lt;strong&gt;软中断信号&lt;/strong&gt;，也被称为软中断，简称信号。&lt;/p&gt;

&lt;p&gt;信号是发送给进程的软中断，操作系统用信号来通知正在运行的程序，发生了意外情况。如引用了不可用的内存地址，或异步事件（如电话断线）。&lt;/p&gt;

&lt;p&gt;信号本质上是在软件层次上 &lt;strong&gt;对硬件中断机制的一种模拟&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个 &lt;strong&gt;进程收到一个信号&lt;/strong&gt; 与 &lt;strong&gt;处理器收到一个中断请求&lt;/strong&gt; 可以说是 &lt;strong&gt;一样&lt;/strong&gt; 的。&lt;/p&gt;

&lt;p&gt;信号用于警告意外事件的发生，这些事件会 &lt;strong&gt;生成&lt;/strong&gt; 或 &lt;strong&gt;触发&lt;/strong&gt; 信号：&lt;/p&gt;

&lt;p&gt;GNU 的 C 函数库定义了各种信号类型，每种类型都适用于特定类型的事件。某些类型的事件使程序不能像往常一样继续进行，相应的信号通常会终止程序。其他类型的报告无害事件的信号在默认情况下被忽略。&lt;/p&gt;

&lt;p&gt;如果用户要参与到会触发信号的事件中，可以事先定义 &lt;strong&gt;信号处理函数&lt;/strong&gt;，当收到 &lt;strong&gt;特定信号&lt;/strong&gt; 时，操作系统会运行它。有时称信号处理函数 &lt;strong&gt;捕获&lt;/strong&gt;（catch） 了信号，当函数运行时，该信号通常处于 &lt;strong&gt;阻塞&lt;/strong&gt;（blocked） 状态。&lt;/p&gt;

&lt;p&gt;一个进程可以给另一个进程发信号，父进程可以借此抛弃子进程，或者两个相关进程借此通信并同步。&lt;/p&gt;

&lt;h2 id=&quot;122-信号的种类&quot;&gt;12.2 信号的种类&lt;/h2&gt;

&lt;h3 id=&quot;1221-可靠信号与不可靠信号&quot;&gt;12.2.1 可靠信号与不可靠信号&lt;/h3&gt;

&lt;p&gt;早期Unix系统中的信号机制比较简单和原始，信号值小于 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGRTMIN&lt;/code&gt; 的信号都是 &lt;strong&gt;不可靠信号&lt;/strong&gt;。这就是 “不可靠信号” 的来源。它的主要问题是 &lt;strong&gt;信号可能丢失&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;信号值位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGRTMIN&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGRTMAX&lt;/code&gt; 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux 在支持新版本的信号安装函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigation()&lt;/code&gt; 以及信号发送函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue()&lt;/code&gt; 的同时，仍然支持早期的 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 信号安装函数，支持信号发送函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号的可靠与不可靠只与信号值有关&lt;/strong&gt;，与信号的发送及安装函数无关。目前 linux 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigation()&lt;/code&gt; 函数实现的，因此，即使通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 安装的实时信号支持排队，同样不会丢失。&lt;/p&gt;

&lt;p&gt;对于目前 linux 的两个信号安装函数：&lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 及 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction()&lt;/code&gt; 来说，它们都不能把 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGRTMIN&lt;/code&gt; 以前的信号变成可靠信号（都不支持排队，仍有可能丢失，仍然是不可靠信号），而且对SIGRTMIN以后的信号都支持排队。这两个函数的最大区别在于，经过sigaction安装的信号都能传递信息给信号处理函数，而经过signal安装的信号不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。&lt;/p&gt;

&lt;h3 id=&quot;1222-实时信号与非实时信号&quot;&gt;12.2.2 实时信号与非实时信号&lt;/h3&gt;

&lt;p&gt;早期 Unix 系统只定义了 32 种信号，前 32 种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的 CTRL ^C 时，会产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGINT&lt;/code&gt; 信号，对该信号的默认反应就是进程终止。后 32 个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;非实时信号&lt;/strong&gt; 都不支持排队，都是 &lt;strong&gt;不可靠信号&lt;/strong&gt;；&lt;strong&gt;实时信号&lt;/strong&gt; 都支持排队，都是 &lt;strong&gt;可靠信号&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1223-linux-信号列表&quot;&gt;12.2.3 Linux 信号列表&lt;/h3&gt;

&lt;p&gt;Linux 内核中的信号，每一种都用一个数字标识，它们不会携带任何参数，名字大多是自我解释的。编号为 1 ~ 31 的信号为传统 UNIX 支持的信号，是 &lt;strong&gt;不可靠信号&lt;/strong&gt;（非实时的），编号为 32 ~ 63 的信号是后来扩充的，为 &lt;strong&gt;可靠信号&lt;/strong&gt; （实时信号）。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;编号&lt;/th&gt;
      &lt;th&gt;信号&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
      &lt;th&gt;产生方法&lt;/th&gt;
      &lt;th&gt;默认动作&lt;/th&gt;
      &lt;th&gt;可忽略&lt;/th&gt;
      &lt;th&gt;可处理&lt;/th&gt;
      &lt;th&gt;可阻塞&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;SIGHUP&lt;/td&gt;
      &lt;td&gt;通知同一会话内的各个作业，告知它们与控制终端不再关联&lt;/td&gt;
      &lt;td&gt;终端连接正常或非正常结束&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;SIGINT&lt;/td&gt;
      &lt;td&gt;中断进程&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;优雅结束进程&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;SIGQUIT&lt;/td&gt;
      &lt;td&gt;终止进程，内核转储&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^\&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;SIGILL&lt;/td&gt;
      &lt;td&gt;执行了非法指令，无法恢复到默认动作&lt;/td&gt;
      &lt;td&gt;可执行文件出现错误，试图执行数据段，堆栈溢出&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;SIGTRAP&lt;/td&gt;
      &lt;td&gt;调试器用信号，无法恢复到默认动作&lt;/td&gt;
      &lt;td&gt;断点指令，其它陷阱指令&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;SIGABRT&lt;/td&gt;
      &lt;td&gt;程序本身检测到错误&lt;/td&gt;
      &lt;td&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;abort&lt;/code&gt; 函数&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;SIGBUS&lt;/td&gt;
      &lt;td&gt;非法地址，包括内存地址对齐错误&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;SIGFPE&lt;/td&gt;
      &lt;td&gt;致命算术错误&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;SIGKILL&lt;/td&gt;
      &lt;td&gt;立即终止进程，致命&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;SIGUSR1&lt;/td&gt;
      &lt;td&gt;预留给用户，用于任何自定义功能&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;SIGSEGV&lt;/td&gt;
      &lt;td&gt;分割违规&lt;/td&gt;
      &lt;td&gt;访问不属于自己存储空间或只读存储空间&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;SIGUSR2&lt;/td&gt;
      &lt;td&gt;预留给用户，用于任何自定义功能&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;SIGPIPE&lt;/td&gt;
      &lt;td&gt;管道已损坏&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;SIGALRM&lt;/td&gt;
      &lt;td&gt;测量真实时间或钟表时间的计时器超时&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alarm&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;SIGTERM&lt;/td&gt;
      &lt;td&gt;立即终止进程&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;优雅结束进程&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;SIGSTKFLT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;SIGCHLD&lt;/td&gt;
      &lt;td&gt;子进程终止或暂停&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;忽略&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;SIGCONT&lt;/td&gt;
      &lt;td&gt;让进程继续运行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;什么也不做&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;SIGSTOP&lt;/td&gt;
      &lt;td&gt;暂停进程&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -STOP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;SIGTSTP&lt;/td&gt;
      &lt;td&gt;挂起进程&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^Z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;SIGTTIN&lt;/td&gt;
      &lt;td&gt;后台作业的进程想读取终端&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;暂停进程&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;SIGTTOU&lt;/td&gt;
      &lt;td&gt;后台作业的进程想写到终端&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;暂停进程&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;SIGURG&lt;/td&gt;
      &lt;td&gt;紧急或带外数据到达套接字&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;忽略&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;SIGXCPU&lt;/td&gt;
      &lt;td&gt;超过 CPU 时间限制&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;SIGXFSZ&lt;/td&gt;
      &lt;td&gt;超出文件大小限制&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;SIGVTALRM&lt;/td&gt;
      &lt;td&gt;测量当前进程使用 CPU 时间的计时器超时&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;SIGPROF&lt;/td&gt;
      &lt;td&gt;测量当前进程使用的 CPU 时间，以及系统花在该进程上的 CPU 时间的计时器超时&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;SIGWINCH&lt;/td&gt;
      &lt;td&gt;终端窗口大小发生改变&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;忽略&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;SIGIO&lt;/td&gt;
      &lt;td&gt;文件描述符为输入输出准备就绪&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fcntl&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;忽略&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;SIGPWR&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;忽略&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;SIGSYS&lt;/td&gt;
      &lt;td&gt;非法的系统调用&lt;/td&gt;
      &lt;td&gt;执行陷阱指令&lt;/td&gt;
      &lt;td&gt;终止进程&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;SIGRTMIN&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;36&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+5&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+7&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;42&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;43&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+10&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+11&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+12&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+13&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;49&lt;/td&gt;
      &lt;td&gt;SIGRTMIN+15&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-13&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-12&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;53&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-11&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-10&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;56&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-7&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;58&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;59&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-5&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;61&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;62&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;63&lt;/td&gt;
      &lt;td&gt;SIGRTMAX-1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;SIGRTMAX&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;根据信号功能的不同，可以大致分成以下几类：&lt;/p&gt;

&lt;h4 id=&quot;程序错误信号&quot;&gt;程序错误信号&lt;/h4&gt;

&lt;p&gt;当操作系统检测到严重的程序错误时会产生以下的信号。通常这些信号表明，程序以某种方式崩溃了，一般没有办法继续运行下去了。&lt;/p&gt;

&lt;p&gt;一些程序会处理程序错误信号，以便在终止之前进行清理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;终止&lt;/strong&gt; 是大多数程序中程序错误的最终结果。&lt;/p&gt;

&lt;p&gt;所有这些信号的 &lt;strong&gt;默认操作是导致进程终止&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果您 &lt;strong&gt;阻止或忽略&lt;/strong&gt; 这些信号，或为它们建立了正常返回的处理程序，那么当这些信号发生时，您的程序可能会发生可怕的破坏，除非它们是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;raise&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 函数，而不是真正的错误产生的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;raise&lt;/code&gt; 函数用于进程给自己发送信号，&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 函数用于把信号发送给进程或进程组，它不仅可以中止进程，也可以向进程发送其他信号。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;内核转储&lt;/strong&gt;：core dump，当进程被这些程序错误信号之一终止运行时，操作系统会将此时进程地址空间的内容以及有关进程状态写出一个文件，文件名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;core&lt;/code&gt;，可保存在进程的任何当前目录。用调试器检查它们，可以调查导致错误的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;sigfpe&quot;&gt;SIGFPE&lt;/h5&gt;

&lt;p&gt;该信号报告一个 &lt;strong&gt;致命的算术错误&lt;/strong&gt;。包括几乎所有的算术错误，包括被零除及溢出。如果程序在某个位置保存了整数，然后用在了浮点运算，就会产生 “非法运算”，因为处理器无法把数据识别为浮点数字。&lt;/p&gt;

&lt;h5 id=&quot;sigill&quot;&gt;SIGILL&lt;/h5&gt;

&lt;p&gt;名字来源于 &lt;strong&gt;非法指令&lt;/strong&gt;，Illegal Instruction。通常意味着程序在尝试执 &lt;strong&gt;行垃圾指令或特权指令&lt;/strong&gt;。因为 C 编译器产生的程序只会执行合法指令，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGILL&lt;/code&gt; 通常表示可执行文件被损坏了，或者在尝试执行数据，而不是程序。&lt;/p&gt;

&lt;p&gt;当发生栈区溢出时，或当系统无法运行信号处理函数时，也会产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGILL&lt;/code&gt; 信号，&lt;/p&gt;

&lt;h5 id=&quot;sigsegv&quot;&gt;SIGSEGV&lt;/h5&gt;

&lt;p&gt;分割违规，Segmentation Violation。&lt;/p&gt;

&lt;p&gt;当程序 &lt;strong&gt;尝试在为其分配的内存以外读或写&lt;/strong&gt; 时，或者，&lt;strong&gt;尝试写入只读内存&lt;/strong&gt; 时，会产生该信号。&lt;/p&gt;

&lt;p&gt;实际上，程序走的太远，才能被系统的内存保护机制检测到，此时，信号才会出现。&lt;/p&gt;

&lt;p&gt;获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSEGV&lt;/code&gt; 条件的常用方法包括：&lt;strong&gt;解引用空指针或未初始化的指针&lt;/strong&gt;，或者当你使 &lt;strong&gt;用指针逐步遍历数组，但未能检查数组的末尾时&lt;/strong&gt;。取消引用空指针会生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSEGV&lt;/code&gt; 还是 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGBUS&lt;/code&gt;，在不同的系统中是不同的。&lt;/p&gt;

&lt;h5 id=&quot;sigbus&quot;&gt;SIGBUS&lt;/h5&gt;

&lt;p&gt;该信号的名称是 “总线错误” 的缩写。当 &lt;strong&gt;无效指针被解除引用时&lt;/strong&gt; 会生成此信号。&lt;/p&gt;

&lt;p&gt;像 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSEGV&lt;/code&gt; 一样，该信号通常是解引用未初始化的指针的结果。两者之间的区别在于 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSEGV&lt;/code&gt; 表示对有效内存的无效访问，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGBUS&lt;/code&gt; 表示访问无效地址&lt;/strong&gt;。特别是，&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGBUS&lt;/code&gt; 信号通常是由于 &lt;strong&gt;引用一个未对齐的指针&lt;/strong&gt; 而引起的，比如指向一个不能被 4 整除的地址的四字整数。（每种计算机都有自己的地址对齐要求。）&lt;/p&gt;

&lt;h5 id=&quot;sigabrt&quot;&gt;SIGABRT&lt;/h5&gt;

&lt;p&gt;该信号表示程序本身检测到错误，并通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;abort&lt;/code&gt; 进行报告。请参阅中止程序。&lt;/p&gt;

&lt;h5 id=&quot;sigiot&quot;&gt;SIGIOT&lt;/h5&gt;

&lt;p&gt;由 PDP-11 &lt;code class=&quot;highlighter-rouge&quot;&gt;iot&lt;/code&gt; 指令生成。在大多数机器上，这只是 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGABRT&lt;/code&gt; 的另一个名称。&lt;/p&gt;

&lt;h5 id=&quot;sigtrap&quot;&gt;SIGTRAP&lt;/h5&gt;

&lt;p&gt;由机器的 &lt;strong&gt;断点指令&lt;/strong&gt;（breakpoint）生成，可能还有其他 &lt;strong&gt;陷阱指令&lt;/strong&gt;（trap）。这个信号被 &lt;strong&gt;调试器&lt;/strong&gt; 使用。如果程序以某种方式执行错误的指令，你的程序可能只会看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTRAP&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;【 breakpoint 】：软件开发中，断点指程序中故意设计的暂停位置，用于调试，有时干脆就叫暂停（pause）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;【 trap 】：陷阱，也称异常或故障，是一种典型的同步中断，通常是由异常情况（如断点、零除、无效的内存访问）产生的。陷阱通常会导致切换到内核态，操作系统在返回原始进程之前会进行一些操作。在系统进程中的陷阱要比用户进程中的陷阱更严重，在某些系统中是致命的。在有些用法中，陷阱这个词单指某个中断，该中断用于启动上下文切换，到监控程序或调试器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;sigemt&quot;&gt;SIGEMT&lt;/h5&gt;

&lt;p&gt;模拟器陷​​阱。这是由某些未实现的指令造成的，这些指令可能在软件中模拟，或操作系统未能正确模拟它们。&lt;/p&gt;

&lt;h5 id=&quot;sigsys&quot;&gt;SIGSYS&lt;/h5&gt;

&lt;p&gt;坏的系统调用。也就是说，执行了向操作系统施加陷阱的指令，但系统调用执行的代码号无效。&lt;/p&gt;

&lt;h4 id=&quot;终止信号&quot;&gt;终止信号&lt;/h4&gt;

&lt;p&gt;这些信号都用于以不同的方式通知进程终止。它们的目的稍有不同，程序也希望以不同的方式来处理这些信号。&lt;/p&gt;

&lt;p&gt;处理这些信号的原因通常是为了让程序在终止之前，能够清理一下资源和数据。如，保存状态信息、删除临时文件、恢复之前的终端模式等。这一类的信号处理函数结尾时应该 &lt;strong&gt;指定响应信号的默认动作&lt;/strong&gt;，然后 &lt;strong&gt;再重新给自己发信号&lt;/strong&gt;（reraise）。&lt;/p&gt;

&lt;p&gt;以下所有信号的 &lt;strong&gt;默认动作均为终止进程&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;sigterm&quot;&gt;SIGTERM&lt;/h5&gt;

&lt;p&gt;通用的终止进程的信号，与 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 不同，该信号可被阻塞、处理、忽略。&lt;/p&gt;

&lt;p&gt;优雅地要求进程终止。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 会产生该信号。&lt;/p&gt;

&lt;h5 id=&quot;sigint&quot;&gt;SIGINT&lt;/h5&gt;

&lt;p&gt;中止进程，在终端按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;^C&lt;/code&gt; 时产生。&lt;/p&gt;

&lt;h5 id=&quot;sigquit&quot;&gt;SIGQUIT&lt;/h5&gt;

&lt;p&gt;由 “退出字符” 控制，终端按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;^\&lt;/code&gt; 会产生。它会在终止进程时产生内核转储，就像程序错误信号一样。可以认为是被用户检测到的程序错误情形。&lt;/p&gt;

&lt;p&gt;由该信号终止的进程会省略一些清理工作，如不会删除临时文件，以便用户连同内核转储一起查看。&lt;/p&gt;

&lt;h5 id=&quot;sigkill&quot;&gt;SIGKILL&lt;/h5&gt;

&lt;p&gt;立即终止进程。不能被处理、忽略、阻塞，因此是致命的信号。&lt;/p&gt;

&lt;p&gt;通常只由专门的请求来产生，因为它不能被处理，应该做为最后的措施来使用，之前应该先尝试使用不这么激烈的办法，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;^C&lt;/code&gt;。如果其它所有信号对进程都不管用时，使用该信号往往会让它马上终止。&lt;/p&gt;

&lt;p&gt;在某些异常情况下，如程序已经完全无法继续运行时（连一个信号处理函数都运行不了），系统会自动为进程产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 信号。&lt;/p&gt;

&lt;h5 id=&quot;sighup&quot;&gt;SIGHUP&lt;/h5&gt;

&lt;p&gt;hang-up，用于报告用户终端已经断开连接，也许因为网络故障。&lt;/p&gt;

&lt;p&gt;该信号还用于将 “终端上的控制进程的终止” 报告给与该会话相关联的作业，该终止在控制终端上有效地断开了会话中的所有进程。&lt;/p&gt;

&lt;p&gt;用户终端连接正常或非正常结束时发出，通常是在终端的控制进程结束时，通知同一会话内的各个作业，告知它们与控制终端不再关联。&lt;/p&gt;

&lt;p&gt;此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。&lt;/p&gt;

&lt;h4 id=&quot;闹铃信号&quot;&gt;闹铃信号&lt;/h4&gt;

&lt;p&gt;这些信号用于提醒计时器已超时。默认动作为促使进程终止，但很少使用默认动作，大多数用来交给信号处理函数执行。&lt;/p&gt;

&lt;h5 id=&quot;sigalrm&quot;&gt;SIGALRM&lt;/h5&gt;

&lt;p&gt;该信号通常表示，用来测量真实时间或钟表时间的计时器超时了，如使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;alarm&lt;/code&gt; 函数。&lt;/p&gt;

&lt;h5 id=&quot;sigvtalrm&quot;&gt;SIGVTALRM&lt;/h5&gt;

&lt;p&gt;该信号通常表示，用来测量当前进程使用 CPU 时间的计时器超时了，名字源于 virtual time alarm。&lt;/p&gt;

&lt;h5 id=&quot;sigprof&quot;&gt;SIGPROF&lt;/h5&gt;

&lt;p&gt;该信号通常表示，用于测量当前进程使用的 CPU 时间，以及系统花在该进程上的 CPU 时间的计时器超时了，这样的定时器用于实现代码分析工具。&lt;/p&gt;

&lt;h4 id=&quot;异步-io-信号&quot;&gt;异步 I/O 信号&lt;/h4&gt;

&lt;p&gt;这些信号用于和异步 I/O 设备的连接。必须通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;fcntl&lt;/code&gt; 来采取明确的动作，以促使特定的文件描述符产生这些信号，默认动作为忽略。&lt;/p&gt;

&lt;h5 id=&quot;sigio&quot;&gt;SIGIO&lt;/h5&gt;

&lt;p&gt;当一个文件描述符准备就绪，可以进行输入或输出时产生。&lt;/p&gt;

&lt;p&gt;在大多数操作系统中，终端和 socket 是能生 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGIO&lt;/code&gt; 信号的唯一类型的文件，其它类型，包括普通文件，即便你要求它们，也永远也不会产生该信号。&lt;/p&gt;

&lt;p&gt;GNU 系统中，如果使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;fcntl&lt;/code&gt; 成功地设定了异步模式，该信号就会产生。&lt;/p&gt;

&lt;h5 id=&quot;sigurg&quot;&gt;SIGURG&lt;/h5&gt;

&lt;p&gt;当 “紧急（urgent）” 或带外数据（out-of-band）到达套接字时，会发送此信号。&lt;/p&gt;

&lt;h5 id=&quot;sigpoll&quot;&gt;SIGPOLL&lt;/h5&gt;

&lt;p&gt;这是一个 System V 的信号名字，与 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGIO&lt;/code&gt; 类似，仅为兼容性定义。&lt;/p&gt;

&lt;h4 id=&quot;作业控制信号&quot;&gt;作业控制信号&lt;/h4&gt;

&lt;p&gt;这些信号用于支持作业控制。如果操作系统不支持作业控制，则这些信号无法被处理或 raise。&lt;/p&gt;

&lt;p&gt;如果不是很懂作业控制，最好不要使用这些信号。&lt;/p&gt;

&lt;h5 id=&quot;sigchld&quot;&gt;SIGCHLD&lt;/h5&gt;

&lt;p&gt;子进程终止或暂停时，会把该信号发给父进程。&lt;/p&gt;

&lt;p&gt;默认动作为忽略。&lt;/p&gt;

&lt;p&gt;如果为该信号准备了信号处理函数，但此时有被终止的子进程仍未通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitpid&lt;/code&gt; 报告自己的状态，那么，该信号处理函数是否要管理这些进程决定于不同的操作系统。&lt;/p&gt;

&lt;h5 id=&quot;sigcld&quot;&gt;SIGCLD&lt;/h5&gt;

&lt;p&gt;已过时，被 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGCHLD&lt;/code&gt;取代。&lt;/p&gt;

&lt;h5 id=&quot;sigcont&quot;&gt;SIGCONT&lt;/h5&gt;

&lt;p&gt;用于使进程继续运行。比较特殊的信号，如果进程已暂停，在信号传送之前 ，它永远会使其继续。&lt;/p&gt;

&lt;p&gt;默认动作为什么也不做。&lt;/p&gt;

&lt;p&gt;可以阻塞该信号，可以为其设定处理函数，但它永远会不管不顾地使进程继续运行。&lt;/p&gt;

&lt;h5 id=&quot;sigstop&quot;&gt;SIGSTOP&lt;/h5&gt;

&lt;p&gt;暂停进程，不可捕获、忽略、阻塞。&lt;/p&gt;

&lt;h5 id=&quot;sigtstp&quot;&gt;SIGTSTP&lt;/h5&gt;

&lt;p&gt;交互式暂停信号，与 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 不同，该信号可捕获、忽略。&lt;/p&gt;

&lt;p&gt;如果你想在进程暂停时，让文件或系统表处于安全状态，就需要用函数来捕获该信号。例如，关闭屏显的程序应该捕获 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTSTP&lt;/code&gt;，以便它们暂停之前能恢复屏显。&lt;/p&gt;

&lt;p&gt;当用户键入 SUSP 字符时（^Z）会产生。&lt;/p&gt;

&lt;h5 id=&quot;sigttin&quot;&gt;SIGTTIN&lt;/h5&gt;

&lt;p&gt;当进程作为后台作业运行时，无法从用户终端读取。如果后台进程尝试读取终端，作业中的所有进程都会收到一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTTIN&lt;/code&gt; 信号，默认动作为暂停进程。&lt;/p&gt;

&lt;h5 id=&quot;sigttou&quot;&gt;SIGTTOU&lt;/h5&gt;

&lt;p&gt;当后台进程尝试向终端写入，或尝试设置终端模式时，产生该信号。&lt;/p&gt;

&lt;p&gt;默认动作为暂停进程。&lt;/p&gt;

&lt;p&gt;只有在开启了 &lt;code class=&quot;highlighter-rouge&quot;&gt;TOSTOP&lt;/code&gt; 模式的情况下，尝试写入终端才会产生该信号。&lt;/p&gt;

&lt;p&gt;当进程暂停时，不会再给它传递任何信号，直到它又继续运行，当然，除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGCONT&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;暂停期间，想要传递给进程的信号会标记为挂起（pending），直到其运行再传递给它。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 信号永远会让进程终止，不能被阻塞、捕获、忽略。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGCONT&lt;/code&gt; 虽然可以被忽略，但它不管怎么样都会让暂停的进程继续运行。&lt;/p&gt;

&lt;p&gt;给进程发送 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGCONT&lt;/code&gt; 信号，会促使任何挂起的暂停信号被丢弃。同样，任何挂起的 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGCONT&lt;/code&gt; 信号，当进程收到暂停信号时都会被丢弃。&lt;/p&gt;

&lt;p&gt;如果孤儿进程组中的一个进程收到 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTSTP&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTTIN&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTTOU&lt;/code&gt; 信号，但不予捕获，进程就不会暂停。暂停该进程其实没什么用了，因为不会有 shell 程序会注意到它暂停，然后再允许用户继续运行它。取而代之的是，取决于在用的操作系统，有些系统什么也不会做，还有些系统会发送另一个信号，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGHUP&lt;/code&gt;。在 GNU 系统中，进程遇到 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 就会死掉，由此避免了过多的暂停进程或孤儿进程在系统驻留可能引发的问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;【 孤儿进程组 】：当一个控制进程终止时，它的终端变得可用，可在上面新建起一个会话。实际上，其它用户可以登陆到该终端。如果原会话中的任何进程仍然尝试使用该终端时，会造成问题。为了防止问题的发生，当会话发起者被终止时，进程组仍需继续运行，称为孤儿进程组。
当进程组变成孤儿时，其中的进程都会收到一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGHUP&lt;/code&gt; 信号，一般情况会造成进程终止，但如果进程忽略该信号，或建立一个信号处理函数，它就可以继续运行于孤儿进程组中，即便其控制进程已经终止，但它仍然再也无法访问终端了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;操作错误信号&quot;&gt;操作错误信号&lt;/h4&gt;

&lt;p&gt;这些信号用于报告由于程序操作引起的各种错误。并不是程序内部的程序错误，而是导致操作系统调用无法顺利完成的错误。&lt;/p&gt;

&lt;p&gt;所有信号的默认动作均为终止进程。&lt;/p&gt;

&lt;h5 id=&quot;sigpipe&quot;&gt;SIGPIPE&lt;/h5&gt;

&lt;p&gt;管道已损坏。&lt;/p&gt;

&lt;p&gt;如果使用管道或 FIFO，你必须精心设计你的程序，必须先用一个进程来打开管道读取，然后才能允许其它进程开始写入。如果读取进程始终没有运行，或异常终止，写入管道会产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGPIPE&lt;/code&gt; 信号。&lt;/p&gt;

&lt;p&gt;如果该信号被阻塞、捕获或忽略，则违规呼叫将以 &lt;code class=&quot;highlighter-rouge&quot;&gt;EPIPE&lt;/code&gt; 而失败。&lt;/p&gt;

&lt;p&gt;如果尝试向一个已断开的套接字输出也会产生该信号。&lt;/p&gt;

&lt;h5 id=&quot;siglost&quot;&gt;SIGLOST&lt;/h5&gt;

&lt;p&gt;资源丢失。&lt;/p&gt;

&lt;p&gt;当你对 NFS 文件进行咨询锁定时，NFS 服务器重启了，并忘记锁定这回事了，此时会产生该信号。&lt;/p&gt;

&lt;p&gt;在 GNU 系统中，当服务进程异常死掉时会产生该信号，可以忽略该信号。&lt;/p&gt;

&lt;p&gt;无论使用了什么调用都会返回一个错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据 man SIGNAL(7)，Linux 中，&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGIO&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGLOST&lt;/code&gt; 使用同一个编号，29。&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGLOST&lt;/code&gt; 在内核中被注释掉了，但某些软件编译过程中，仍然会把 29 当作 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGLOST&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;sigxcpu&quot;&gt;SIGXCPU&lt;/h5&gt;

&lt;p&gt;超出了 CPU 时间限制。&lt;/p&gt;

&lt;p&gt;当进程超过了其在 CPU 时间上的软件资源限制时会产生该信号。&lt;/p&gt;

&lt;h5 id=&quot;sigxfsz&quot;&gt;SIGXFSZ&lt;/h5&gt;

&lt;p&gt;超出文件大小限制。&lt;/p&gt;

&lt;p&gt;当进程尝试扩展文件大小，超出进程软件资源在文件大小的限制时，会产生该信号。&lt;/p&gt;

&lt;h4 id=&quot;其他信号&quot;&gt;其他信号&lt;/h4&gt;

&lt;p&gt;这些信号用于各种不同的目的，它们通常不会影响进程，除非为了什么明确地使用它们。&lt;/p&gt;

&lt;h5 id=&quot;sigusr1sigusr2&quot;&gt;SIGUSR1、SIGUSR2&lt;/h5&gt;

&lt;p&gt;预留给用户，用于任何自定义功能。&lt;/p&gt;

&lt;p&gt;可用于简单的进程间通讯。&lt;/p&gt;

&lt;p&gt;默认动作为终止进程。&lt;/p&gt;

&lt;h5 id=&quot;sigwinch&quot;&gt;SIGWINCH&lt;/h5&gt;

&lt;p&gt;Window size change，改变窗口大小。&lt;/p&gt;

&lt;p&gt;当终端驱动程序记录屏幕上的行数和列数发生变化时，产生该信号。&lt;/p&gt;

&lt;p&gt;默认动作为忽略。&lt;/p&gt;

&lt;h5 id=&quot;siginfo&quot;&gt;SIGINFO&lt;/h5&gt;

&lt;p&gt;显示系统、进程状态信息&lt;/p&gt;

&lt;p&gt;当用户在终端的规范模式（canonical mode）下键入 STATUS 字符时，该信号被发送到控制终端的前台进程组中的所有进程。&lt;/p&gt;

&lt;p&gt;如果该进程是进程组的首领（leader），默认动作是显示一些关于系统及进程当前行为的状态信息，否则默认动作为什么都不做。&lt;/p&gt;

&lt;p&gt;该信号只对 alpha 和 sparc 架构的系统可用。&lt;/p&gt;

&lt;h2 id=&quot;123-信号的生命周期&quot;&gt;12.3 信号的生命周期&lt;/h2&gt;

&lt;p&gt;对于一个完整的信号生命周期（从信号发送到相应的处理函数执行完毕）来说，可以分为三个阶段：&lt;/p&gt;

&lt;h3 id=&quot;1231-信号的产生&quot;&gt;12.3.1 信号的产生&lt;/h3&gt;

&lt;h4 id=&quot;产生信号的事件&quot;&gt;产生信号的事件&lt;/h4&gt;

&lt;p&gt;通常来说，产生信号的事件主要可归结为以下三类：&lt;strong&gt;错误、外部事件、显式请求&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;错误&quot;&gt;错误&lt;/h5&gt;

&lt;p&gt;错误意味着某个程序做了非法的事情，无法继续执行下去了。但并非所有类型的错误都会产生信号 – 事实上，大多数情况下不会。例如，打开一个不存在的文件是一个错误，但它不会产生一个信号；相反，&lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;。通常，通过返回指示错误的值，来报告与某些库函数相关的错误。引发信号的错误可能发生在程序中的任何地方，而不仅仅是在库调用中。这些包括除以零和无效的内存地址。&lt;/p&gt;

&lt;h5 id=&quot;外部事件&quot;&gt;外部事件&lt;/h5&gt;

&lt;p&gt;部事件通常与 I/O 或其他进程有关。这些包括输入的到达，计时器的到期以及子进程的终止。&lt;/p&gt;

&lt;h5 id=&quot;显式请求&quot;&gt;显式请求&lt;/h5&gt;

&lt;p&gt;显式请求意味着使用库函数，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;，其目的很明确，就是为了生成一个信号。&lt;/p&gt;

&lt;h4 id=&quot;信号产生的时机&quot;&gt;信号产生的时机&lt;/h4&gt;

&lt;p&gt;信号可以 &lt;strong&gt;同步生成&lt;/strong&gt; 或 &lt;strong&gt;异步生成&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;同步&quot;&gt;同步&lt;/h5&gt;

&lt;p&gt;同步信号 &lt;strong&gt;与程序中的特定操作有关&lt;/strong&gt;，并在该操作期间传递（除非被阻塞）。&lt;/p&gt;

&lt;p&gt;大多数 &lt;strong&gt;错误&lt;/strong&gt; 会同步地生成信号，进程为自己生成信号的 &lt;strong&gt;显式请求&lt;/strong&gt; 也是同步产生。&lt;/p&gt;

&lt;p&gt;在某些机器上，某些类型的硬件错误（通常是浮点异常）不会完全同步地报告，而是会在运行几个指令之后。。&lt;/p&gt;

&lt;h5 id=&quot;异步&quot;&gt;异步&lt;/h5&gt;

&lt;p&gt;生成异步信号的事件，往往 &lt;strong&gt;不受进程的控制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在进程执行期间，这些信号到达的时间是不可预测的。&lt;strong&gt;外部事件&lt;/strong&gt; 会异步生成信号，对进程的 &lt;strong&gt;显式请求&lt;/strong&gt; 也是异步生成信号。&lt;/p&gt;

&lt;p&gt;给定类型的信号通常要么是同步的，要么是异步的。例如，错误信号通常是同步的，因为错误会同步地产生信号。但是任何类型的信号都可以通过 &lt;strong&gt;显示请求&lt;/strong&gt; &lt;strong&gt;同步或异步生成&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;生成信号&quot;&gt;生成信号&lt;/h4&gt;

&lt;p&gt;除了由于硬件陷阱或中断而产生的信号之外，程序可以显示地（explicitly）将信号发送给自己或另一个进程。&lt;/p&gt;

&lt;h5 id=&quot;给自己发信号&quot;&gt;给自己发信号&lt;/h5&gt;

&lt;p&gt;进程可以给使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;raise&lt;/code&gt; 函数来自己发信号，该函数声明于 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal.h&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;raise&lt;/code&gt; 的用途之一是 &lt;strong&gt;重现&lt;/strong&gt; 你已捕获的信号的 &lt;strong&gt;默认行为&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如可以做到：当收到一个暂停信号时，可以把响应重新设为默认动作，然后执行一些清理工作，再重新发送一遍暂停信号。当进程重新继续时，再恢复信号处理器。&lt;/p&gt;

&lt;h5 id=&quot;给另一进程发信号&quot;&gt;给另一进程发信号&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 函数可用于向另一个进程发送信号。虽然它的名字代表杀掉进程，但实际上它还可以用于许多其它的目的。比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;父进程启动一个子进程来执行一项任务，也许让其处于一个无限循环，当不再需要该任务时，就结束它。&lt;/li&gt;
  &lt;li&gt;一个进程做为进程组的一部分执行任务时，需要终止掉，或遇到错误及其它事件时，需要通知其它进程。&lt;/li&gt;
  &lt;li&gt;两个进程协同工作时，需要同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当进程给自己发一个信号时，如果该信号没有被阻塞，在进程返回之前，&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 会传递至少一个信号给进程，但该信号不一定非的是刚刚发给自己的这个信号，也有可能是其它挂起的、未阻塞的信号。&lt;/p&gt;

&lt;p&gt;如果信号可以成功发送，&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 的返回值为零。否则，不会发送信号，返回值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; （&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 函数的参数）指定了向多个进程发送一个信号，如果它能向至少一个进程发送信号，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 就成功了。你无法区分是一个进程收到了信号，还是所有进程都收到了。&lt;/p&gt;

&lt;h5 id=&quot;使用-kill-的权限&quot;&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 的权限&lt;/h5&gt;

&lt;p&gt;你是无法用 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 把信号发送给任意的随机进程的，因为存在一些限制。这些限制旨在防止反社会行为，例如任意杀死属于另一用户的进程。&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 比较典型的使用，还是在父、子、兄弟进程之间传递信号，在这些情况下，你通常有权发送信号。唯一常见的例外，是在子进程中运行 setuid 程序。如果程序更改了其真实 UID 以及其有效 UID，你就可能不再有权限来发送信号了。&lt;code class=&quot;highlighter-rouge&quot;&gt;su&lt;/code&gt; 就是这样的程序。&lt;/p&gt;

&lt;p&gt;一个进程是否有权给另一个进程发信号，由两个进程的 UID 决定的。&lt;/p&gt;

&lt;p&gt;通常，一个进程要想给另一个进程发信号，要么 &lt;strong&gt;发送进程属于特权用户&lt;/strong&gt;（如 root），要么 &lt;strong&gt;发送进程的真实 UID 或有效 UID 与接收进程的相匹配&lt;/strong&gt;。如果接收进程已从其映像文件上的 SUID 模式位更改了其有效 UID，则进程映像文件的所有者会被用来代替其当前有效 UID。在一些实施方案中，即使 UID 不匹配，父进程也能够将信号发送到子进程，而其他实施方案则可能会用别的限制。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGCONT&lt;/code&gt; 信号是一种特殊情况。如果发送进程与接收进程处于同一个会话，则可以发送，而不考虑 UID。&lt;/p&gt;

&lt;h3 id=&quot;1232-信号在目标进程中注册&quot;&gt;12.3.2 信号在目标进程中注册&lt;/h3&gt;

&lt;p&gt;在 &lt;strong&gt;进程表的表项&lt;/strong&gt; 中有一个 &lt;strong&gt;软中断信号域&lt;/strong&gt;，该域中每一位对应一个信号。&lt;/p&gt;

&lt;p&gt;内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果信号发送给一个正在睡眠的进程，如果进程为可中断睡眠，则唤醒进程&lt;/li&gt;
  &lt;li&gt;如果进程为不可中断睡眠，则仅设置进程表中信号域相应的位，而不唤醒进程&lt;/li&gt;
  &lt;li&gt;如果进程处于就绪状态，则仅设置进程表中信号域相应的位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个 &lt;strong&gt;实时信号&lt;/strong&gt; 发送给一个进程时，不管该信号是否已经在进程中注册，都会被 &lt;strong&gt;再注册一次&lt;/strong&gt;，因此，信号不会丢失，因此，实时信号又叫做 “可靠信号”。&lt;/p&gt;

&lt;p&gt;当一个 &lt;strong&gt;非实时信号&lt;/strong&gt; 发送给一个进程时，如果该信号已经在进程中注册，则该信号将被 &lt;strong&gt;丢弃&lt;/strong&gt;，造成信号丢失。因此，非实时信号又叫做 “不可靠信号”。&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;因此，&lt;strong&gt;信号是否可靠只与信号值有关&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1233-信号的执行和注销&quot;&gt;12.3.3 信号的执行和注销&lt;/h3&gt;

&lt;p&gt;内核处理一个进程收到的软中断信号是在该 &lt;strong&gt;进程的上下文&lt;/strong&gt; 中，因此，&lt;strong&gt;进程必须处于运行状态&lt;/strong&gt;。当其由于被信号唤醒或者正常调度重新获得 CPU 时，在其从内核空间返回到用户空间时，会检测是否有信号等待处理。如果存在未决信号等待处理，且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉。&lt;/p&gt;

&lt;p&gt;对于 &lt;strong&gt;非实时信号&lt;/strong&gt; 来说，由于在未决信号信息链中最多只 &lt;strong&gt;占用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt;&lt;/strong&gt; 结构，因此该结构被释放后，应该 &lt;strong&gt;把信号在进程未决信号集中删除&lt;/strong&gt;（信号注销完毕）；&lt;/p&gt;

&lt;p&gt;而对于 &lt;strong&gt;实时信号&lt;/strong&gt; 来说，可能在未决信号信息链中占用多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 结构，因此应该针对占用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 结构的数目区别对待：如果只 &lt;strong&gt;占用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt;&lt;/strong&gt; 结构（进程只收到该信号一次），则执行完相应的处理函数后，应该 &lt;strong&gt;把信号在进程的未决信号集中删除&lt;/strong&gt;（信号注销完毕）。如果 &lt;strong&gt;占用多个&lt;/strong&gt;，则 &lt;strong&gt;要等待该信号的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 处理完毕&lt;/strong&gt; 后再在进程的未决信号 &lt;strong&gt;集中删除&lt;/strong&gt; 该信号。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;信号屏蔽字：就是进程中被阻塞的信号集，这些信号不能发送给该进程，它们在该进程中被 “屏蔽” 了.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。对于被屏蔽的信号，当取消屏蔽后，在返回到用户空间时会再次执行上述检查处理的一套流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核处理&lt;/strong&gt; 一个进程收到的 &lt;strong&gt;信号的时机&lt;/strong&gt;，是在一个 &lt;strong&gt;进程从内核态返回用户态&lt;/strong&gt; 时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。&lt;strong&gt;进程只有处理完信号才会返回用户态&lt;/strong&gt;，&lt;strong&gt;进程在用户态下不会有未处理完的信号&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1234-信号的传递&quot;&gt;12.3.4 信号的传递&lt;/h3&gt;

&lt;p&gt;信号被生成时，一开始先是被 &lt;strong&gt;挂起&lt;/strong&gt;（pending）。但通常只在挂起状态停留很小一段时间，然后就会被 &lt;strong&gt;传递&lt;/strong&gt; 给进程。然而，如果这类的信号当前 &lt;strong&gt;被阻塞&lt;/strong&gt;，它就有可能无限期地停留在挂起状态，直到这种信号被 &lt;strong&gt;解阻&lt;/strong&gt;（unblocked）。一旦被解阻，它就会立即被传递出去。&lt;/p&gt;

&lt;p&gt;传递信号时，无论是立即传递出去，还是长时间延迟之后才传递出去，都会引起程序的 &lt;strong&gt;特定动作&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于某些信号，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt;，采取的动作是固定的，但对于大多数信号，程序有一个选择：&lt;strong&gt;忽略&lt;/strong&gt; 信号、&lt;strong&gt;指定处理函数&lt;/strong&gt; 或 &lt;strong&gt;接受&lt;/strong&gt; 该类信号的 &lt;strong&gt;默认动作&lt;/strong&gt;。程序会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction&lt;/code&gt; 等函数来设定其选择。我们有时会说处理函数 &lt;strong&gt;捕捉到&lt;/strong&gt; 信号。当运行处理程序时，该信号通常处于被阻塞状态。&lt;/p&gt;

&lt;p&gt;如果对某种信号设定的默认动作为忽略，则所产生的任何此类信号当即就会被丢弃。即使信号在此时被阻塞，也会发生这种情况。以这种方式被丢弃的信号将永远不会被传送，即使程序随后为该类信号指定了不同的动作，然后解除阻止。&lt;/p&gt;

&lt;p&gt;如果信号到达时，程序既没有处理也没有忽略，其默认动作就上场了。每种信号都有其自己的默认动作。对于大多数信号，默认操作是终止进程。对于那些代表 “无害” 事件的信号，默认行为是什么都不做。&lt;/p&gt;

&lt;p&gt;当信号终止进程时，其父进程可以通过检查由 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitpid&lt;/code&gt; 函数报告的终止状态代码来确定终止的原因。它可以通过获得的信息来确认：子进程的终止，是由一个信号及其涉及的同类信号引起的。如果在 shell 中运行的程序被信号终止，shell 通常会打印出一些错误消息。&lt;/p&gt;

&lt;p&gt;通常用于代表程序错误的信号具有一个特殊的属性：当一个信号终止进程时，它还会写入一个核心转储文件，该文件会记录终止时进程的状态。你可以使用调试器来检查核心转储，以调查导致错误的原因。&lt;/p&gt;

&lt;p&gt;如果你通过显示请求引发了 “程序错误” 信号，并且导致了进程的终止，那么它就会生成一个核心转储文件，就好像该信号是由于错误直接引发的一样。&lt;/p&gt;

&lt;p&gt;如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回、弹出栈顶时，就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。这样做的原因是，用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）。&lt;/p&gt;

&lt;h4 id=&quot;传递信号的命令&quot;&gt;传递信号的命令&lt;/h4&gt;

&lt;h5 id=&quot;kill&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -signal PID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用 kill 把信号传递给指定作业（%jobnumber）或进程（PID）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -SIGHUP $(ps aux | grep 'rsyslogd' | grep -v 'grep'| awk '{print $2}')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;killall&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall -signal command&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall&lt;/code&gt; 可以直接指定发送信号的进程名称。可以杀掉所有指定名称的进程，用于杀服务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall [-iIe] [command name]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;   交互式&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt;   指定里程准确名称&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-I&lt;/code&gt;   进程名称忽略大小写&lt;/p&gt;

&lt;p&gt;范例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall -1 rsyslogd&lt;/code&gt;  给 rsyslogd 启动的 PID 发送 SIGHUP 信号&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall -9 httpd&lt;/code&gt;  强制终止所有 httpd 启动的进程&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;killall -i -9 bash&lt;/code&gt;  依次询问每个 bash 进程是否需要被终止&lt;/p&gt;

&lt;h2 id=&quot;124-信号的阻塞&quot;&gt;12.4 信号的阻塞&lt;/h2&gt;

&lt;p&gt;阻塞信号意味着告诉操作系统先按住它（hold），稍后再传送。一般来说，程序不会无限期地阻塞信号 – 也有可能通过设置动作为 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIG_IGN&lt;/code&gt; 来忽略它们。但是暂时阻塞信号是很有用的，可以防止它们中断敏感的操作。如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在你修改全局变量时，如果这些变量也会被某些信号的处理器修改，可以使用函数来阻塞这些信号&lt;/li&gt;
  &lt;li&gt;在特定的信号处理器运行时，你可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction&lt;/code&gt; 调用中设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;sa_mask&lt;/code&gt;，来阻塞某些信号，以保证信号处理器运行时不会被信号中断&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1241-为什么要阻塞&quot;&gt;12.4.1 为什么要阻塞&lt;/h3&gt;

&lt;p&gt;临时阻塞信号可以 &lt;strong&gt;防止运行重要代码时被中断&lt;/strong&gt;，此收到的信号会在解阻之后传递给进程。&lt;/p&gt;

&lt;p&gt;有时阻塞会使 &lt;strong&gt;程序变的更加可靠&lt;/strong&gt;。如信号处理器以外的其它代码在检查或修改数据期间，可以阻塞特定的信号，不让信号处理函数在引期间运行。&lt;/p&gt;

&lt;p&gt;如果希望只有当 &lt;strong&gt;信号尚未到达时，才想执行特定的操作&lt;/strong&gt;，则阻塞信号也是必要的。&lt;/p&gt;

&lt;p&gt;想要 &lt;strong&gt;测试信号是否到达&lt;/strong&gt; 的唯一可靠方法，就是在信号被阻塞时进行测试。&lt;/p&gt;

&lt;h3 id=&quot;1242-信号集&quot;&gt;12.4.2 信号集&lt;/h3&gt;

&lt;p&gt;所有的信号阻塞函数都使用一种数据结构，称为信号集（signal set），用来 &lt;strong&gt;指定哪些信号会受到影响&lt;/strong&gt;。因此，每个活动都涉及两个阶段：创建信号集，然后将其做为参数传给一个库函数。&lt;/p&gt;

&lt;h3 id=&quot;1243-进程信号掩码&quot;&gt;12.4.3 进程信号掩码&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;当前被阻塞的信号集合&lt;/strong&gt; 称为信号掩码（signal mask），每个进程都有其自己的信号掩码，创建新进程时，它会继承父进程的信号掩码。通过设置信号掩码，你可以 &lt;strong&gt;灵活地施加阻塞或解阻&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在多线程进程中，每个线程都有其自己的信号掩码，不存在唯一的进程掩码。&lt;/p&gt;

&lt;h3 id=&quot;1244-测试信号的传递&quot;&gt;12.4.4 测试信号的传递&lt;/h3&gt;

&lt;p&gt;阻塞可用于测试信号的传递，可以临时把会影响测试的信号阻塞，避免对测试造成中断。&lt;/p&gt;

&lt;h3 id=&quot;1245-为信号处理器阻塞&quot;&gt;12.4.5 为信号处理器阻塞&lt;/h3&gt;

&lt;p&gt;如果要使用信号处理器，你通常希望它能够完成其运行，期间不受其它信号的打扰。从信号处理器开始运行，直到其结束，期间必须阻塞可能引起混乱或损坏其数据的信号。&lt;/p&gt;

&lt;p&gt;如果要拿信号处理函数来对付信号，在处理函数运行期间，该信号会自动阻塞（加入到该进程的信号掩码中）。例如，如果针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTSTP&lt;/code&gt; 设定了处理函数，则信号到来时，处理函数运行期间，将会迫使随后的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTSTP&lt;/code&gt; 信号全部等待。&lt;/p&gt;

&lt;p&gt;然而，默认情况下，其它类型的信号不会被阻塞，在处理函数运行期间，它们可以正常抵达。&lt;/p&gt;

&lt;p&gt;在任何情况下，当处理程序返回时，系统将恢复在处理程序之前就位的掩码。如果有任何未决信号在挂起，则该进程将立即收到这些信号，然后才继续执行下面的代码。&lt;/p&gt;

&lt;h3 id=&quot;1246-检查挂起的信号&quot;&gt;12.4.6 检查挂起的信号&lt;/h3&gt;

&lt;p&gt;可以随时通过系统调用来查看哪些信号正在挂起。检查某个信号是否在挂起的测试，通常并没有什么用处。如果在该信号没有被阻塞的情况下来测试，则更是个坏主意。&lt;/p&gt;

&lt;p&gt;如果有一种特定的信号在为进程挂起，随后到达的更多相同类型的信号很可能会被丢弃。比如，如果有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGINT&lt;/code&gt; 信号正在挂起，此时另一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGINT&lt;/code&gt; 信号到来，当解阻该信号时，程序很有可能只会看到其中的一个。&lt;/p&gt;

&lt;h3 id=&quot;1247-记住一个信号&quot;&gt;12.4.7 记住一个信号&lt;/h3&gt;

&lt;p&gt;记住一个信号，稍后再有所行动。&lt;/p&gt;

&lt;p&gt;除了使用库功能来阻塞信号，还可以让处理程序设置一个标签随后来测试，同样可以直到和阻塞相同的效果。&lt;/p&gt;

&lt;h2 id=&quot;125-等待信号&quot;&gt;12.5 等待信号&lt;/h2&gt;

&lt;p&gt;如果程序是由外部事件驱动的，或者需要使用信号来同步，当它无事可做时，可能需要等待，直到某个信号到来。&lt;/p&gt;

&lt;h3 id=&quot;1251-使用-pause-函数&quot;&gt;12.5.1 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt; 函数&lt;/h3&gt;

&lt;p&gt;让进程进入等待直到信号到来，最简单的方法是调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt; 函数。它会暂停程序的执行，直到收到信号处理器被执行，或是进程终止。&lt;/p&gt;

&lt;p&gt;如果信号促使处理函数被执行，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt; 返回。这被认为是一个不成功的返回，（因为成功的行为应该是永远暂停程序），因此返回值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1252-pause-的问题&quot;&gt;12.5.2 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt; 的问题&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt; 的简单性会隐藏严重的时间错误，这些错误会使程序神秘地挂起。&lt;/p&gt;

&lt;p&gt;如果程序的真正工作是由信号处理器自己完成的，则可以安全的使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt;，主程序除了调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt; 就什么也不做。每次有信号被传递时，处理程序会做后继的批量工作，然后再返回，于是程序的主循环再次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;直到等来一个或多个信号，才能安全地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt;，然后再继续真正的工作。即便想办法让信号处理程序通过设置标签来从中协调，也仍然无法可靠地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pause&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1253-使用-sigsuspend&quot;&gt;12.5.3 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigsuspend&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;等待信号的干净、可靠的方法就是阻塞它，然后再使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigsuspend&lt;/code&gt;。通过在循环中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigsuspend&lt;/code&gt; 函数，可以等待特定类别的信号，同时允许其他类型的信号交给各自的处理程序。&lt;/p&gt;

&lt;h2 id=&quot;126-信号的安装&quot;&gt;12.6 信号的安装&lt;/h2&gt;

&lt;p&gt;如果 &lt;strong&gt;进程要处理某一信号&lt;/strong&gt;，那么就 &lt;strong&gt;要在进程中安装该信号&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1261-为什么要安装&quot;&gt;12.6.1 为什么要安装&lt;/h3&gt;

&lt;p&gt;安装信号主要用来确定 &lt;strong&gt;信号值&lt;/strong&gt; 及进程针对该信号值的 &lt;strong&gt;动作&lt;/strong&gt; 之间的 &lt;strong&gt;映射关系&lt;/strong&gt;，即进程将要处理哪个信号，该信号被传递给进程时，将执行何种操作。&lt;/p&gt;

&lt;h3 id=&quot;1261-如何安装&quot;&gt;12.6.1 如何安装&lt;/h3&gt;

&lt;p&gt;linux 主要有两个函数实现信号的安装：&lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt;：只有两个参数，不支持信号传递信息，主要是用于前 32 种 &lt;strong&gt;非实时信号的安装&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction()&lt;/code&gt;：是 &lt;strong&gt;较新&lt;/strong&gt; 的函数，由 &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_signal&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_rt_sigaction&lt;/code&gt; 这两个系统调用实现，有三个参数，&lt;strong&gt;支持信号传递信息&lt;/strong&gt;，主要用来与 &lt;code class=&quot;highlighter-rouge&quot;&gt;sigqueue()&lt;/code&gt; 系统调用配合使用。&lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction()&lt;/code&gt; 同样 &lt;strong&gt;支持非实时信号的安装&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sigaction()&lt;/code&gt; 优于 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 主要体现在 &lt;strong&gt;支持信号携带参数&lt;/strong&gt;。&lt;/p&gt;</content><author><name></name></author><category term="信号" /><category term="linux" /></entry></feed>