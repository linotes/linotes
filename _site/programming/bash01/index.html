<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Bash 入门 01 - LINOTES</title>
<meta name="description" content="Bash 与 Bash 脚本，脚本的编写与调试，Bash 环境">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Bash 入门 01">
<meta property="og:url" content="https://linotes.netlify.com/programming/bash01/">


  <meta property="og:description" content="Bash 与 Bash 脚本，脚本的编写与调试，Bash 环境">



  <meta property="og:image" content="https://linotes.netlify.com/assets/images/header/backup.jpg">





  <meta property="article:published_time" content="2017-05-03T00:00:00+08:00">






<link rel="canonical" href="https://linotes.netlify.com/programming/bash01/">













<!-- end _includes/seo.html -->


<link href="https://linotes.netlify.com/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://linotes.netlify.com/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->






<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://linotes.netlify.com/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/app/rsync/" >Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/server/vsftpd/" >Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/kernel/filedescriptor/" >文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/tools/tools.datastream/" >数据流处理</a>
            </li>
          
        </ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://linotes.netlify.com/assets/images/header/backup.jpg');"
>
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Bash 入门 01

        
      </h1>
      
        <p class="page__lead">Bash 与 Bash 脚本，脚本的编写与调试，Bash 环境
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://linotes.netlify.com/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:imhawkz@gmail.com">
            <meta itemprop="email" content="imhawkz@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Bash 入门 01">
    <meta itemprop="description" content="Bash 与 Bash 脚本，脚本的编写与调试，Bash 环境">
    <meta itemprop="datePublished" content="May 03, 2017">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-code"></i> Bash 入门 01</h4></header>
              <ul class="toc__menu">
  <li><a href="#1-bash-与-bash-脚本">1. Bash 与 Bash 脚本</a>
    <ul>
      <li><a href="#11-常用的-shell-程序">1.1 常用的 shell 程序</a></li>
      <li><a href="#12-bash-的优势">1.2 Bash 的优势</a></li>
      <li><a href="#13-命令的执行">1.3 命令的执行</a></li>
      <li><a href="#14-shell-的标准组件">1.4 Shell 的标准组件</a></li>
      <li><a href="#15-开发好脚本">1.5 开发好脚本</a></li>
    </ul>
  </li>
  <li><a href="#2-脚本的编写与调试">2. 脚本的编写与调试</a>
    <ul>
      <li><a href="#21-创建脚本并运行">2.1 创建脚本并运行</a></li>
      <li><a href="#22-脚本基础">2.2 脚本基础</a></li>
      <li><a href="#23-调试-bash-脚本">2.3 调试 bash 脚本</a></li>
    </ul>
  </li>
  <li><a href="#3-bash-环境">3. bash 环境</a>
    <ul>
      <li><a href="#31-shell-初始化文件">3.1 shell 初始化文件</a></li>
      <li><a href="#32-变量">3.2 变量</a></li>
      <li><a href="#33-对字符的引用">3.3 对字符的引用</a></li>
      <li><a href="#34-shell-扩展">3.4 shell 扩展</a></li>
      <li><a href="#35-别名">3.5 别名</a></li>
      <li><a href="#36-bash-其它选项">3.6 bash 其它选项</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p>Bash Guide for Beginners is a good book.</p>

<p><a href="http://www.tldp.org/LDP/Bash-Beginners-Guide/html/index.html">《 Bash Guide for Beginners 》</a></p>

<h2 id="1-bash-与-bash-脚本">1. Bash 与 Bash 脚本</h2>

<blockquote>
  <p>空白字符：空格或制表符</p>
</blockquote>

<h3 id="11-常用的-shell-程序">1.1 常用的 shell 程序</h3>

<p>UNIX 的 shell 程序可以解释用户的命令，无论是用户直接输入的，还是从 shell 脚本读取的。</p>

<p>Shell 脚本是 <strong>解释</strong> 型的，而不是编译型的。Shell 从脚本的每一行读取命令，并在系统中搜索这些命令。</p>

<p>脚本中可以使用可执行文件。</p>

<p>除了向内核传送命令之外，shell 的主要任务是提供一个用户环境，该环境可用 shell 配置文件来单独配置。</p>

<h4 id="shell-类型">shell 类型</h4>

<h5 id="sh">sh</h5>

<p>即 Bourne Shell。它是最早的 shell，现在仍在使用。</p>

<p>它是基本的 shell，特性不多。虽不是标准的 shell，但为了 UNIX 程序的兼容性，仍存在于每个 Linux 系统中。</p>

<h5 id="bash">bash</h5>

<p>Bourne Again shell。标准的 GNU shell，直观而又灵活。</p>

<p>初学者最明智的选择，同时对高级和专业用户来说也是一个强有力的工具。在 Linux 上，bash 是普通用户的标准 shell。这个 shell 因此称为 Bourne shell 的超集，一套附件和插件。</p>

<p>bash 与 sh 是兼容的：在 sh 中可以工作的命令，在 bash 中也能工作，反之则不然。</p>

<h5 id="csh">csh</h5>

<p>C shell。语法类似于 C 语言，某些时候程序员会使用。</p>

<h5 id="tcsh">tcsh</h5>

<p>Turbo C shell。普通 C shell 的超集，加强了的用户友好度和速度。</p>

<h5 id="ksh">ksh</h5>

<p>Korn shell。有时被有 UNIX 背景的人所赏识。</p>

<p>Bourne shell 的一个超集，有着对初学者来说就是一场恶梦的标准配置。</p>

<h4 id="相关文件">相关文件</h4>

<p><code class="highlighter-rouge">/etc/shells</code>  文件中保存了当前系统存在的 shell。</p>

<p><code class="highlighter-rouge">/etc/passwd</code>  文件中，每个用户都有自己默认 shell 的设置。</p>

<h4 id="shell-的切换">shell 的切换</h4>

<p>要从一个 shell 转换到另外一个，只需在当前终端输入新 shell 的文件名。</p>

<p>系统在 <code class="highlighter-rouge">PATH</code> 变量设置的目录中查找。</p>

<p>新的 shell 会启用新的提示符，因为每个 shell 都有自己的外观。</p>

<h3 id="12-bash-的优势">1.2 Bash 的优势</h3>

<h4 id="gnu-shell">GNU shell</h4>

<p>GNU 计划为类 UNIX 系统管理提供遵守 UNIX 标准的免费软件。</p>

<p>Bash 是兼容 sh 的 shell，而且从 Korn shell (ksh) 和 C shell (csh) 整合了一些有用的特性。它遵循 IEEE POSIX P1003.2/ISO 9945.2 Shell 和工具标准。提供了基于 sh 的编程和交互的功能改进；其中包括命令行编辑，无限制的历史命令，作业控制，shell 函数和别名，无大小限制的索引数组，和以 2 到 64 为基础的整数算法。Bash 可以不经修改地运行多数 sh 脚本。</p>

<p>和其他的 GNU 项目一样，Bash 主动开始保留、保护和促进使用、学习、拷贝、修改和再发布软件的自由。普遍认为这样的情况激发了创造力。这也是 Bash 程序可以而许多其他 shell 无法提供的额外特性的缘由。</p>

<h4 id="bash-独有的特性">Bash 独有的特性</h4>

<h5 id="bash-启动脚本">Bash 启动脚本</h5>

<p>启动脚本是指当 Bash 启动时会读取并执行的脚本。</p>

<h6 id="以交互登陆-shell-调用或者使用-login">以交互登陆 shell 调用，或者使用 ‘–login’</h6>

<p>读取的文件：</p>

<p><code class="highlighter-rouge">/etc/profile</code></p>

<p><code class="highlighter-rouge">~/.bash_profile</code>,<code class="highlighter-rouge"> ~/.bash_login</code> 或 <code class="highlighter-rouge">~/.profile</code>： 读取第一个存在的可读取的文件</p>

<p><code class="highlighter-rouge">~/.bash_logout</code> 退出的时候</p>

<p>如果配置文件存在但无法读取，将会显示错误消息。一个文件不存在，Bash 会查找下一个。</p>

<h6 id="以交互非登陆-shell-调用">以交互非登陆 shell 调用</h6>

<p>读取的文件：</p>

<p><code class="highlighter-rouge">~/.bashrc</code></p>

<p>此文件通常指向 <code class="highlighter-rouge">~/.bash_profile</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> ~/.bashrc <span class="o">]</span><span class="p">;</span> <span class="k">then</span> <span class="nb">.</span> ~/.bashrc<span class="p">;</span> <span class="k">fi</span>
</code></pre></div></div>

<h6 id="非交互调用">非交互调用</h6>

<p>所有脚本使用非交互 shell。这些脚本通常仅仅是为了完成特定任务。</p>

<p>读取的文件：</p>

<p>由变量 <code class="highlighter-rouge">BASH_ENV</code> 定义</p>

<p><code class="highlighter-rouge">PATH</code> 无法查找脚本文件，所以运行脚本时，最好文件名。</p>

<h6 id="以-sh-命令调用">以 sh 命令调用</h6>

<p>Bash 尝试 sh 的相似行为，同时也遵循 POSIX 标准。</p>

<p>读取的文件：</p>

<p><code class="highlighter-rouge">/etc/profile</code></p>

<p><code class="highlighter-rouge">~/.profile</code></p>

<p>当以交互方式调用时，环境变量 <code class="highlighter-rouge">ENV</code> 能指向额外的启动信息。</p>

<h6 id="posix-模式">POSIX 模式</h6>

<p>本选项在使用内建的命令 <code class="highlighter-rouge">set</code> 时会启用：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="nt">-o</span> posix
</code></pre></div></div>

<p>或用 <code class="highlighter-rouge">--posix</code> 选项来调用 bash 时也会启用 POSIX 模式。</p>

<p>Bash 会尽可能遵循 POSIX 的 shell 标准。 设置 <code class="highlighter-rouge">POSIXLY_CORRECT</code> 变量可以达到目的。</p>

<p>读取的文件：</p>

<p>由变量 <code class="highlighter-rouge">ENV</code> 定义。</p>

<h6 id="远程调用">远程调用</h6>

<p>以 rshd 调用时读取的文件：</p>

<p><code class="highlighter-rouge">~/.bashrc</code></p>

<p class="notice--info">【 不要使用 r 系列工具 】使用 rlogin, telnet, rsh 和 rcp 这类工具存在一定的危险。由于他们在网络上传输数据是 <strong>未经加密</strong> 的，所以他们本质上是不安全的。如果你需要远程执行和文件传输之类的工具，推荐使用 SSH。</p>

<h6 id="uid-不等于-euid-时调用">UID 不等于 EUID 时调用</h6>

<p>这种情况不会读取任何启动脚本。</p>

<h5 id="交互式-shell">交互式 shell</h5>

<p>交互式 shell 通常可从终端读取用户的输入，也可以把输出写到终端：输入和输出都与终端相连。</p>

<p>如果 bash 命令不带任何选项地启动，就会启动 Bash 的交互行为。</p>

<h6 id="判断方法">判断方法</h6>

<p>如何判断当前 shell 是不是交互式的：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$-</span>
himBH
</code></pre></div></div>

<p>只要返回的结果中包含 <code class="highlighter-rouge">i</code> 即代表是交互式的 shell。</p>

<p>另外，非交互式 shell 不需要命令提示符，所以变量 <code class="highlighter-rouge">PS1</code> 未设置。</p>

<h6 id="交互式-shell-的行为特征">交互式 shell 的行为特征</h6>

<ul>
  <li>bash 会读取启动脚本</li>
  <li>默认启用作业控制</li>
  <li>默认设置命令提示符。同时会启用 <code class="highlighter-rouge">PS1</code> 和 <code class="highlighter-rouge">PS2</code> 变量，<code class="highlighter-rouge">PS2</code> 为多行命令的提示符，当用户命令不完整时，回车后也会出现。</li>
  <li>默认使用 <code class="highlighter-rouge">readline</code> 命令从命令行读取命令</li>
  <li>读取命令时，bash 如果收到 EOF，它会先检查 <code class="highlighter-rouge">ignoreeof</code> 选项的值，如果它没有设置才会退出</li>
  <li>默认会启用命令历史和历史扩展，shell 退出时会把命令历史保存到 <code class="highlighter-rouge">HISTFILE</code> 变量所代表的文件中，默认为 <code class="highlighter-rouge">~/.bash_history</code></li>
  <li>默认启用别名扩展</li>
  <li>如果没有设置 trap，<code class="highlighter-rouge">SIGTERM</code> 信号会被忽略</li>
  <li>如果没有设置 trap，<code class="highlighter-rouge">SIGINT</code>  信号会被捕捉并处理。<code class="highlighter-rouge">^C</code> 会中断某些内建的命令，但不会导致交互 shell 的退出</li>
  <li>如果启用了 <code class="highlighter-rouge">huponexit</code> 选项，则退出 shell 时会向所有作业发送 <code class="highlighter-rouge">SIGHUP</code> 信号</li>
  <li>bash 读取到命令会立即执行</li>
  <li>bash 会定期检查邮件</li>
  <li>bash 可以配置成遇到未引用的变量就退出，该行为在交互模式下是禁用的</li>
  <li>shell 内建命令遇到重定向错误时，不会导致 shell 的退出</li>
  <li>特殊的内建命令在 POSIX 模式返回错误时，不会导致 shell 的退出</li>
  <li>如果 <code class="highlighter-rouge">exec</code> 执行失败，不会导致 shell 的退出</li>
  <li>解析到语法错误，不会导致 shell 的退出</li>
  <li>默认对内建命令 <code class="highlighter-rouge">cd</code> 的参数开启简单的拼写检查</li>
  <li>默认情况下，超过 <code class="highlighter-rouge">TMOUT</code> 变量指定的时间，bash 会自动退出，即超时</li>
</ul>

<h5 id="条件表达式">条件表达式</h5>

<p>可以在 <code class="highlighter-rouge">[[ ]]</code>，<code class="highlighter-rouge">test</code>，<code class="highlighter-rouge">[ ]</code> 中使用条件表达式。</p>

<p>表达式可以是 <strong>一元</strong> 或 <strong>二元</strong> 的。</p>

<p><strong>一元条件表达式</strong> 经常用来检验文件的状态：</p>

<p>只需要一个对象，如一个文件，就能执行操作。</p>

<p><strong>二元条件表达式</strong> 需要两个对象来执行操作：</p>

<h5 id="shell-运算">shell 运算</h5>

<p>shell 可以对算术表达式求值，使用 shell 扩展或内建命令 <code class="highlighter-rouge">let</code> 来完成。</p>

<p>赋值时需用等宽整数，不会进行溢出检查，除以 0 会被捕获，并标记为错误。</p>

<h5 id="别名">别名</h5>

<p>可以用一个简单的字符串来代替另一堆相对复杂的字符串，通过一张别名列表来管理，相关命令为 <code class="highlighter-rouge">alias</code> 和 <code class="highlighter-rouge">unalias</code>。</p>

<p>bash 需要把 <strong>一行命令读取完毕</strong>，才会开始执行其中的命令。而别名的扩展是发生在 <strong>读取命令时</strong>，而非执行命令时。因此，要想让别名生效，至少要从下一行起。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">alias </span><span class="nv">l</span><span class="o">=</span><span class="s1">'ls -l'</span><span class="p">;</span> l
bash: l: <span class="nb">command </span>not found...
<span class="c"># 别名未生效</span>

<span class="nb">alias </span><span class="nv">l</span><span class="o">=</span><span class="s1">'ls -l'</span>
l
total 2
drwxrwxr-x. 5 neo neo  36 May 17 16:41 aa
drwxrwxr-x. 5 neo neo  36 May 17 16:41 bb
<span class="c"># 读取完一整行之后，别名生效</span>
</code></pre></div></div>

<p>对于函数来说，因为函数相当于 <strong>一个</strong> 复合的命令，因此同样地，需要等到整个函数的定义全部读取完毕，别名才被扩展。</p>

<h5 id="数组">数组</h5>

<p>bash 支持一维数组变量。</p>

<p>任何变量都可以用在数组中。</p>

<p>用 <code class="highlighter-rouge">delcare</code> 内建命令来显示声明数组。</p>

<p>数组没有大小的限制，成员无需索引，无需连续赋值。</p>

<h5 id="目录栈">目录栈</h5>

<p>目录栈用于保存最近访问的目录的列表。</p>

<p><code class="highlighter-rouge">pushd dir1</code>  内建命令用于把指定目录加入列表</p>

<p><code class="highlighter-rouge">popd dir2</code>  内建命令用于把指定目录移出列表</p>

<p><code class="highlighter-rouge">dirs</code>  命令可查看列表内容</p>

<h5 id="命令提示符">命令提示符</h5>

<p>交互式 bash 使用提示符，可以自定义。</p>

<h5 id="bash-受限模式">bash 受限模式</h5>

<p>如果调用 <code class="highlighter-rouge">rbash</code>，或调用 bash 时使用 <code class="highlighter-rouge">--restricted</code> 选项，会发生以下事情：</p>

<ul>
  <li>内建命令 <code class="highlighter-rouge">cd</code> 被禁用</li>
  <li>无法修改 <code class="highlighter-rouge">SHELL</code>，<code class="highlighter-rouge">PATH</code>，<code class="highlighter-rouge">ENV</code>，<code class="highlighter-rouge">BASH_ENV</code> 这些变量的值</li>
  <li>命令中禁止包含斜线</li>
  <li><code class="highlighter-rouge">source</code> 命令（<code class="highlighter-rouge">.</code>）后面的文件名禁止包含斜线</li>
  <li><code class="highlighter-rouge">hash -p</code>  内建命令不接受斜线</li>
  <li>禁止在启动时导入函数</li>
  <li>启动时会忽略 <code class="highlighter-rouge">SHELLOPTS</code> 变量</li>
  <li>禁止使用 <code class="highlighter-rouge">&gt;</code>，<code class="highlighter-rouge">&gt;|</code>，<code class="highlighter-rouge">&gt;&lt;</code>，<code class="highlighter-rouge">&gt;&amp;</code>，<code class="highlighter-rouge">&amp;&gt;</code>，<code class="highlighter-rouge">&gt;&gt;</code> 进行输出重定向</li>
  <li>禁用内建命令 <code class="highlighter-rouge">exec</code></li>
  <li>内建命令 <code class="highlighter-rouge">enalbe</code> 的 <code class="highlighter-rouge">-f</code> 和 <code class="highlighter-rouge">-d</code> 选项被禁用</li>
  <li>受限模式无法关闭</li>
</ul>

<h3 id="13-命令的执行">1.3 命令的执行</h3>

<p>Bash 会判断要执行的程序的类型。</p>

<p>普通程序为编译好的系统命令，运行时会产生新的进程，因为 bash 生成了一个自己的副本。该子进程拥有相同的环境，只不过 PID 不同。该过程称为 forking。</p>

<p>forking 之后，子进程的地址空间被新的数据覆盖，是通过 <code class="highlighter-rouge">exec</code> 系统调用实现的。</p>

<p><code class="highlighter-rouge">fork-and-exec</code> 机制把旧命令转化成新命令，而新程序的环境仍然与原来的相同，包括输入输出设备的配置、环境变量和优先级。这种机制用来创建所有的进程。</p>

<h4 id="shell-内建命令">shell 内建命令</h4>

<p>内建命令包含于 shell 自身。如果内建程序的名称在一个简单命令中处于最前面，shell 会直接执行该命令，无需生成新的进程。</p>

<p>bash 支持三种内建命令：</p>

<h5 id="sh-内建命令">sh 内建命令</h5>

<p><code class="highlighter-rouge">:</code></p>

<p><code class="highlighter-rouge">.</code></p>

<p><code class="highlighter-rouge">break</code></p>

<p><code class="highlighter-rouge">cd</code></p>

<p><code class="highlighter-rouge">continue</code></p>

<p><code class="highlighter-rouge">eval</code></p>

<p><code class="highlighter-rouge">exec</code></p>

<p><code class="highlighter-rouge">exit</code></p>

<p><code class="highlighter-rouge">export</code></p>

<p><code class="highlighter-rouge">getopts</code></p>

<p><code class="highlighter-rouge">hash</code></p>

<p><code class="highlighter-rouge">pwd</code></p>

<p><code class="highlighter-rouge">readonly</code></p>

<p><code class="highlighter-rouge">return</code></p>

<p><code class="highlighter-rouge">set</code></p>

<p><code class="highlighter-rouge">shift</code></p>

<p><code class="highlighter-rouge">test</code></p>

<p><code class="highlighter-rouge">[</code></p>

<p><code class="highlighter-rouge">times</code></p>

<p><code class="highlighter-rouge">trap</code></p>

<p><code class="highlighter-rouge">umask</code></p>

<p><code class="highlighter-rouge">unset</code></p>

<h5 id="bash-内建命令">bash 内建命令</h5>

<p><code class="highlighter-rouge">alias</code></p>

<p><code class="highlighter-rouge">bind</code></p>

<p><code class="highlighter-rouge">builtin</code></p>

<p><code class="highlighter-rouge">command</code></p>

<p><code class="highlighter-rouge">declare</code></p>

<p><code class="highlighter-rouge">echo</code></p>

<p><code class="highlighter-rouge">enable</code></p>

<p><code class="highlighter-rouge">help</code></p>

<p><code class="highlighter-rouge">let</code></p>

<p><code class="highlighter-rouge">local</code></p>

<p><code class="highlighter-rouge">logout</code></p>

<p><code class="highlighter-rouge">printf</code></p>

<p><code class="highlighter-rouge">read</code></p>

<p><code class="highlighter-rouge">shopt</code></p>

<p><code class="highlighter-rouge">type</code></p>

<p><code class="highlighter-rouge">typeset</code></p>

<p><code class="highlighter-rouge">ulimit</code></p>

<p><code class="highlighter-rouge">unalias</code></p>

<h5 id="特殊内建命令">特殊内建命令</h5>

<p>bash 以 POSIX 模式运行时，特殊内建命令主要表现为以下三方面的不同：</p>

<ul>
  <li>命令查找期间，特殊内建命令会先于 shell 函数被找到</li>
  <li>如果特殊内建命令返回一个错误状态码，非交互式 shell 会退出</li>
  <li>命令完成后，在命令之前执行的赋值语句在 shell 环境中仍然有效</li>
</ul>

<p>特殊内建命令：</p>

<p><code class="highlighter-rouge">:</code></p>

<p><code class="highlighter-rouge">.</code></p>

<p><code class="highlighter-rouge">break</code></p>

<p><code class="highlighter-rouge">continue</code></p>

<p><code class="highlighter-rouge">eval</code></p>

<p><code class="highlighter-rouge">exec</code></p>

<p><code class="highlighter-rouge">exit</code></p>

<p><code class="highlighter-rouge">export</code></p>

<p><code class="highlighter-rouge">readonly</code></p>

<p><code class="highlighter-rouge">return</code></p>

<p><code class="highlighter-rouge">set</code></p>

<p><code class="highlighter-rouge">shift</code></p>

<p><code class="highlighter-rouge">trap</code></p>

<p><code class="highlighter-rouge">unset</code></p>

<h4 id="从脚本中执行程序">从脚本中执行程序</h4>

<p>如果被执行的程序是一个脚本，bash 会用 fork 创建一个新的 bash 进程，该子 shell 会逐行读取脚本，加以解释、执行，和直接从键盘上输入命令的效果是一样的。</p>

<p>在子 shell 逐行处理脚本时，父进程会等着它，处理完脚本所有行，子 shell 就终止了，父 shell 苏醒，并显示提示符。</p>

<h3 id="14-shell-的标准组件">1.4 Shell 的标准组件</h3>

<p>Bash 是 GNU shell，兼容 sh，并从其他 shell 中吸取了许多有用的功能。</p>

<p>shell 启动时会读取其配置文件。最重要的几个：</p>

<p><code class="highlighter-rouge">/etc/profile</code></p>

<p><code class="highlighter-rouge">~/.bash_profile</code></p>

<p><code class="highlighter-rouge">~/.bashrc</code></p>

<p>Bash 在交互模式下的行为有所不同, 具有 POSIX 兼容模式和受限模式。</p>

<p>shell 命令分为：shell 的函数、shell 内建命令以及系统中某目录中的命令。</p>

<p>Shell 脚本由这些命令组成，并按 shell 的句法规定排列。</p>

<p>脚本是按行读取和执行的，应该有一个逻辑结构。</p>

<h4 id="shell-句法">Shell 句法</h4>

<p>如果输入没有被注释掉，shell 会把读取的输入 <strong>分割</strong> 成文字和操作符，用 <strong>引用规则</strong> 来定义每个字符的含义。这些文字和操作符于是被 <strong>转化为命令</strong> 和其它成分，命令会返回一个退出状态。</p>

<p>只有在 shell 解析完输入之后，该 <code class="highlighter-rouge">fork-and-exec</code> 机制才会起作用。解析过程如下：</p>

<ul>
  <li>
    <p>shell 从文件、字符串或终端 <strong>读取输入</strong>。</p>
  </li>
  <li>
    <p>输入按引用规则被 <strong>拆分成</strong> 文字和操作符，这些 <strong>记号</strong>（token）用元字符（metacharacter）来分隔，同时进行了别名扩展。</p>
  </li>
  <li>
    <p>shell 把这些记号 <strong>解析成</strong> 简单或复合的 <strong>命令</strong>。</p>
  </li>
  <li>
    <p>Bash 进行多种 shell <strong>扩展</strong>，把扩展后的记号转换成文件名列表、命令和参数。</p>
  </li>
  <li>
    <p>需要时进行 <strong>重定向</strong>，把重定向操作符和被重定向的对象从参数列表中移除。</p>
  </li>
  <li>
    <p>执行命令。</p>
  </li>
  <li>
    <p>需要时，shell 会等待命令的完成，并收集其退出状态。</p>
  </li>
</ul>

<h4 id="shell-命令">shell 命令</h4>

<p>简单的 shell 命令由 <strong>命令</strong> 和 <strong>参数</strong> 组成，由 <strong>空格</strong> 分隔。</p>

<p>再复杂的命令也是由多个简单的命令以某种方式组合在一起的，如管道、循环、条件结构等。</p>

<h4 id="shell-函数">shell 函数</h4>

<p>使用 shell 函数，可以把多个命令组合在一起，便于稍后用一个名字来执行。函数执行起来就像一个普通的命令，如果把函数名作为命令来运行，与该函数名关联的命令列表就会被执行。</p>

<p>shell 函数是在当前 shell 执行的，<strong>不会产生新进程</strong>。</p>

<h4 id="shell-参数">shell 参数</h4>

<p>参数是可以保存值的实体。它可以是名字、数字或特殊值。</p>

<p>对于 shell 来说，变量是个参数，用于保存名字。一个变量可以有值，以及零或多个属性。变量可通过内建命令 <code class="highlighter-rouge">declare</code> 创建。</p>

<p>如果没有给变量赋值，会给变量分配一个 <strong>空字符串</strong>。</p>

<p>变量只能通过内建命令 <code class="highlighter-rouge">unset</code> 来删除。</p>

<h4 id="shell-扩展">shell 扩展</h4>

<p>每个命令行被分割成记号以后，会进行 shell 扩展：</p>

<ul>
  <li>括号扩展</li>
  <li><code class="highlighter-rouge">~</code> 扩展</li>
  <li>参数和变量扩展</li>
  <li>命令替换</li>
  <li>算术扩展</li>
  <li>单词分割</li>
  <li>文件名扩展</li>
</ul>

<h4 id="重定向">重定向</h4>

<p>在执行命令之前，借助一个特殊符号，其输入和输出可以被重定向。</p>

<p>重定向也可用于在当前执行环境中打开或关闭文件。</p>

<h4 id="命令的执行">命令的执行</h4>

<p>执行命令时，解析器标记为 <strong>变量赋值</strong>（命令名前面）的单词和 <strong>重定向</strong> 将被 <strong>保存</strong> 以供后面引用，不属于变量赋值或重定向功能的词将被 <strong>扩展</strong>；扩展后的第一个剩余单词被视为 <strong>命令</strong> 的名称，其余的是该命令的 <strong>参数</strong>。然后执行 <strong>重定向</strong> 功能, 将分配给变量的字符串扩展开。如果没有找到命令名，变量会在当前 shell 环境继续生效。</p>

<p>shell 众多任务中最重要的，就是查找命令。以下为查找的流程：</p>

<ul>
  <li>检查命令中是否包含斜线。如果没有，先从函数列表里面找。</li>
  <li>如果命令不是函数，再从内建命令中找。</li>
  <li>如果都不是，从 <code class="highlighter-rouge">PATH</code> 变量值中定义的各个路径中找。bash 使用哈希表（内存中的数据存储区块）来保存可执行文件的完整路径，可以避免粗放的 <code class="highlighter-rouge">PATH</code> 查找。</li>
  <li>如是还没找到，bash 打印错误消息，返回退出状态码 127。</li>
  <li>如果找到了，或如果命令包含斜线，shell 会在单独的执行环境中执行该命令。</li>
  <li>如果由于文件非可执行而执行失败，且文件不是目录，则假定其是 shell 脚本。</li>
  <li>如果命令没有异步地启动，shell 会等待命令执行完毕，然后收集其退出状态。</li>
</ul>

<h4 id="shell-脚本">shell 脚本</h4>

<p>调用 bash 时，如果脚本被用作第一个非选项参数（不带 <code class="highlighter-rouge">-c</code> 或者 <code class="highlighter-rouge">-s</code>，这两个参数会创建非交互 shell），该 shell 首先会查找脚本文件当前目录，如果没找到，则对环境变量 <code class="highlighter-rouge">PATH</code> 进行查找。</p>

<h3 id="15-开发好脚本">1.5 开发好脚本</h3>

<h4 id="好脚本的特质">好脚本的特质</h4>

<ul>
  <li>运行无错误</li>
  <li>能完成预期的任务</li>
  <li>程序的逻辑清晰、明确</li>
  <li>不做不必要的工作</li>
  <li>可被重用</li>
</ul>

<h4 id="脚本的结构">脚本的结构</h4>

<p>脚本的结构非常灵活。即使在 bash 中有很大的自由度可以发挥，仍然要确保正确的逻辑、流控制和高效，以便用户可以轻松正确地执行脚本。</p>

<p>开始着手编写脚本时，问自己几个问题：</p>

<ul>
  <li>我需要从用户或用户环境中获取任何信息吗？</li>
  <li>怎么保存这些信息？</li>
  <li>要创建文件吗？保存在哪？权限？所有人？</li>
  <li>要用什么命令？如果脚本在其它系统运行，上面有这些命令的所需版本吗？</li>
  <li>用户要接收通知消息吗？什么时候发送？为什么发送？</li>
</ul>

<h4 id="术语">术语</h4>

<p>常用编程术语：</p>

<table>
  <thead>
    <tr>
      <th>术语</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>命令控制</td>
      <td>测试命令的退出状态，以判断这部分代码是否应该执行</td>
    </tr>
    <tr>
      <td>条件分支</td>
      <td>代码中的逻辑点，由条件决定下一步该发生什么</td>
    </tr>
    <tr>
      <td>逻辑流程</td>
      <td>程序的总体设计。确定任务的逻辑顺序，以确保得到成功且可控的结果</td>
    </tr>
    <tr>
      <td>循环</td>
      <td>这部分代码会被执行 0 或多次</td>
    </tr>
    <tr>
      <td>用户输入</td>
      <td>程序运行时，由外部源提供的信息，需要时可保存或回调</td>
    </tr>
  </tbody>
</table>

<h4 id="关于顺序与逻辑">关于顺序与逻辑</h4>

<p>为了加速开发的进程，程序的 <strong>逻辑顺序</strong> 应提前考虑充分。这是开发脚本的第一步。</p>

<p>有多种方法可供使用，最常用的就是使用列表。逐项列出程序中涉及的 <strong>任务列表</strong> 可帮助描述每段流程，可以用项目编号来引用单个的任务。</p>

<p>用口语化的语言来 <strong>标记</strong> 程序中的各项任务，有助于建立便于理解的 <strong>程序框架</strong>。之后，就可以用 shell 的语言和结构来替换。</p>

<p>下面的例子示范了这种逻辑流程的设计。描述了日志文件的轮替。</p>

<p>设计一个重复的循环，用轮替的日志文件数量来控制：</p>

<ol>
  <li>你想轮替日志吗？
 a. 如果是：
     i. 输入要轮替日志所在的目录
     ii. 输入日志文件基准文件名
     iii. 输入日志需要保存的天数
     iv. 修改用户的 <code class="highlighter-rouge">crontab</code> 文件
 b. 如果不是，跳到第 3 步</li>
  <li>你要轮替另一组日志吗？
 a. 如果是：重复第 1 步
 b. 如果不是：跳到第 3 步</li>
  <li>退出</li>
</ol>

<p>用户要提供信息，才能让程序做点什么。必须要获取用户的输入并且保存下来。有必要提醒用户他的 <code class="highlighter-rouge">crontab</code> 文件将会被修改。</p>

<h2 id="2-脚本的编写与调试">2. 脚本的编写与调试</h2>

<h3 id="21-创建脚本并运行">2.1 创建脚本并运行</h3>

<h4 id="编写与命名">编写与命名</h4>

<p>shell 脚本是一个重复使用的命令序列，通常在命令行中输入脚本的名称来执行。或者，也可以借助 cron 让脚本实现自动化的任务。脚本的另一个用途是在系统启动和关机过程中，在初始化脚本中可以定义守护进程和服务的操作。</p>

<p>要创建 shell 脚本，请在编辑器中打开一个新的空文件，放里面放几个命令，然后再起个一看就明白的名字，但不要与现有命令名冲突。为了方便，脚本文件通常加后缀 <code class="highlighter-rouge">.sh</code>。即使这样，也有可能同一系统中不同位置存在同名的脚本，可用以下命令帮助确认：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which <span class="nt">-a</span> script_name
whereis script_name
locate script_name
</code></pre></div></div>

<h4 id="执行脚本">执行脚本</h4>

<p>脚本的所有人要想运行，必须给脚本赋予可执行权限。</p>

<p>一般情况下，用 <code class="highlighter-rouge">./script_name</code> 的方式来运行脚本。如果当前路径被加入了 <code class="highlighter-rouge">PATH</code> 变量，则可以直接用脚本名 <code class="highlighter-rouge">script_name</code> 来运行。</p>

<p>可以把脚本做为参数来运行 <code class="highlighter-rouge">bash</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash <span class="nt">-x</span> script_name.sh
</code></pre></div></div>

<p>但通常我们只在需要获取特殊行为时才会执行此操作，例如检查脚本是否可以与另一个 shell 一起工作，或打印用于调试的追踪。指定的 shell 将启动一个当前 shell 的子 shell 来执行脚本。若想让脚本以特定选项启动，或想在特定条件下来启动时，可以用这种方法。</p>

<p>如果不希望启动一个子 shell 执行脚本，可以用 <code class="highlighter-rouge">source</code> 来运行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source </span>script_name.sh
</code></pre></div></div>

<p><code class="highlighter-rouge">source</code> 是内建命令，与 <code class="highlighter-rouge">.</code> 的作用相同。<code class="highlighter-rouge">.</code> 最早是 sh 命令。此时脚本不需要可执行权限，命令是在当前 shell 执行的，因此，由此对环境变量造成的任何改变，随后都可以看到。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source </span>script1.sh
<span class="nt">--output</span> ommited--

<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$VALUE</span>
9
</code></pre></div></div>

<h3 id="22-脚本基础">2.2 脚本基础</h3>

<h4 id="221-用哪个-shell-来运行脚本">2.2.1 用哪个 shell 来运行脚本</h4>

<p>在子 shell 运行脚本时，需要指明用哪个 shell 来运行。你用来编写脚本的 shell 类型有可能不是当前系统的默认 shell，因此如果用错误的 shell 执行时，你输入的命令可能会造成错误。</p>

<p>脚本的第一行确定要启动的 shell。第一行的前两个字符应该是 <code class="highlighter-rouge">#!</code>，然后就是用来解释后面命令的 shell 的路径。空白行也被视为行，所以不要用空行启动脚本。</p>

<p><code class="highlighter-rouge"><span class="c">#!/bin/bash</span></code>  将会使用在 <code class="highlighter-rouge">/bin</code> 目录中找到的 bash 可执行文件来执行脚本。</p>

<h4 id="222-添加注释">2.2.2 添加注释</h4>

<p>应该清楚一点，你不会是唯一一个会阅读你写的代码的人，许多用户和系统管理员都会运行别人写的代码。清楚明白的注释会帮助别人了解你是如何编写脚本的。</p>

<p>注释也会让自己更轻松一些。比如说，为了实现一个特定的结果，你要在脚本中使用某些命令，因此不得不阅读大量的帮助文档。过了几周或几个月，你可能就不记得这些命令是如何工作的了，除非加了充足的注释。</p>

<p>在一个正式的脚本中，第一行通常注释的内容是该脚本的简介，会发生什么。之后，根据需要，为每一大块命令添加必要的注释。</p>

<h3 id="23-调试-bash-脚本">2.3 调试 bash 脚本</h3>

<h4 id="231-调试整个脚本">2.3.1 调试整个脚本</h4>

<p>如果脚本没有按预期的工作，就要判断是什么导致了脚本的失败。</p>

<p>bash 提供了调试功能，最常用的是用 <code class="highlighter-rouge">-x</code> 选项来启动子 shell，会以调试模式来运行整个脚本。在每条命令被扩展后、被执行之前，对该命令和参数的追踪都会打印到标准输出。</p>

<h4 id="232-调试部分脚本">2.3.2 调试部分脚本</h4>

<p>要想对脚本的局部代码进行调试，可以使用内建命令 <code class="highlighter-rouge">set</code>，以普通模式运行，来查看局部代码的调试信息。</p>

<table>
  <thead>
    <tr>
      <th>简写</th>
      <th>长形</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>set -f</td>
      <td>set -o noglob</td>
      <td>禁止使用元字符（通配）来扩展文件名</td>
    </tr>
    <tr>
      <td>set -v</td>
      <td>set -o verbose</td>
      <td>在 shell 读取输入时，同时显示出来</td>
    </tr>
    <tr>
      <td>set -x</td>
      <td>set -o xtrace</td>
      <td>执行命令之前，显示命令的追踪</td>
    </tr>
  </tbody>
</table>

<p class="notice--primary">用减号 <code class="highlighter-rouge">-</code> 来激活调试，用加号 <code class="highlighter-rouge">+</code> 停止调试。</p>

<h5 id="用-set-包围局部代码">用 <code class="highlighter-rouge">set</code> 包围局部代码</h5>

<p>例如，我们不确定某个脚本文件中 <code class="highlighter-rouge">w</code> 命令是如何运行的，则可以在代码中把 <code class="highlighter-rouge">w</code> 命令用 <code class="highlighter-rouge">set</code> 包围起来：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="nt">-x</span>		<span class="c"># 从此处激活调试</span>
w
<span class="nb">set</span> +x		<span class="c"># 从此处停止调试</span>
</code></pre></div></div>

<p>输出将是这样的：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>script1.sh
The script starts now.
Hi, willy!

I will now fetch you a list of connected <span class="nb">users</span>:

+ w
  5:00pm  up 18 days,  7:00,  4 <span class="nb">users</span>,  load average: 0.79, 0.39, 0.33
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     tty2     -                Sat 2pm  5:47m  0.24s  0.05s  <span class="nt">-bash</span>
willy    :0       -                Sat 2pm   ?     0.00s   ?     -
+ <span class="nb">set</span> +x
</code></pre></div></div>

<p>你可以在脚本中随意地启用、停止调用。</p>

<h5 id="在命令行中运行-set">在命令行中运行 <code class="highlighter-rouge">set</code></h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">set</span> <span class="nt">-v</span>
<span class="nv">$ </span><span class="nb">ls
ls
</span>aaaaaaaaa.sh   bbb.sh

<span class="nv">$ </span><span class="nb">set</span> +v
<span class="nb">set</span> +v

<span class="nv">$ </span><span class="nb">ls</span> <span class="k">*</span>
aaaaaaaaa.sh   bbb.sh

<span class="nv">$ </span><span class="nb">set</span> <span class="nt">-f</span>

<span class="nv">$ </span><span class="nb">ls</span> <span class="k">*</span>
<span class="nb">ls</span>: <span class="k">*</span>: No such file or directory

<span class="nv">$ </span><span class="nb">touch</span> <span class="k">*</span>

<span class="nv">$ </span><span class="nb">ls</span>
<span class="k">*</span>   commented-scripts.sh    script1.sh

<span class="nv">$ </span><span class="nb">rm</span> <span class="k">*</span>

<span class="nv">$ </span><span class="nb">ls
</span>commented-scripts.sh    script1.sh
</code></pre></div></div>

<h5 id="在脚本开头添加选项">在脚本开头添加选项</h5>

<p>可以把要使用的选项直接添加在 <code class="highlighter-rouge">#!</code> 行后面：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash -xv</span>
</code></pre></div></div>

<h5 id="找到问题代码之后">找到问题代码之后</h5>

<p>一旦找到了脚本中出问题的部分代码，可以在每条不太确定的命令之前用 <code class="highlighter-rouge">echo</code> 加上调试声明，这样会看的更清楚，哪儿不正常，为什么了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"debug message: now attempting to start w command"</span><span class="p">;</span> w
</code></pre></div></div>

<p>在更高级的脚本中，可以插入 <code class="highlighter-rouge">echo</code> 来显示不同阶段同一变量的内容，以便检测出错误：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Variable VARNAME is now set to </span><span class="nv">$VARNAME</span><span class="s2">."</span>
</code></pre></div></div>

<h2 id="3-bash-环境">3. bash 环境</h2>

<h3 id="31-shell-初始化文件">3.1 shell 初始化文件</h3>

<h4 id="311-系统范围的配置文件">3.1.1 系统范围的配置文件</h4>

<h5 id="etcprofile"><code class="highlighter-rouge">/etc/profile</code></h5>

<p>如果 bash 是使用 <code class="highlighter-rouge">--login</code> 选项被调用的，或是做为 <code class="highlighter-rouge">sh</code> 被调用的，它会读取  <code class="highlighter-rouge">/etc/profile</code> 脚本，其中通常会设置变量 <code class="highlighter-rouge">PATH</code>，<code class="highlighter-rouge">USER</code>，<code class="highlighter-rouge">MAIL</code>，<code class="highlighter-rouge">HOSTNAME</code>，<code class="highlighter-rouge">HISTSIZE</code>。</p>

<p>在某些系统中，<code class="highlighter-rouge">umask</code> 的值是在 <code class="highlighter-rouge">/etc/profile</code> 中设定的，其它系统中是在该文件中保有指向其它配置文件的指针，如：</p>

<ul>
  <li><code class="highlighter-rouge">/etc/inputrc</code>，系统范围的 <code class="highlighter-rouge">Readline</code> 初始化文件，用于设定命令行提示音</li>
  <li><code class="highlighter-rouge">/etc/profile.d</code>  目录，其中的文件用于配置特定程序系统的范围的行为</li>
</ul>

<p>如果希望设定的用户环境能 <strong>影响到所有用户</strong>，就应该在 <code class="highlighter-rouge">/etc/profile</code> 中设定。</p>

<p>该文件会设定一些基础的 shell <strong>环境变量</strong>，以及用户在网页浏览器中运行 Java 或 Java 程序时所需要的一些变量。</p>

<h5 id="etcbashrc"><code class="highlighter-rouge">/etc/bashrc</code></h5>

<p>如果系统支持多种 shell，建议使用该文件来进行针对 bash 的配置，因为 <code class="highlighter-rouge">/etc/profile</code> 文件也会被其他 shell 所读取，比如 Bourne shell。如果其他 shell 不理解 bash 的语法就会产生错误，所以建议把针对不同类型 shell 的配置文件分割开。这种情况下，用户的 <code class="highlighter-rouge">~/.bashrc</code> 有可能指向 <code class="highlighter-rouge">/etc/bashrc</code>，目的是为了在登陆 shell 初始化期间将 <code class="highlighter-rouge">/etc/bashrc</code> 脚本包含进来。</p>

<p><code class="highlighter-rouge">/etc/profile</code> 仅仅维护 shell 的环境变量和程序的自动启动设置，而 <code class="highlighter-rouge">/etc/bashrc</code> 包含了系统范围的对 <strong>shell 函数</strong> 和 <strong>别名</strong> 的定义。</p>

<p><code class="highlighter-rouge">/etc/bashrc</code>  可能会在 <code class="highlighter-rouge">/etc/profile</code> 或单用户初始文件中 <strong>被引用</strong>。</p>

<h4 id="312-单用户配置文件">3.1.2 单用户配置文件</h4>

<p>这些单用户配置文件有可能默认不存在，需要时可以创建。</p>

<h5 id="bash_profile"><code class="highlighter-rouge">~/.bash_profile</code></h5>

<p>要想单独为特定用户配置 shell 环境，最好就用 <code class="highlighter-rouge">~/.bash_profile</code> 文件 。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.bashrc
<span class="nb">source</span> ~/.bash_login
......
</code></pre></div></div>

<h5 id="bash_login"><code class="highlighter-rouge">~/.bash_login</code></h5>

<p>通常只有在需要登陆系统的时候才会执行该文件。如果 shell 找不到 <code class="highlighter-rouge">~/.bash_profile</code>，就会读取该文件。</p>

<h5 id="profile"><code class="highlighter-rouge">~/.profile</code></h5>

<p>如果找不到 <code class="highlighter-rouge">~/.bash_profile</code> 和 <code class="highlighter-rouge">~/.bash_login</code>，就会读取 <code class="highlighter-rouge">~/.profile</code>。该文件可以保存相同的配置，也可以被其它 shell 访问。</p>

<h5 id="bashrc"><code class="highlighter-rouge">~/.bashrc</code></h5>

<p>现在经常会用到非登陆 shell，比如在图形界面里，用 X 终端登陆时。打开这个窗口时，用户无需输入用户名和密码，也不会进行认证。</p>

<h5 id="bash_logout"><code class="highlighter-rouge">~/.bash_logout</code></h5>

<p>退出时会执行该文件。</p>

<h4 id="313-修改-shell-配置文件">3.1.3 修改 shell 配置文件</h4>

<p>如果以上文件发生了修改，用户要么需要重新连接到系统，要么通过 <code class="highlighter-rouge">source script_name</code> 来使其生效。对文件的修改会应用到当前 shell 会话。</p>

<p>许多 shell 脚本会在私有环境下执行：变量只有从父进程导出，才会被子进程所继承。因此，<code class="highlighter-rouge">source</code> 一个脚本不仅会应用其对环境的修改，也会应用其对变量的设置。</p>

<p>如果需要的话，为了便于了解哪些设置来自于哪个文件，可以在配置文件中用 <code class="highlighter-rouge">echo</code> 添加一些声明文字，如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Now executing .bash_profile.."</span>
</code></pre></div></div>

<p>或：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Now setting PS1 in .bashrc:"</span>
<span class="nb">export </span><span class="nv">PS1</span><span class="o">=</span><span class="s2">"[some value]"</span>
<span class="nb">echo</span> <span class="s2">"PS1 is now set to </span><span class="nv">$PS1</span><span class="s2">"</span>
</code></pre></div></div>

<p>这样，当某个配置文件被应用时，你随时都会了解到它做了些什么。</p>

<h3 id="32-变量">3.2 变量</h3>

<h4 id="321-变量的种类">3.2.1 变量的种类</h4>

<p>按照习惯，shell 变量通常使用大写字母来表示。bash 会保留变量的列表，其中有两类变量：</p>

<h5 id="全局变量">全局变量</h5>

<p>全局变量或环境变量在所有 shell 中可见。可以用 <code class="highlighter-rouge">env</code> 或 <code class="highlighter-rouge">printenv</code> 命令来查看环境变量。</p>

<h5 id="局部变量">局部变量</h5>

<p>局部变量只在当前 shell 可见。使用内建命令 <code class="highlighter-rouge">set</code> 不带选项运行，可以查看所有变量和函数的列表。输出会根据当前语系进行排序，以可重用的格式来显示。</p>

<h5 id="按变量内容区分">按变量内容区分</h5>

<p>如果按变量内容来区分变量：</p>

<ul>
  <li>字符变量</li>
  <li>整数变量</li>
  <li>常量</li>
  <li>数组变量</li>
</ul>

<h4 id="322-创建变量">3.2.2 创建变量</h4>

<p>变量是区分大小写的，默认都用大写。有时候习惯性用小写字母来命名局部变量。然而，你可以随意使用大小写来命名变量。变量名可以包含数字，但不能在首位。如 <code class="highlighter-rouge">number1</code> 是合法的名字，但 <code class="highlighter-rouge">1number</code> 就不是。</p>

<p>要在 shell 中设置一个变量，使用如下格式：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">VARNAME</span><span class="o">=</span><span class="s2">"value"</span>
</code></pre></div></div>

<p>等号两边与变量和值之间都不能有空格，否则会出错。为变量赋值时，建议养成 <strong>引用</strong> 内容字符串的好习惯。这会减小出错的机率。</p>

<p>用 <code class="highlighter-rouge">unset</code> 删除变量之后，该变量就不再可用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">unset </span>MYVAR1
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$MYVAR1</span>

</code></pre></div></div>

<h4 id="323-导出变量">3.2.3 导出变量</h4>

<p>创建变量之后只是在当前 shell 可见，是局部变量，当前 shell 的子进程看不到。要想把变量传递给子 shell，需要使用 <code class="highlighter-rouge">export</code> 命令来将其导出，被导出之后，变量就会当作环境变量来看待了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">VARNAME</span><span class="o">=</span><span class="s2">"value"</span>
</code></pre></div></div>

<p>子 shell 可以修改其继承的变量，但所作的修改不会影响父进程。</p>

<h4 id="324-保留变量">3.2.4 保留变量</h4>

<h5 id="bourne-shell-的保留变量">Bourne shell 的保留变量</h5>

<p>bash 有一些变量是与 Bourne shell 相同的，某些情况下，bash 会给这些变量赋予默认值。</p>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CDPATH</td>
      <td>用冒号分隔的目录列表，用于为 <code class="highlighter-rouge">cd</code> 查找路径</td>
    </tr>
    <tr>
      <td>HOME</td>
      <td>当前用户的家目录，<code class="highlighter-rouge">cd</code> 的默认参数，该变量的值也用于 <code class="highlighter-rouge">~</code> 扩展</td>
    </tr>
    <tr>
      <td>IFS</td>
      <td>一个字符列表，这些字符用于分隔字段，在扩展中用于分割单词</td>
    </tr>
    <tr>
      <td>MAIL</td>
      <td>如果该变量用作一个文件名的参数，而且 <code class="highlighter-rouge">MAILPATH</code> 变量没有设置，bash 会检查该文件，如果其中有新的邮件就提醒用户</td>
    </tr>
    <tr>
      <td>MAILPATH</td>
      <td>用冒号分隔的文件列表，shell 会定期检查新邮件</td>
    </tr>
    <tr>
      <td>OPTARG</td>
      <td>由 <code class="highlighter-rouge">getopts</code> 命令处理的、最近的选项参数的值</td>
    </tr>
    <tr>
      <td>OPTIND</td>
      <td>由 <code class="highlighter-rouge">getopts</code> 命令处理的、最近的选项参数的索引号</td>
    </tr>
    <tr>
      <td>PATH</td>
      <td>用冒号分隔的目录列表，shell 用于查找命令</td>
    </tr>
    <tr>
      <td>PS1</td>
      <td>主要的命令提示符，默认值为 <code class="highlighter-rouge">\s-\v\$ </code></td>
    </tr>
    <tr>
      <td>PS2</td>
      <td>次要的命令提示符，默认值为 <code class="highlighter-rouge">&gt;</code>，用于多行</td>
    </tr>
  </tbody>
</table>

<h5 id="bash-的保留变量">Bash 的保留变量</h5>

<p>以下变量为 bash 专有的变量，但对于其它 shell 就是普通的变量名，不会特殊对待它们。</p>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>auto_resume</td>
      <td>控制 shell 如何与用户交互，作业控制</td>
    </tr>
    <tr>
      <td>BASH</td>
      <td>用于执行当前 Bash 实例的全路径</td>
    </tr>
    <tr>
      <td>BASH_ENV</td>
      <td>调用 bash 执行脚本时，如果该变量已设置，执行脚本前，会将变量值扩展，作为启动文件来读取</td>
    </tr>
    <tr>
      <td>BASH_VERSION</td>
      <td>当前 bash 实例的版本号</td>
    </tr>
    <tr>
      <td>BASH_VERSINFO</td>
      <td>只读数组变量，其成员保存该 bash 实例的版本信息</td>
    </tr>
    <tr>
      <td>COLUMNS</td>
      <td>打印列表时，内建命令 <code class="highlighter-rouge">select</code> 使用该变量来判断终端的宽度，接到 <code class="highlighter-rouge">SIGWINCH</code> 信号时会自动设置</td>
    </tr>
    <tr>
      <td>COMP_CWORD</td>
      <td>当前光标下输入的单词位于 <code class="highlighter-rouge">COMP_WORDS</code> 数组中的索引</td>
    </tr>
    <tr>
      <td>COMP_LINE</td>
      <td>当前命令行中输入的完整命令</td>
    </tr>
    <tr>
      <td>COMP_POINT</td>
      <td>相对于当前命令起始处的当前光标位置</td>
    </tr>
    <tr>
      <td>COMP_WORDS</td>
      <td>数组变量，保存当前命令行输入所有的单词</td>
    </tr>
    <tr>
      <td>COMPREPLY</td>
      <td>用于生成补全列表的数组</td>
    </tr>
    <tr>
      <td>DIRSTACK</td>
      <td>数组变量，保存目录栈的内容</td>
    </tr>
    <tr>
      <td>EUID</td>
      <td>当前用户的有效 UID</td>
    </tr>
    <tr>
      <td>FCEDIT</td>
      <td>当内建命令 <code class="highlighter-rouge">fc</code> 使用 <code class="highlighter-rouge">-e</code> 选项时，其使用的默认编辑器</td>
    </tr>
    <tr>
      <td>FIGNORE</td>
      <td>指定多个文件扩展名，用冒号分隔，自动补全时会忽略这些扩展名</td>
    </tr>
    <tr>
      <td>FUNCNAME</td>
      <td>数组变量，包含了整个调用链上所有函数的名字。<code class="highlighter-rouge">${FUNCNAME[0]}</code> 代表 shell 脚本当前正在执行的函数的名字，而变量 <code class="highlighter-rouge">${FUNCNAME[1]}</code> 则代表调用函数 ${FUNCNAME[0]} 的函数的名字，依此类推</td>
    </tr>
    <tr>
      <td>GLOBIGNORE</td>
      <td>设置要忽略的模式匹配文件，多个模式用冒号分隔，文件名扩展时会忽略匹配这些模式的文件</td>
    </tr>
    <tr>
      <td>GROUPS</td>
      <td>数组变量，包含当前用户的所有的组</td>
    </tr>
    <tr>
      <td>histchars</td>
      <td>用于控制历史记录展开、快速替换和标记化的字符，最多有 3 个字符</td>
    </tr>
    <tr>
      <td>HISTCMD</td>
      <td>当前命令执行完后，它在历史命令中的排列编号</td>
    </tr>
    <tr>
      <td>HISTCONTROL</td>
      <td>用于指定是否要把某个命令加入历史列表中</td>
    </tr>
    <tr>
      <td>HISTFILE</td>
      <td>保存历史命令的文件名，默认为 <code class="highlighter-rouge">~/.bash_history</code></td>
    </tr>
    <tr>
      <td>HISTFILESIZE</td>
      <td>历史命令文件可以保存的最大行数，默认为 500 行</td>
    </tr>
    <tr>
      <td>HISTIGNORE</td>
      <td>指定哪些命令保存到历史文件中，哪些忽略</td>
    </tr>
    <tr>
      <td>HISTSIZE</td>
      <td>历史列表中可保存的命令的数量，默认为 500 个</td>
    </tr>
    <tr>
      <td>HOSTFILE</td>
      <td><code class="highlighter-rouge">/etc/hosts</code></td>
    </tr>
    <tr>
      <td>HOSTNAME</td>
      <td>指定主机名要保存在哪个文件中，如 <code class="highlighter-rouge">/etc/hosts</code>。shell 需要时会读取。</td>
    </tr>
    <tr>
      <td>HOSTTYPE</td>
      <td>用于描述运行 bash 的当前主机硬件平台</td>
    </tr>
    <tr>
      <td>IGNOREEOF</td>
      <td>如果整个输入是一个 EOF 字符，shell 应该如何对待</td>
    </tr>
    <tr>
      <td>INPUTRC</td>
      <td>Readlin 初始化文件的名称，用来覆盖默认值 <code class="highlighter-rouge">/etc/inputrc</code></td>
    </tr>
    <tr>
      <td>LANG</td>
      <td>排除那些以 <code class="highlighter-rouge">LC_</code> 开头的变量所设置的语系，该变量用于设置其余类别的语系</td>
    </tr>
    <tr>
      <td>LC_ALL</td>
      <td>设置语系，用于覆盖 <code class="highlighter-rouge">LANG</code> 和 <code class="highlighter-rouge">LC_</code> 开头的所有变量</td>
    </tr>
    <tr>
      <td>LC_COLLATE</td>
      <td>文件名扩展之后，用该变量指定的语系来排序，并确定了字符整理和字符串整理的规则，这些规则控制着范围、同等类以及多字符整理元素的行为。</td>
    </tr>
    <tr>
      <td>LC_CTYPE</td>
      <td>指定用于 LC_CTYPE 类别信息的语言环境。LC_CTYPE 类别确定了字符处理的规则，这些规则控制着文本数据字符（即单字节和多字节字符）的字节序列的解释、字符的分类（如，字母、数字等）以及字符类的行为。</td>
    </tr>
    <tr>
      <td>LC_MESSAGES</td>
      <td>指定用于 LC_MESSAGES 类别信息的语言环境。LC_MESSAGES 类别确定了控制肯定和否定响应的规则，以及控制用于消息和菜单的语言环境（语言）的规则。</td>
    </tr>
    <tr>
      <td>LC_NUMERIC</td>
      <td>指定用于 LC_NUMERIC 类别信息的语言环境。LC_NUMERIC 类别确定了控制非货币数字格式的规则。</td>
    </tr>
    <tr>
      <td>LINENO</td>
      <td>脚本中当前执行的行号</td>
    </tr>
    <tr>
      <td>LINES</td>
      <td><code class="highlighter-rouge">select</code> 命令用该变量来决定打印时的宽度</td>
    </tr>
    <tr>
      <td>MACHTYPE</td>
      <td>记录系统的硬件结构，格式为标准的 GNU 格式：CPU-COMPANY-SYSTEM</td>
    </tr>
    <tr>
      <td>MAILCHECK</td>
      <td><code class="highlighter-rouge">MAILPATH</code> 或 <code class="highlighter-rouge">MAIL</code> 变量所指定的邮件文件，该变量指定多少秒检查一次邮件文件</td>
    </tr>
    <tr>
      <td>OLDPWD</td>
      <td><code class="highlighter-rouge">cd</code> 命令设置的上一个工作目录</td>
    </tr>
    <tr>
      <td>OPTERR</td>
      <td>如果设为 1，bash 会显示 <code class="highlighter-rouge">getopt()</code> 函数产生的错误</td>
    </tr>
    <tr>
      <td>OSTYPE</td>
      <td>当前操作系统类型</td>
    </tr>
    <tr>
      <td>PIPESTATUS</td>
      <td>数组变量，保存最近在前台执行的管道进程的退出状态码的列表</td>
    </tr>
    <tr>
      <td>POSIXLY_CORRECT</td>
      <td>bash 启动时，如果该变量在环境变量中，shell 会进入 POSIX 模式</td>
    </tr>
    <tr>
      <td>PPID</td>
      <td>shell 的父进程的 ID</td>
    </tr>
    <tr>
      <td>PROMPT_COMMAND</td>
      <td>如果设置该变量，变量值会被解释为一个命令，在每次打印主要提示符 <code class="highlighter-rouge">PS1</code> 之前执行</td>
    </tr>
    <tr>
      <td>PS3</td>
      <td>变量值用于作为 <code class="highlighter-rouge">select</code> 命令的提示符，默认为 <code class="highlighter-rouge">#?</code></td>
    </tr>
    <tr>
      <td>PS4</td>
      <td>在 bash 的调试模式中，每行命令都会被回显，该变量的值可以在每条回显的最前面显示</td>
    </tr>
    <tr>
      <td>PWD</td>
      <td><code class="highlighter-rouge">cd</code> 命令设置的当前工作目录</td>
    </tr>
    <tr>
      <td>RANDOM</td>
      <td>该变量每次做为参数被引用时，都会随机产生一个 0 ~ 32767 的整数。为变量赋值可以为随机生成器设定种子</td>
    </tr>
    <tr>
      <td>REPLY</td>
      <td><code class="highlighter-rouge">read</code> 命令的默认值</td>
    </tr>
    <tr>
      <td>SECONDS</td>
      <td>该变量会扩展为 shell 到现在运行的秒数</td>
    </tr>
    <tr>
      <td>SHELLOPTS</td>
      <td>所有已启用的 shell 选项，用冒号分隔</td>
    </tr>
    <tr>
      <td>SHLVL</td>
      <td>启动一个新的 bash 实例，该变量就会加 1</td>
    </tr>
    <tr>
      <td>TIMEFORMAT</td>
      <td>此参数的值用作格式字符串, 用于指定应如何显示带有 <code class="highlighter-rouge">time</code> 的管道的计时信息</td>
    </tr>
    <tr>
      <td>TMOUT</td>
      <td>如果设置的值大于 0，<code class="highlighter-rouge">TMOUT</code> 会做为 <code class="highlighter-rouge">read</code> 命令超时的默认值。在交互式 shell 中，出现提示符以后，变量值代表等待输入的秒数，如果超过这个时间还没有输入，bash 就会终止</td>
    </tr>
    <tr>
      <td>UID</td>
      <td>当前用户的真实 UID</td>
    </tr>
  </tbody>
</table>

<h4 id="325-特殊参数">3.2.5 特殊参数</h4>

<p>有几个参数 shell 会特殊对待，这些参数只可以被引用，不可以赋值。</p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>用途</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">$*</code></td>
      <td>扩展为位置参数，从 1 开始。如果扩展发生在双引号中，该变量会被扩展成一个词，该词由若干个参数组成，参数之间用 IFS 的第一个字符分隔。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$@</code></td>
      <td>扩展为位置参数，从 1 开始。如果扩展发生在双引号中，其中的每一个参数都会被单独扩展成为一个词。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$#</code></td>
      <td>扩展成十进制的位置参数</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$?</code></td>
      <td>扩展成为最近在前台执行的管道的退出状态</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$-</code></td>
      <td>用于保存当前 shell 所使用的所有选项，这些选项都是由 <code class="highlighter-rouge">set</code> 命令设置的</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$$</code></td>
      <td>扩展为 shell 的进程 ID</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$!</code></td>
      <td>扩展为最近后台执行的进程的 ID</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$0</code></td>
      <td>扩展为 shell 的名称或 shell 脚本的名称</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$_</code></td>
      <td>保存前一个命令最后一个参数的变量值</td>
    </tr>
  </tbody>
</table>

<h5 id="-vs-"><code class="highlighter-rouge">$*</code> vs <code class="highlighter-rouge">$@</code></h5>

<p class="notice--success">现实使用中 <code class="highlighter-rouge">$*</code> 经常会带来问题，因此经常使用 <code class="highlighter-rouge">$@</code>。</p>

<h5 id="位置参数">位置参数</h5>

<p>位置参数是指脚本名后面跟的词，它们会放到 <code class="highlighter-rouge">$1</code>、<code class="highlighter-rouge">$2</code>、<code class="highlighter-rouge">$3</code> 等变量中。需要时，可以把变量加入一个内部数组。</p>

<p><code class="highlighter-rouge">$#</code>  保存了参数的总个数。</p>

<h4 id="326-变量让脚本更易于重用">3.2.6 变量让脚本更易于重用</h4>

<p>为了让得到脚本的他人能更快速地修改、使用，建议尽可能地用变量代替常量。</p>

<h3 id="33-对字符的引用">3.3 对字符的引用</h3>

<h4 id="331-为什么要引用字符">3.3.1 为什么要引用字符</h4>

<p>引用是为了清除字符或词的特殊含义。</p>

<p class="notice--info">引用可以 <strong>禁用</strong> shell 对某些特殊字符的 <strong>特殊对待</strong>，可以让 shell <strong>忽略其保留的词</strong>，从而对它们 <strong>禁用参数的扩展</strong>。</p>

<h4 id="332-转义符">3.3.2 转义符</h4>

<p>转义符用于移除 <strong>单个字符</strong> 的特殊含义。没被引用的 <code class="highlighter-rouge">\</code> 在 bash 中是一个转义符。它会保持其后面这个字符的原始值，<strong>换行符除外</strong>。如果 <code class="highlighter-rouge">\</code> 后面紧跟着换行符，代表下一行的内容与本行是连续的，输入流中的这个 <code class="highlighter-rouge">\</code> 会被移除并忽略，从而 <code class="highlighter-rouge">\</code> 在此起了连接两行的作用。</p>

<h4 id="333-单引号">3.3.3 单引号</h4>

<p><code class="highlighter-rouge">' '</code> 单引号用于保持被引用内容中 <strong>所有字符</strong> 的原始值。</p>

<p>单引号不能嵌套使用，哪怕加了转义符也不可以。</p>

<h4 id="334-双引号">3.3.4 双引号</h4>

<p><code class="highlighter-rouge">" "</code> 双引号用于保持被引用内容中 <strong>大部分</strong> 字符的原始值，除了 <code class="highlighter-rouge">$</code>，<code class="highlighter-rouge">` `</code>，<code class="highlighter-rouge">\</code>。</p>

<p><code class="highlighter-rouge">$</code> 和 <code class="highlighter-rouge">` `</code> 在双引号中保持其原义，即变量替换和命令替换。</p>

<p><code class="highlighter-rouge">\</code> 只有在 <code class="highlighter-rouge">$</code>，<code class="highlighter-rouge">` `</code>，<code class="highlighter-rouge">" "</code>，<code class="highlighter-rouge">\</code>，<code class="highlighter-rouge">换行符</code> 前面时才会保持原义。在双引号中，如果 <code class="highlighter-rouge">\</code> 后面跟的是这些符号之一，<code class="highlighter-rouge">\</code> 会从输入流中被删除。</p>

<p>双引号可以嵌套使用，但被引用的双引号需被转义。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "I'd say: \"Go for it!\""
I'd say: "Go for it!"
</code></pre></div></div>

<h4 id="ansi-c-引用">ANSI-C 引用</h4>

<p>bash 还有一种引用的机制：在字符中使用类 ANSI-C 的转义序列，语法为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$'string'
</code></pre></div></div>

<p><code class="highlighter-rouge">string</code> 中如果含有以下转义序列，会被转义：</p>

<table>
  <thead>
    <tr>
      <th>转义码</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">\"</code></td>
      <td>双引号</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\'</code></td>
      <td>单引号</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\\</code></td>
      <td>反斜线</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\a</code></td>
      <td>终端警告字符（提示音）</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\b</code></td>
      <td>回退</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\e</code></td>
      <td>转义</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\f</code></td>
      <td>馈页</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\n</code></td>
      <td>换行</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\r</code></td>
      <td>光标到行首</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\t</code></td>
      <td>水平制表符</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\v</code></td>
      <td>垂直制表符</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\cx</code></td>
      <td>一个 <code class="highlighter-rouge">ctrl-x</code> 字符，如 <code class="highlighter-rouge">$'\cZ'</code> 会输出 <code class="highlighter-rouge">ctrl-z</code>  的控制序列</td>
    </tr>
  </tbody>
</table>

<h4 id="336-语系">3.3.6 语系</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$"string"
</code></pre></div></div>

<p>这种引用称为 I18N。</p>

<p>如果对该字符串存在可用的翻译，会用其译文来代替原有的文字。如果没有，或如果语系设置为 <code class="highlighter-rouge">C</code> 或 <code class="highlighter-rouge">POSIX</code>，该 <code class="highlighter-rouge">$</code> 符号会被忽略，结果就变成普通的双引号引用字符串。</p>

<p>如果字符串被译文所替换，则结果是双引号引用。</p>

<h3 id="34-shell-扩展">3.4 shell 扩展</h3>

<h4 id="简介">简介</h4>

<p>命令被拆分成记号以后，这些记号或词汇会被扩展或解析。共可进行 8 类扩展，在所有扩展完成之后，会进行引用的移除。</p>

<h4 id="342-大括号扩展">3.4.2 大括号扩展</h4>

<p>大括号扩展是一种能够生成任意字符串的机制。</p>

<p>大括号扩展的模式是这样的：</p>

<ul>
  <li>有一个可选的 <strong>前缀</strong></li>
  <li>然后是一组 <strong>字符串</strong> 或表达式，它们包含在大括号中，用 <strong>逗号</strong> 分隔</li>
  <li>最后是一个可选的 <strong>后缀</strong></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>前缀{字,符,串}后缀
前缀{表,达,式}后缀
</code></pre></div></div>

<p>大括号扩展允许嵌套。每个扩展字符串的结果是不会排序的，依然按照从左到右的顺序依次扩展。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo sp{el,il,al}l
spell spill spall
</code></pre></div></div>

<p>大括号扩展是先于其他扩展进行的，其他扩展眼中的特殊字符都会被保留下来，这个过程是严格的文本性质的。对于扩展的内容和括号内的文本，bash 绝对不会应用任何的语法解释。为了避免与参数扩展造成冲突，大括号扩展不会识别字符串中的 <code class="highlighter-rouge">${</code>。</p>

<p>正确的形式：大括号扩展必须包含未引用的成对的大括号，以及至少一个未引用的逗号。</p>

<p>如果大括号扩展的形式错误，扩展之后不会产生任何变化。</p>

<h4 id="343--扩展">3.4.3 <code class="highlighter-rouge">~</code> 扩展</h4>

<p>如果词汇的开头是个未引用的波浪线 <code class="highlighter-rouge">~</code>，所有的字符一直到第一个未引用斜线，或所有的字符（如果没有未引用斜线）被看作波浪线 <strong>前缀</strong>。</p>

<h5 id="neo"><code class="highlighter-rouge">~neo</code></h5>

<p>前缀中如果没有字符被引用，则其中紧随 <code class="highlighter-rouge">~</code> 后面的字符串被看作有可能是登陆名。</p>

<p>如果该登陆名是空字符串，<code class="highlighter-rouge">~</code> 会被替换成 <code class="highlighter-rouge">HOME</code> 变量的值。</p>

<p>如果 <code class="highlighter-rouge">HOME</code> 未设置，则用执行 shell 的用户的家目录替换，否则用指定登陆名的家目录替换。</p>

<p>如果登陆名无效或扩展失败，则命令不会受影响，不会变。</p>

<h5><code class="highlighter-rouge">~+</code></h5>

<p>如果前缀是 <code class="highlighter-rouge">~+</code>，用变量 <code class="highlighter-rouge">PWD</code> 的值替换前缀。</p>

<h5 id="-"><code class="highlighter-rouge">~-</code></h5>

<p>如果前缀是 <code class="highlighter-rouge">~-</code>，用变量 <code class="highlighter-rouge">OLDPWD</code> 的值，如果预先设置的话，就进行替换。</p>

<h5 id="6"><code class="highlighter-rouge">~6</code></h5>

<p>如果前缀是个数字 n，则把 <code class="highlighter-rouge">~n</code> 替换成目录堆栈的第 n 个目录。</p>

<h5 id="pathtest"><code class="highlighter-rouge">$PATH:~/test</code></h5>

<p>给变量赋值时，如果值是以 <code class="highlighter-rouge">：</code> 或 <code class="highlighter-rouge">=</code> 开头，也会进行扩展，因此可以用 <code class="highlighter-rouge">~</code> 和文件名的组合来为 <code class="highlighter-rouge">PATH</code>、<code class="highlighter-rouge">MAILPATH</code>、<code class="highlighter-rouge">CDPATH</code> 赋值，shell 会把扩展后的值赋给变量。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:~/test
</code></pre></div></div>

<p><code class="highlighter-rouge">~/test</code> 会先扩展为 <code class="highlighter-rouge">$HOME/test</code>，如果 <code class="highlighter-rouge">$HOME</code> 为 <code class="highlighter-rouge">/home/franky</code>，则 <code class="highlighter-rouge">/home/franky/test</code> 会加入 <code class="highlighter-rouge">PATH</code> 变量的内容中。</p>

<h4 id="344-shell-参数与变量扩展">3.4.4 shell 参数与变量扩展</h4>

<p>🍎 本节要特别感谢 <a href="https://blog.csdn.net/astrotycoon/article/details/78109827">astrotycoon</a> 的文章！</p>

<h5 id="参数的概念">参数的概念</h5>

<p>在 shell 编程中，参数是个 <strong>大概念</strong>，也是个笼统的概念，它是个实体，其中存储着各式各样的值。</p>

<p>可以通过三类方式来引用参数，从而得到参数中存储的值：</p>

<ul>
  <li>
    <p>通过 <strong>名称</strong> 来引用参数，这样的参数称之为 <strong>变量</strong>。</p>

    <p>一个变量拥有自己的值和诸多属性，属性可以通过 <code class="highlighter-rouge">declare</code> 来设定，可以通过 <code class="highlighter-rouge">unset</code> 来取消一个变量。</p>
  </li>
  <li>
    <p>通过 <strong>数字</strong> 来引用参数，这样的参数称之为 <strong>位置参数</strong>。</p>

    <p>位置参数在脚本被调用时自动初始化为传递给脚本的参数。脚本中调用函数时，位置参数会临时替换成传递给函数的参数。可以用 <code class="highlighter-rouge">set</code> 命令来改变位置参数的值，但无法通过赋值语句来改变。</p>
  </li>
  <li>
    <p>还有一类参数，被称之为 <strong>特殊参数</strong>。</p>

    <p>只能通过 shell 内部预定义的特殊符号来引用它们，并且只能引用，不能用赋值语句来重新赋值。预定义的特殊符号包括：<code class="highlighter-rouge">*</code>  <code class="highlighter-rouge">@</code>  <code class="highlighter-rouge">$</code>  <code class="highlighter-rouge">?</code>  <code class="highlighter-rouge">!</code>  <code class="highlighter-rouge">-</code>  <code class="highlighter-rouge">$</code>  <code class="highlighter-rouge">0</code></p>
  </li>
</ul>

<h5 id="参数扩展">参数扩展</h5>

<p>参数扩展就是通过符号 <code class="highlighter-rouge">$</code> 获得参数中存储的值。在获得最终结果之前，要对参数及数值进行一系列的操作，如删除、截取、替换等。</p>

<p>参数扩展最简单的形式为：<code class="highlighter-rouge">$参数</code> 或 <code class="highlighter-rouge">${参数}</code></p>

<p>被扩展的参数名可以用大括号括起来，大括号是可选的，但 <strong>建议总是加上</strong>。</p>

<ul>
  <li>使用大括号时，关闭的大括号不能被转义、被引用，也不能处于算术表达式、命令替换、参数替换中。</li>
  <li>大括号中参数的值将被替换。</li>
  <li>如果参数是大于一位的位置参数，如 <code class="highlighter-rouge">$15</code>，则必须要使用大括号，即 <code class="highlighter-rouge">${$15}</code>，否则 <code class="highlighter-rouge">$$15</code> 会被认为是 <code class="highlighter-rouge">$1</code> 后面跟着一个 5。</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">WORD</span><span class="o">=</span>car
<span class="nb">echo</span> <span class="k">${</span><span class="nv">WORD</span><span class="k">}</span>s and <span class="nv">$WORDs</span>
cars and
</code></pre></div></div>

<p class="notice--success">所以如果需要把变量名与紧随的字符区分开，就一定要使用大括号。</p>

<h6 id="常用的参数扩展方法">常用的参数扩展方法</h6>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">${var}</code></td>
      <td>变量 <code class="highlighter-rouge">var</code> 的值，同 <code class="highlighter-rouge">$var</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var-$DEFAULT}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 未设置，表达式求值结果为 <code class="highlighter-rouge">$DEFAULT</code> <sup>*</sup></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var:-$DEFAULT}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 未设置或为空，表达式求值结果为 <code class="highlighter-rouge">$DEFAULT</code> <sup>*</sup></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var=$DEFAULT}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 未设置，表达式求值结果为 <code class="highlighter-rouge">$DEFAULT</code> <sup>*</sup></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var:=$DEFAULT}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 未设置或为空，表达式求值结果为 <code class="highlighter-rouge">$DEFAULT</code> <sup>*</sup></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var+$OTHER}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 已设置，表达式求值结果为 <code class="highlighter-rouge">$OTHER</code>，否则为空</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var:+$OTHER}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 已设置，表达式求值结果为 <code class="highlighter-rouge">$OTHER</code>，否则为空</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var?$ERR_MSG}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 未设置，打印 <code class="highlighter-rouge">$ERR_MSG</code>，退出脚本，退出状态为 1。<sup>*</sup></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${var:?$ERR_MSG}</code></td>
      <td>如果 <code class="highlighter-rouge">var</code> 未设置，打印 <code class="highlighter-rouge">$ERR_MSG</code>，退出脚本，退出状态为 1。<sup>*</sup></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${!varprefix*}</code></td>
      <td>匹配之前所有以 <code class="highlighter-rouge">varprefix</code> 开头声明的变量</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">${!varprefix@}</code></td>
      <td>匹配之前所有以 <code class="highlighter-rouge">varprefix</code> 开头声明的变量</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">*</code> 如果 <code class="highlighter-rouge">var</code> 已设置，表达式求值结果为 <code class="highlighter-rouge">$var</code>。</p>

<h5 id="间接扩展">间接扩展</h5>

<p>间接扩展也称间接引用，是指用一个变量的值来传递另一个变量的名字。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NAME</span><span class="o">=</span><span class="s2">"VAR1"</span>
<span class="nv">VAR1</span><span class="o">=</span>42
<span class="nb">echo</span> <span class="k">${</span><span class="p">!NAME</span><span class="k">}</span>
42
</code></pre></div></div>

<p>如果参数的第一个字符是个感叹号 <code class="highlighter-rouge">!</code>，则参数其余的字符做为变量名，但该变量扩展成变量值以后，该变量值代表另一个变量的名字。</p>

<h5 id="子串扩展">子串扩展</h5>

<p><code class="highlighter-rouge">${parameter:offset}</code></p>

<p><code class="highlighter-rouge">${parameter:offset:length}</code></p>

<p>从 offset 位置开始，截取长度为 length 的子字符串，如果没有提供 length，则是从 offset 开始到结尾。</p>

<ul>
  <li>如果 offset 是负值，开始位置是从字符串末尾开始算起，取长度为 length 的子串。</li>
  <li>如果 length 是负值，则 length 不再代表字符串长度，而代表另一个 offset，位置从字符串末尾开始，扩展的结果是 offset ~ length 之间的子串。</li>
  <li>如果 parameter 是 <code class="highlighter-rouge">@</code>，即所有的位置参数时，offset 必须从 1 开始。</li>
</ul>

<p>当 offset 是负值时，负号 <code class="highlighter-rouge">-</code> 与前面的冒号 <code class="highlighter-rouge">:</code> 必须用空格分开，或者把负数用括号括起来：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo ${MYSTRING: -34:13}
echo ${MYSTRING:(-34):13}
</code></pre></div></div>

<h5 id="查找并替换">查找并替换</h5>

<p><code class="highlighter-rouge">${parameter/pattern/string}</code></p>

<p><code class="highlighter-rouge">${parameter//pattern/string}</code></p>

<p><code class="highlighter-rouge">${parameter/pattern}</code></p>

<p><code class="highlighter-rouge">${parameter//pattern}</code></p>

<p>匹配后的子串会用 string 替换掉。</p>

<ul>
  <li>parameter 之后如果是 <code class="highlighter-rouge">/</code>，则只替换匹配到的 <strong>第一个</strong> 子串；parameter 之后如果是 <code class="highlighter-rouge">//</code>，则替换 <strong>所有</strong> 匹配到的子串。</li>
  <li>当 string 为空时，则相当于将匹配的子串 <strong>删除</strong>。</li>
  <li>特殊符号 <code class="highlighter-rouge">#</code> 和 <code class="highlighter-rouge">%</code> 在这种情况下分别锚定字符串的 <strong>开始</strong> 和 <strong>结尾</strong>。</li>
  <li>如果 bash 的 nocasematch 选项是打开的，则匹配的过程大小写是不敏感的。</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ MYSTRING</span><span class="o">=</span><span class="s2">"Be liberal in what you accept, and conservative in what you send"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">MYSTRING</span><span class="p">/in/by</span><span class="k">}</span>
Be liberal by what you accept, and conservative <span class="k">in </span>what you send
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">MYSTRING</span><span class="p">//in/by</span><span class="k">}</span>
Be liberal by what you accept, and conservative by what you send
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">MYSTRING</span><span class="p">/conservative/</span><span class="k">}</span>
Be liberal <span class="k">in </span>what you accept, and <span class="k">in </span>what you send

<span class="nv">$ MYSTRING</span><span class="o">=</span>xxxxxxxxxxxxxxx
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">MYSTRING</span><span class="k">}</span>
xxxxxxxxxxxxxxx
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">MYSTRING</span><span class="p">/#x/y</span><span class="k">}</span>
yxxxxxxxxxxxxxx
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">MYSTRING</span><span class="p">/%x/y</span><span class="k">}</span>
xxxxxxxxxxxxxxy
</code></pre></div></div>

<p>bash 的这个查找替换功能跟 <code class="highlighter-rouge">sed</code> 的很像，不同的是这里的 pattern 不是正则表达式。</p>

<h5 id="查找并删除">查找并删除</h5>

<p><code class="highlighter-rouge">${parameter#pattern}</code></p>

<p><code class="highlighter-rouge">${parameter##pattern}</code></p>

<p><code class="highlighter-rouge">${parameter%pattern}</code></p>

<p><code class="highlighter-rouge">${parameter%%pattern}</code></p>

<p>删除匹配到的子串。其中操作符 <code class="highlighter-rouge">#</code> 与 <code class="highlighter-rouge">%</code> 的作用为：</p>

<ul>
  <li><code class="highlighter-rouge">#</code>  行首起，匹配第一个</li>
  <li><code class="highlighter-rouge">##</code> 行首起，匹配所有</li>
  <li><code class="highlighter-rouge">%</code>  行尾起，匹配第一个</li>
  <li><code class="highlighter-rouge">%%</code> 行尾起，匹配所有</li>
</ul>

<p>例如：<code class="highlighter-rouge">file=/dir1/dir2/dir3/my.file.txt</code>  定义变量</p>

<p><code class="highlighter-rouge">${file#*/}</code> ：<code class="highlighter-rouge">dir1/dir2/dir3/my.file.txt </code></p>

<p><code class="highlighter-rouge">${file##*/}</code> ：<code class="highlighter-rouge">my.file.txt</code> ，相当于 <code class="highlighter-rouge">basename ${file}</code></p>

<p><code class="highlighter-rouge">${file#*.}</code> ：<code class="highlighter-rouge">file.txt</code></p>

<p><code class="highlighter-rouge">${file##*.}</code> ：<code class="highlighter-rouge">txt</code></p>

<p><code class="highlighter-rouge">${file%/*}</code> ：<code class="highlighter-rouge">/dir1/dir2/dir3</code>，相当于 <code class="highlighter-rouge">dirname ${file}</code></p>

<p><code class="highlighter-rouge">${file%%/*}</code> ：空值</p>

<p><code class="highlighter-rouge">${file%.*}</code> ：<code class="highlighter-rouge">/dir1/dir2/dir3/my.file</code></p>

<p><code class="highlighter-rouge">${file%%.*}</code> ：<code class="highlighter-rouge">/dir1/dir2/dir3/my</code></p>

<h5 id="获取参数长度">获取参数长度</h5>

<p><code class="highlighter-rouge">${#parameter}</code></p>

<p>返回 parameter 值的长度。</p>

<h5 id="大小写转换">大小写转换</h5>

<p><code class="highlighter-rouge">${parameter^}</code>  ：将第一个字符转成大写</p>

<p><code class="highlighter-rouge">${parameter^^}</code>  ：将所有字符转成大写</p>

<p><code class="highlighter-rouge">${parameter,}</code>  ： 将第一个字符转成小写</p>

<p><code class="highlighter-rouge">${parameter,,}</code>  ： 将所有字符转成小写</p>

<h4 id="345-命令替换">3.4.5 命令替换</h4>

<p>可以用一个命令的输出来替换命令本身。</p>

<p><code class="highlighter-rouge">$(command)</code> 或 <code class="highlighter-rouge">`command`</code></p>

<p>扩展时，bash 先执行该命令，然后用其输出来替换命令本身，末尾的换行符会被删除，中间的换行符不会删。</p>

<ul>
  <li>如果使用 <code class="highlighter-rouge">`command`</code> 形式：如果 <code class="highlighter-rouge">\</code> 后面是 <code class="highlighter-rouge">$</code>、<code class="highlighter-rouge">`</code>、<code class="highlighter-rouge">\</code>，会将其转义，否则就是 <code class="highlighter-rouge">\</code> 本身。</li>
  <li>如果使用 <code class="highlighter-rouge">$(command)</code> 形式：括号里的所有字符都正常处理。</li>
  <li>命令替换可嵌套，如果用反引号形式，里面的那层反引号需要用 <code class="highlighter-rouge">\</code> 转义。</li>
</ul>

<p>如果命令替换出现在双引号里面，不会对结果进行词汇分割和文件名扩展。</p>

<h4 id="346-算术表达式">3.4.6 算术表达式</h4>

<p>算术表达式会对表达式进行计算，并用计算结果进行替换。</p>

<p>基本形式：  <code class="highlighter-rouge">$(( EXPRESSION ))</code></p>

<p>表达式中的所有记号都会经历参数扩展、命令替换、去除引用。</p>

<p>算术表达式可以嵌套。</p>

<p>计算表达式时会用等宽整数，不会进行溢出检查，除以 0 会被捕获，并标记为错误。</p>

<table>
  <thead>
    <tr>
      <th>运算符</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">VAR++</code>  <code class="highlighter-rouge">VAR--</code></td>
      <td>后缀自增、自减</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">++VAR</code>  <code class="highlighter-rouge">--VAR</code></td>
      <td>前缀自增、自减</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">+</code> <code class="highlighter-rouge">-</code></td>
      <td>加、减</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">*</code> <code class="highlighter-rouge">/</code> <code class="highlighter-rouge">%</code></td>
      <td>乘、除、余数</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">**</code></td>
      <td>求幂</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">!</code></td>
      <td>逻辑否</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&amp;&amp;</code></td>
      <td>逻辑与</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">||</code></td>
      <td>逻辑或</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">==</code> <code class="highlighter-rouge">!=</code></td>
      <td>等于、不等于</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&lt;</code>  <code class="highlighter-rouge">&lt;=</code> <code class="highlighter-rouge">&gt;</code> <code class="highlighter-rouge">&gt;=</code></td>
      <td>比较运算符</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">~</code></td>
      <td>按位取反</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&lt;&lt;</code> <code class="highlighter-rouge">&gt;&gt;</code></td>
      <td>按位左移、按位右移</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&amp;</code></td>
      <td>按位与</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">|</code></td>
      <td>按位或</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">^</code></td>
      <td>按位异或</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">expr1 ? expr2 : expr3</code></td>
      <td>条件计算</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">=</code> <code class="highlighter-rouge">*=</code> <code class="highlighter-rouge">/=</code> <code class="highlighter-rouge">%=</code> <code class="highlighter-rouge">+=</code> <code class="highlighter-rouge">-=</code> <code class="highlighter-rouge">&lt;&lt;=</code> <code class="highlighter-rouge">&gt;&gt;=</code> <code class="highlighter-rouge">&amp;=</code> <code class="highlighter-rouge">^=</code> <code class="highlighter-rouge">|=</code></td>
      <td>赋值</td>
    </tr>
  </tbody>
</table>

<p>shell 变量也可作为运算对象。计算前会先进行参数扩展。在表达式中，shell 变量也可以由名称引用，而不使用参数扩展语法。变量的值在引用时作为算术表达式求值。一个 shell 变量不需要开启它的整数属性就可以用于表达式。</p>

<h5 id="进制表示">进制表示</h5>

<p>由 0 开头的常数被看作八进制数字。</p>

<p>由 0x 或 0X 开头的为十六进制。</p>

<p>否则就使用 <code class="highlighter-rouge">[BASE'#']N</code> 的形式：BASE 是一个 2~64 的二进制数字，代表是什么进制，N 是该进制的数字。如果 <code class="highlighter-rouge">BASE'#'</code> 被省略，则认为是十进制的数字。大于 9 的数字依次用小写字母、大写字母、<code class="highlighter-rouge">@</code>、<code class="highlighter-rouge">_</code> 来表示。如果 BASE 小于等于 36，大小写可以相互混用，来代表 10~35 的数字。</p>

<p>运算符按优先顺序进行计算，括号中的子表达式最先计算，可以覆盖上面的规则。</p>

<p>只要可能，就建议尽量使用这种形式的表达式：</p>

<p><code class="highlighter-rouge">$[ EXPRESSION ]</code></p>

<p>但这种形式只能计算，不能进行条件的测试。</p>

<h4 id="347-进程替换">3.4.7 进程替换</h4>

<p>用管道将一个命令的标准输出传递给另一个命令的标准输入，这是个强大的技术。但是，如果要用管道来传递 <strong>多个命令</strong> 的标准输出该怎么做？这时候进程替换就派上用场了。进程替换可以把一个（或多个）进程的输出送到另一个进程的标准输入。</p>

<h5 id="原理">原理</h5>

<p class="notice--info">进程替换是 <strong>进程间通讯</strong> 的一种形式，允许一个命令的输入或输出看上去 <strong>像个文件</strong> 一样。bash 会将 <strong>命令</strong> 在线 <strong>替换</strong> 成一个 <strong>文件名</strong>，借助这种方法，原来只能接受文件做为参数的命令，现在可以直接从另一个程序读取输入，或把输出直接写到另一个程序。</p>

<p>进程替换是 <strong>重定向</strong> 的一种形式，一个进程的输入或输出显示为一个 <strong>临时文件</strong>。</p>

<p>进程替换与参数扩展、命令替换和算术扩展是 <strong>同时</strong> 进行的。</p>

<h5 id="语法">语法</h5>

<p>格式： <code class="highlighter-rouge">&gt;(command_list)</code> 或 <code class="highlighter-rouge">&lt;(command_list)</code></p>

<p><code class="highlighter-rouge">&lt;</code> 或 <code class="highlighter-rouge">&gt;</code> 与括号之间没有空格，加上空格或报错。</p>

<p>括号中的命令执行以后，其：</p>

<ul>
  <li>形式为 <code class="highlighter-rouge">&lt;( )</code> 的标准输出文件描述符  或</li>
  <li>形式为 <code class="highlighter-rouge">&gt;( )</code> 的标准输入文件描述符</li>
</ul>

<p>被连接到一个 FIFO 文件上，或 <code class="highlighter-rouge">/dev/fd/</code> 目录中的某个文件上。然后，文件描述符所连接的文件名被用来替换 <code class="highlighter-rouge">&lt;( )</code> 或 <code class="highlighter-rouge">&gt;( )</code> 结构。</p>

<p>有些程序只支持从文件获取输入，不支持从标准输入获取，因此无法从管道获取输入。借助进程替换，这些程序就可以接收来自于其它程序的数据了。</p>

<h5 id="范例">范例</h5>

<p>这个例子最便于理解进程替换格式的含义：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> &lt;<span class="o">(</span><span class="nb">ls</span><span class="o">)</span>
aa
bbb
cccc

<span class="nv">$ </span><span class="nb">echo</span> &lt;<span class="o">(</span><span class="nb">ls</span><span class="o">)</span>
/dev/fd/63
</code></pre></div></div>

<p><code class="highlighter-rouge">&lt;(ls)</code> 改变了 ls 的输出定向。原本 <code class="highlighter-rouge">ls</code> 的输出是到标准输出的，但 <code class="highlighter-rouge">&lt;(ls)</code> 把输出指向了一个临时文件，用描述符 <code class="highlighter-rouge">/dev/fd/63</code> 来表示。</p>

<p>文件名作为 <code class="highlighter-rouge">cat</code> 的参数时，会将文件内容打印出来，即 <code class="highlighter-rouge">ls</code> 的文件列表。</p>

<p>文件名作为 <code class="highlighter-rouge">echo</code> 的参数时，只会把*文件名本身打印出来。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /usr/share/dict/linux.words | <span class="nb">wc
 </span>479828  479828 4953680
<span class="nv">$ </span><span class="nb">wc</span> &lt;<span class="o">(</span><span class="nb">cat</span> /usr/share/dict/linux.words<span class="o">)</span>
 479828  479828 4953680 /dev/fd/63
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>diff <span class="nt">-u</span> &lt;<span class="o">(</span>ps<span class="o">)</span> &lt;<span class="o">(</span>ps <span class="nt">-e</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff <span class="nt">-u</span> .bashrc &lt;<span class="o">(</span>ssh remote <span class="nb">cat</span> .bashrc<span class="o">)</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rsync <span class="nt">-arv</span> <span class="nt">--log-file</span><span class="o">=&gt;(</span><span class="nb">grep</span> <span class="nt">-vF</span> .tmp <span class="o">&gt;</span>log.txt<span class="o">)</span> src/ host::dst/
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ps <span class="nt">-ef</span> | <span class="nb">tee</span> <span class="o">&gt;(</span><span class="nb">awk</span> <span class="s1">'$1=="tom"'</span> <span class="o">&gt;</span>toms-procs.txt<span class="o">)</span> <span class="se">\</span>
               <span class="o">&gt;(</span><span class="nb">awk</span> <span class="s1">'$1=="root"'</span> <span class="o">&gt;</span>roots-procs.txt<span class="o">)</span> <span class="se">\</span>
</code></pre></div></div>

<h4 id="348-字段分割">3.4.8 字段分割</h4>

<p>Word Splitting</p>

<p>如果 <code class="highlighter-rouge">IFS</code> 的值为空（null），就不会进行字段分割。</p>

<p>如果没有发生扩展，也不会进行字段分割。</p>

<p>在参数扩展、命令替换及算术扩展之后，shell 扫描得到的结果，找到双引号，对里面的内容进行字段分割。</p>

<p>shell 把 <code class="highlighter-rouge">$IFS</code> 的每一个字符都做为分隔符，在这些分隔符上进行分割，把其它扩展的结果分割成单独的字段。</p>

<ul>
  <li>如果 <code class="highlighter-rouge">IFS</code> 没有设置，或其值是 <code class="highlighter-rouge">&lt;space&gt;&lt;tab&gt;&lt;newline&gt;</code> 这个默认值，则 <code class="highlighter-rouge">IFS</code> 字符的任何排列都可以用来切割字段。</li>
  <li>如果 <code class="highlighter-rouge">IFS</code> 中含有非默认值，而且 <code class="highlighter-rouge">IFS</code> 中包含空白字符（空格或制表符），则词汇开头和结尾的空白字符序列会被忽略。</li>
  <li><code class="highlighter-rouge">IFS</code> 中的非空白字符与空白字符的组合也可以用来分割。</li>
  <li><code class="highlighter-rouge">IFS</code> 空白字符的序列可以用来分割。</li>
</ul>

<h5 id="范例-1">范例</h5>

<p>这东西必须得有实例才能直观地理解。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">x</span><span class="o">=</span><span class="s1">'   one , tow,      three    '</span>
<span class="nb">printf</span> <span class="s2">"&lt;%s&gt;</span><span class="se">\n</span><span class="s2">"</span> <span class="nv">$x</span>
&lt;one&gt;
&lt;two&gt;
&lt;three&gt;
<span class="c">#  IFS 没有设置，使用默认值</span>
<span class="c">#+ 无论这些空白是纯空格，纯制表符，</span>
<span class="c">#+ 还是空格与制表符的组合，都看作单一分隔符</span>


<span class="nv">IFS</span><span class="o">=</span><span class="s1">','</span>
<span class="nv">x</span><span class="o">=</span><span class="s1">'  one , tow,three  '</span>
<span class="nb">printf</span> <span class="s2">"&lt;%s&gt;</span><span class="se">\n</span><span class="s2">"</span> <span class="nv">$x</span>
&lt;  one <span class="o">&gt;</span>
&lt; two&gt;
&lt;three  <span class="o">&gt;</span>
<span class="c"># IFS 只有逗号时，空格也被看作普通字符</span>


<span class="nv">IFS</span><span class="o">=</span><span class="s1">' ,'</span>
<span class="nv">x</span><span class="o">=</span><span class="s1">'  one , tow,three  '</span>
<span class="nb">printf</span> <span class="s2">"&lt;%s&gt;</span><span class="se">\n</span><span class="s2">"</span> <span class="nv">$x</span>
&lt;one&gt;
&lt;two&gt;
&lt;three&gt;
<span class="c"># IFS 为空格和逗号时，空格与逗号的任何组合都被看作单一的分隔符</span>
</code></pre></div></div>

<h4 id="349-文件名扩展">3.4.9 文件名扩展</h4>

<blockquote>
  <p><code class="highlighter-rouge">set -f</code> 会禁止 bash 使用通配符做文件名。</p>
</blockquote>

<p>如果 bash 没有开启 <code class="highlighter-rouge">-f</code> 选项，词汇分割之后，它就会在字段中查找 <code class="highlighter-rouge">*</code>、<code class="highlighter-rouge">?</code>、<code class="highlighter-rouge">[</code> 这些字符。如果找到，该字段即被当作文件名 <strong>匹配模板</strong>。</p>

<ul>
  <li>如果有匹配的文件名：文件列表会按字母排序，然后替换掉模板本身。</li>
  <li>如果没有匹配的文件名：<code class="highlighter-rouge">nullglob</code> 选项没有开启，该字段就不做任何改动；若 <code class="highlighter-rouge">nullglob</code> 选项开启，该字段会被删除。</li>
  <li>如果 <code class="highlighter-rouge">nocaseglob</code> 选项开启，匹配时会忽略大小写。</li>
  <li>如果选项 <code class="highlighter-rouge">dotglob</code> 没有开启，文件名开头的 <code class="highlighter-rouge">.</code> 或  <code class="highlighter-rouge">./</code> 必须显式匹配：<code class="highlighter-rouge">*</code> 不可匹配 <code class="highlighter-rouge">.file</code>，只有 <code class="highlighter-rouge">.*</code> 才能匹配；同理，只有 <code class="highlighter-rouge">./*</code> 才能匹配 <code class="highlighter-rouge">./file</code>。</li>
  <li>在匹配文件名的过程中，<code class="highlighter-rouge">/</code> 始终要显式匹配：<code class="highlighter-rouge">*</code> 不能匹配 <code class="highlighter-rouge">/dir</code>，只有 <code class="highlighter-rouge">/*</code> 才能匹配。</li>
  <li><code class="highlighter-rouge">GLOBIGNORE</code> 变量可以用来限制文件名如何匹配模板：如果设置了该变量，匹配的文件名中，如果同时也匹配该变量，该文件名会被移除。文件名 <code class="highlighter-rouge">.</code> 和 <code class="highlighter-rouge">..</code> 不受该变量的限制，会被忽略。</li>
  <li>设置 <code class="highlighter-rouge">GLOBIGNORE</code> 变量相当于开启了 <code class="highlighter-rouge">dotglob</code> 选项，于是以 <code class="highlighter-rouge">.</code> 开头的文件名也会被通配符匹配：<code class="highlighter-rouge">*</code> 可以匹配 <code class="highlighter-rouge">.file</code>。</li>
</ul>

<h3 id="35-别名">3.5 别名</h3>

<h4 id="351-别名简介">3.5.1 别名简介</h4>

<p>别名就是用简短的字段来代替一个通常是更复杂的字符串。</p>

<p>shell 平时维护了一个 <strong>别名列表</strong>。用 <code class="highlighter-rouge">alias</code> 和 <code class="highlighter-rouge">unalias</code> 命令来添加和删除其中的条目。</p>

<p><code class="highlighter-rouge">alias</code> 不加参数运行，可以查看该列表内容。</p>

<h5 id="别名的用途">别名的用途</h5>

<ul>
  <li>同一个命令在系统中有多个版本，用别名可以简化不同版本的调用</li>
  <li>设置命令的默认选项</li>
  <li>纠正易发的错误拼写</li>
</ul>

<h5 id="别名的扩展">别名的扩展</h5>

<ul>
  <li>在非交互式 shell 中不会发生别名扩展，除非使用 <code class="highlighter-rouge">shopt</code> 命令来启用 <code class="highlighter-rouge">expand_aliases</code> 选项。</li>
  <li>简单命令中的 <strong>第一个字段</strong> 如果 <strong>没被引用</strong>，会被检查是否是别名。如果是，则用其原始内容替换。<code class="highlighter-rouge">'ll' /tmp</code> 不会被扩展。</li>
  <li>除了别名中不能包含 <code class="highlighter-rouge">=</code> 以外，别名与原始内容可以包含任何有效的 shell 输入，包括 shell 元字符。</li>
  <li><strong>原始内容</strong> 中的第一个字段会被 <strong>再次</strong> 检查，看是不是其它别名。但同一个别名只会扩展一次：如把 <code class="highlighter-rouge">ls -F</code> 做名别名 <code class="highlighter-rouge">ls</code>，bash 会正常执行 <code class="highlighter-rouge">ls -F</code>，而不会没完没了地递归扩展下去。</li>
  <li>
    <p>默认情况下，bash 只会检查一行命令中的 <strong>第一个字段</strong> 是不是别名。但是，如果第一个别名的原始内容其 <strong>最后一个字符是空白字符</strong>，则会检查紧挨着的 <strong>第二个字段</strong> 是否别名：
  如：<code class="highlighter-rouge">sudo ll</code>，bash 默认只会检查 <code class="highlighter-rouge">sudo</code> 是否别名，而不会检查 <code class="highlighter-rouge">ll</code>。要想让 <code class="highlighter-rouge">ll</code> 别名被检查，可以重新给 <code class="highlighter-rouge">sudo</code> 加个别名：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">alias sudo</span><span class="o">=</span><span class="s1">'sudo '</span>
</code></pre></div>    </div>

    <p>别名 <code class="highlighter-rouge">sudo</code> 的原始内容为 <code class="highlighter-rouge">sudo </code>，其最后一个为空白字符，因此跟随它后面的命令也会被检查。</p>
  </li>
</ul>

<h4 id="352-创建与删除别名">3.5.2 创建与删除别名</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s1">'ls -l'</span>

<span class="nb">unalias </span>ll
</code></pre></div></div>

<p>bash 总是要把一行命令完整地读取完毕，然后才会执行其中的命令。因此，别名的扩展发生于 <strong>读取命令时</strong>，而非执行命令时。</p>

<p>因此，创建别名时，不要指望在同一行马上就使用：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s1">'ls -l'</span><span class="p">;</span> ll
bash: ll: <span class="nb">command </span>not found...
</code></pre></div></div>

<p>刚创建的别名，至少要在创建别名的这一行命令的下一行才能开始生效。</p>

<p>因此，要把创建别名的命令单独放在一行，不建议放到复合命令中去。</p>

<p>别名不会被子进程所继承。</p>

<p class="notice--info">别名扩展是在执行函数之后进行的，因此相对来说解析的稍慢一些。虽然别名更容易理解，但还是建议 <strong>尽量使用函数</strong> 而不使用别名。</p>

<h3 id="36-bash-其它选项">3.6 bash 其它选项</h3>

<h4 id="361-查看选项">3.6.1 查看选项</h4>

<p><code class="highlighter-rouge">set -o</code> 可以查看所有 shell 选项。</p>

<h4 id="362-修改选项">3.6.2 修改选项</h4>

<p>shell 的这些选项，可以在调用 shell 的时候设定，也可以在 shell 运行期间修改，还可以把选项直接写到启动脚本里。</p>

<h5 id="调用-shell-时设定">调用 shell 时设定</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bash <span class="nt">--posix</span> script.sh
</code></pre></div></div>

<h5 id="运行期间修改">运行期间修改</h5>

<p>要想临时修改当前环境，或想在脚本中修改选项，最好就是用 <code class="highlighter-rouge">set</code> 命令，<code class="highlighter-rouge">- 选项</code> 为启用，<code class="highlighter-rouge">+ 选项</code> 为禁用。</p>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	<hr />
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/bash" class="page__taxonomy-item" rel="tag">bash</a><span class="sep">  </span>
    
		
      <a href="/tag/环境" class="page__taxonomy-item" rel="tag">环境</a>
    
    </span>
  </p>













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://linotes.netlify.com/categories/#programming" class="page__taxonomy-item" rel="tag">programming</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2017-05-03T00:00:00+08:00">May 03, 2017</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="https://linotes.netlify.com/programming/progr.intro/" class="pagination--pager" title="上一页
">Python 编程导论</a>
    
    
      <a href="https://linotes.netlify.com/programming/bash02/" class="pagination--pager" title="下一页
">Bash 入门 02</a>
    
  </nav>


    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">相关文章</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/kernel/filedescriptor/" rel="permalink">文件描述符简介
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash03/" rel="permalink">Bash 入门 03
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">循环，变量，函数，捕捉信号
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash02/" rel="permalink">Bash 入门 02
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">正则表达式，SED，AWK，条件结构，交互式脚本
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/progr.intro/" rel="permalink">Python 编程导论
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">以 Python 为例，学习编程基础。
</p>
-->

  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
    
    
    
    
    <li><a href="https://linotes.netlify.com/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://linotes.netlify.com/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>








  </body>
</html>
