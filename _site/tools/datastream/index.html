<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Linux 的使用 - 数据流处理 - LINOTES</title>
<meta name="description" content="grep, sed，awk,">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Linux 的使用 - 数据流处理">
<meta property="og:url" content="https://linotes.netlify.com/tools/datastream/">


  <meta property="og:description" content="grep, sed，awk,">



  <meta property="og:image" content="https://linotes.netlify.com/assets/images/header/linux.jpg">





  <meta property="article:published_time" content="2015-02-01T00:00:00+08:00">






<link rel="canonical" href="https://linotes.netlify.com/tools/datastream/">













<!-- end _includes/seo.html -->


<link href="https://linotes.netlify.com/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://linotes.netlify.com/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->






<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://linotes.netlify.com/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/app/rsync/">Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/server/vsftpd/">Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/kernel/filedescriptor/">文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://linotes.netlify.com/tools/tools.datastream/">数据流处理</a>
            </li>
          
        </ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay" style=" background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://linotes.netlify.com/assets/images/header/linux.jpg');">
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Linux 的使用 - 数据流处理

        
      </h1>
      
        <p class="page__lead">grep, sed，awk,
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://linotes.netlify.com/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:imhawkz@gmail.com">
            <meta itemprop="email" content="imhawkz@gmail.com">
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox">
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Linux 的使用 - 数据流处理">
    <meta itemprop="description" content="grep, sed，awk,">
    <meta itemprop="datePublished" content="February 01, 2015">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-laptop"></i> Linux 的使用 - 数据流处理</h4></header>
              <ul class="toc__menu">
  <li>
<a href="#grep">GREP</a>
    <ul>
      <li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li>
      <li><a href="#%E8%8C%83%E4%BE%8B">范例</a></li>
    </ul>
  </li>
  <li>
<a href="#sed">SED</a>
    <ul>
      <li><a href="#%E8%AF%AD%E6%B3%95-1">语法</a></li>
      <li><a href="#%E8%8C%83%E4%BE%8B-1">范例</a></li>
    </ul>
  </li>
  <li>
<a href="#awk">AWK</a>
    <ul>
      <li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
      <li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a></li>
      <li><a href="#%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F">内建变量</a></li>
      <li><a href="#%E8%AF%AD%E6%B3%95-2">语法</a></li>
      <li><a href="#%E9%80%89%E9%A1%B9">选项</a></li>
      <li><a href="#%E6%A8%A1%E6%9D%BF">模板</a></li>
      <li><a href="#%E6%93%8D%E4%BD%9C">操作</a></li>
      <li><a href="#%E5%88%86%E9%9A%94%E7%AC%A6">分隔符</a></li>
      <li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
      <li><a href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0">内建函数</a></li>
    </ul>
  </li>
  <li>
<a href="#%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6">输入控制</a>
    <ul>
      <li><a href="#read">READ</a></li>
    </ul>
  </li>
  <li>
<a href="#%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6">输出控制</a>
    <ul>
      <li><a href="#%E5%9D%97%E6%93%8D%E4%BD%9C">块操作</a></li>
      <li><a href="#%E8%A1%8C%E6%93%8D%E4%BD%9C">行操作</a></li>
      <li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">字符串操作</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p>grep 、sed、awk 被称为 linux 中的 “三剑客”。</p>

<ul>
  <li>grep 适合单纯的 <strong>查找</strong> 或 <strong>匹配</strong> 文本</li>
  <li>sed  适合 <strong>编辑</strong> 匹配到的文本</li>
  <li>awk  适合 <strong>格式化</strong> 文本，对文本进行较复杂格式处理</li>
</ul>

<h2 id="grep">GREP</h2>

<h3 id="语法">语法</h3>

<p>检索文件内容，列出模板所在的行。模板可以是字符串或正则表达式，支持 BRE 和 ERE。</p>

<p><code class="highlighter-rouge">grep [-A] [-B] [--color=auto] '模板' filename</code></p>

<p><code class="highlighter-rouge">-A</code>  列出该行及其后 n 行</p>

<p><code class="highlighter-rouge">-B</code>  列出该行及其前 n 行</p>

<p><code class="highlighter-rouge">--color=auto</code>  标记颜色</p>

<p><code class="highlighter-rouge">-n</code>  显示行号</p>

<h3 id="范例">范例</h3>

<h4 id="正向匹配">正向匹配</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>last | <span class="nb">grep</span> <span class="s1">'root'</span>
</code></pre></div></div>

<h4 id="反向匹配">反向匹配</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>last | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'root'</span>
</code></pre></div></div>

<h4 id="使用高亮">使用高亮</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">--color</span><span class="o">=</span>auto <span class="s1">'MANPATH'</span> /etc/man_db.conf
</code></pre></div></div>

<h4 id="统计匹配次数">统计匹配次数</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>last | <span class="nb">grep</span> <span class="nt">-c</span> root
10
</code></pre></div></div>

<h4 id="忽略大小写">忽略大小写</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-i</span> shit file
</code></pre></div></div>

<h4 id="显示行号">显示行号</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-n</span> shit file
</code></pre></div></div>

<h4 id="以文本方式对待二进制文件">以文本方式对待二进制文件</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-a</span> shit bin
</code></pre></div></div>

<h4 id="查看关键字所在行的前后内容">查看关键字所在行的前后内容</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>dmesg | <span class="nb">grep</span> <span class="nt">-n</span> <span class="nt">-A1</span> <span class="nt">-B5</span> <span class="nt">--color</span><span class="o">=</span>auto <span class="s1">'qxl'</span> file
</code></pre></div></div>

<p>A: After。<code class="highlighter-rouge">-A1</code> 关键字所在行的后 1 行。</p>

<p>B: Before。<code class="highlighter-rouge">-B5</code> 关键字所在行的前 5 行。</p>

<h2 id="sed">SED</h2>

<p>Stream EDitor</p>

<p>sed 是一种流编辑器，它是文本处理中非常强大的工具，能够完美的配合正则表达式使用，功能不同凡响。</p>

<p class="notice">处理时，把当前处理的行存储在临时缓冲区中，称为 “模板空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容发送到屏幕。接着处理下一行，这样不断重复，直到文件末尾。它不会主动修改文件内容。</p>

<p>Sed 主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>

<h3 id="语法-1">语法</h3>

<p>sed [options] ‘command’ file(s)
sed [options] -f scriptfile file(s)</p>

<h4 id="-options-">[ options ]</h4>

<p><code class="highlighter-rouge">-e script</code>	在命令行用指定的参数来处理，常用于同时进行 <strong>多个操作</strong></p>

<p><code class="highlighter-rouge">-f script</code>	用指定的 <strong>脚本</strong> 文件来处理</p>

<p><code class="highlighter-rouge">-n</code> <strong>仅显示</strong> 由脚本处理过的行，否则会显示文件所有行</p>

<p><code class="highlighter-rouge">-r</code>  使用 ERE</p>

<p><code class="highlighter-rouge">-i</code>  直接修改文件内容</p>

<h4 id="-command-">[ command ]</h4>

<p><code class="highlighter-rouge">[n1[,n2]]function</code></p>

<p>n1, n2：可选，表示选择范围的起止行数</p>

<p>function：</p>

<p><code class="highlighter-rouge">a</code>  在当前行下面插入一行</p>

<p><code class="highlighter-rouge">c</code>  修改指定行的内容</p>

<p><code class="highlighter-rouge">d</code>  删除指定行</p>

<p><code class="highlighter-rouge">i</code>  在当前行上面插入一行</p>

<p><code class="highlighter-rouge">p</code>  输出</p>

<p><code class="highlighter-rouge">s</code>  替换，可以直接进行替换，可搭配正则表达式</p>

<p class="notice--success">sed 后面如果要接超过两个以上的操作时，每个操作之前均要加 <code class="highlighter-rouge">-e</code> 。</p>

<h3 id="范例-1">范例</h3>

<h4 id="删除">删除</h4>

<h5 id="删除单行">删除单行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'4d'</span>
</code></pre></div></div>

<h5 id="删除连续多行">删除连续多行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'2,5d'</span>
</code></pre></div></div>

<h5 id="删除第-3-行至末行">删除第 3 行至末行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'3,$d'</span>
</code></pre></div></div>

<h4 id="整行替换">整行替换</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="s1">'行范围c 替换内容'</span> file
</code></pre></div></div>

<p>行范围：单行用一个数字表示行号；多行用逗号 <strong><code class="highlighter-rouge">,</code></strong> 连接两个行号来表示。</p>

<p>紧随的 <code class="highlighter-rouge">c</code> 表示将范围内所有行修改为空格后面的字符串。</p>

<h5 id="替换单行">替换单行</h5>

<p>行范围为一个数字：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'3c holly shit'</span> file
</code></pre></div></div>

<p>把第 3 行的全部内容替换为 <code class="highlighter-rouge">holly shit</code>。</p>

<h5 id="替换连续多行">替换连续多行</h5>

<p>行范围为逗号连接的两个行号：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'2,5c No 2-5 number'</span>
</code></pre></div></div>

<p>原来的第 2~5 行，会被替换为一行，内容为 <code class="highlighter-rouge">No 2-5 number</code>：</p>

<h4 id="字符串替换">字符串替换</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="s1">'s/关键字/替换/g'</span>
</code></pre></div></div>

<p>在行内替换匹配的字符串。</p>

<p><code class="highlighter-rouge">s</code> 代表搜索，<code class="highlighter-rouge">g</code> 表示 global，全局替换。</p>

<p class="notice">如果没有 <code class="highlighter-rouge">g</code> 则只替换当前行的 <strong>第一个</strong> 匹配，加上 <code class="highlighter-rouge">g</code> 则替换当前行中 <strong>所有</strong> 匹配。</p>

<h6 id="替换关键字">替换关键字</h6>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'s/good/bad/'</span> file   <span class="c"># 每行仅替换第一个匹配</span>
<span class="nv">$ </span><span class="nb">sed</span> <span class="s1">'s/good/bad/g'</span> file  <span class="c"># 每行替换所有匹配</span>
</code></pre></div></div>

<h6 id="删除文件中的注释行">删除文件中的注释行</h6>

<p><code class="highlighter-rouge">cat /etc/man_db.conf | grep 'MAN' | sed 's/#.*$//g'</code></p>

<h6 id="从-ifconfig-文件中查看-ip-地址">从 ifconfig 文件中查看 IP 地址</h6>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ifconfig eth0 | <span class="nb">grep</span> <span class="s1">'inet '</span> | <span class="nb">sed</span> <span class="s1">'s/^.*inet //g'</span> | <span class="nb">sed</span> <span class="s1">'s/ netmask.*$//g'</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>ipconfig 原始信息</td>
      <td>取出 IP 地址所在行</td>
      <td>删除 IP 地址前面字符</td>
      <td>删除后面字符</td>
    </tr>
  </tbody>
</table>

<h4 id="插入行">插入行</h4>

<p><code class="highlighter-rouge">a</code>  在当前行下面插入</p>

<p><code class="highlighter-rouge">i</code>  在当前行上面插入</p>

<h5 id="在第-2-行下面加入一行">在第 2 行下面加入一行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'2a drink tea'</span>
</code></pre></div></div>

<h5 id="在第-2-行上面插入一行">在第 2 行上面插入一行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'2i drink tea'</span>
</code></pre></div></div>

<h5 id="在第-2-行下面加入两行">在第 2 行下面加入两行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="s1">'2a Drink tea or ......\
&gt; drink beer ?\
&gt; holly shit'</span>
</code></pre></div></div>

<p>不同的行需用 <code class="highlighter-rouge">转义符 + 回车</code> 分隔，最后一行的行尾加单引号结束。</p>

<h4 id="查看行">查看行</h4>

<p>查看第 5-7 行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nl</span> /etc/passwd | <span class="nb">sed</span> <span class="nt">-n</span> <span class="s1">'5,7p'</span>
</code></pre></div></div>

<h4 id="混合使用">混合使用</h4>

<h5 id="删除第-4-行替换第-6-行">删除第 4 行，替换第 6 行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /etc/passwd | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'4d'</span> <span class="nt">-e</span> <span class="s1">'6c no six line'</span>
</code></pre></div></div>

<h5 id="删除第-4-行替换第-610-行">删除第 4 行，替换第 6~10 行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /etc/passwd | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'4d'</span> <span class="nt">-e</span> <span class="s1">'6,10c holly shit'</span>
</code></pre></div></div>

<h4 id="直接修改原文件">直接修改原文件</h4>

<p>使用选项 <code class="highlighter-rouge">-i</code> 可以直接修改原文件，慎用。</p>

<h5 id="直接替换文件内容">直接替换文件内容</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/.$/!/g'</span> test.txt
</code></pre></div></div>

<h5 id="在最后一行后面加入一行">在最后一行后面加入一行</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'$a This is a test'</span> test.txt
</code></pre></div></div>

<p><code class="highlighter-rouge">$</code> 表示最后一行</p>

<h2 id="awk">AWK</h2>

<p>本节内容特别感谢 <a href="http://www.zsythink.net/archives/tag/awk">朱双印个人日志</a> ！</p>

<h3 id="简介">简介</h3>

<p>AWK 是一种解释执行的编程语言。它非常强大，被设计用来专门处理文本数据。</p>

<p>awk 其实是一门编程语言，它支持条件判断、数组、循环等功能。所以，我们也可以把 awk 理解成一个脚本语言解释器。</p>

<p>由 GNU/Linux 发布的 AWK 版本通常被称之为 GNU AWK，由自由软件基金（ Free Software Foundation, FSF）负责开发维护的。 目前总共有如下几种不同的 AWK 版本。</p>

<ul>
  <li>
<strong>AWK</strong>——这个版本是 AWK 最原初的版本，它由 AT&amp;T 实验室开发。</li>
  <li>
<strong>NAWK</strong> ——NAWK(New AWK)是 AWK 的改进增强版本。</li>
  <li>
<strong>GAWK</strong>—— GAWK 即 GNU AWK，所有的 GNU/Linux 发行版都包括 GAWK，且 GAWK 完全兼容 AWK 与 NAWK。</li>
</ul>

<p>linux 中常用的是 gawk。</p>

<h4 id="部分-awk-的典型应用场景">部分 AWK 的典型应用场景</h4>

<p>AWK 可以做非常多的工作，下面只是其中的一小部分：</p>

<ul>
  <li>文本处理</li>
  <li>生成格式化的文本报告</li>
  <li>进行算术运算</li>
  <li>字符串操作
…</li>
</ul>

<h3 id="工作流程">工作流程</h3>

<p>AWK 执行的流程：读取、执行、重复。</p>

<p><img src="/assets/images/awk.process.png" alt="image-center" class="align-center"></p>

<p>awk 是逐行处理的，默认把 “换行符” 作为一行结束的标记，默认使用空格作为分割符，把每一行切割成若干个字段。分割符可以由用户指定。</p>

<p>每一 <strong>行</strong> 也叫一个 <strong>记录</strong>，record。</p>

<p>每一行用分隔符切割之后，剩下的部分叫 <strong>字段</strong>，filed。</p>

<h4 id="读取">读取</h4>

<p>AWK 从输入流（文件、管道或者标准输入）中 <strong>读入一行</strong>，将其放入内存中。</p>

<h4 id="执行">执行</h4>

<p>对于每一行输入，所有的 AWK 命令依次执行。</p>

<p>默认情况下，AWK 命令是针对于每一行输入执行的，但是我们可以将其限制在指定的模式中。</p>

<h4 id="重复">重复</h4>

<p>一直重复上述两个过程直到文件结束。</p>

<h3 id="内建变量">内建变量</h3>

<p>awk 的内建变量。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">变量名称</th>
      <th style="text-align: left">意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">NF</td>
      <td style="text-align: left">每行字段的总数</td>
    </tr>
    <tr>
      <td style="text-align: left">NR</td>
      <td style="text-align: left">当前所在的行号</td>
    </tr>
    <tr>
      <td style="text-align: left">FS</td>
      <td style="text-align: left">输入字段之间的分隔符</td>
    </tr>
    <tr>
      <td style="text-align: left">OFS</td>
      <td style="text-align: left">输出字段之间的分隔符</td>
    </tr>
    <tr>
      <td style="text-align: left">RS</td>
      <td style="text-align: left">输入行之间的分隔符</td>
    </tr>
    <tr>
      <td style="text-align: left">ORS</td>
      <td style="text-align: left">输出行之间的分隔符</td>
    </tr>
    <tr>
      <td style="text-align: left">ARGC</td>
      <td style="text-align: left">在命令行提供的参数的个数</td>
    </tr>
    <tr>
      <td style="text-align: left">ARGV</td>
      <td style="text-align: left">存储命令行输入参数的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">ENVIRON</td>
      <td style="text-align: left">与环境变量相关的关联数组变量</td>
    </tr>
    <tr>
      <td style="text-align: left">FILENAME</td>
      <td style="text-align: left">当前文件名</td>
    </tr>
    <tr>
      <td style="text-align: left">$0</td>
      <td style="text-align: left">整个输入行</td>
    </tr>
    <tr>
      <td style="text-align: left">$n</td>
      <td style="text-align: left">当前输入行的第 n 个字段</td>
    </tr>
  </tbody>
</table>

<p>NR, NF 等内置变量要大写，前面不用加 $ 。</p>

<h3 id="语法-2">语法</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awk [options] 'pattern{action}' filenames
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awk [options] '
BEGIN { actions }
/pattern/ { actions }
/pattern/ { actions }
………
END { actions }
' filenames  
</code></pre></div></div>

<p><code class="highlighter-rouge">[options]</code> ：选项</p>

<p><code class="highlighter-rouge">pattern</code> ：模板</p>

<p><code class="highlighter-rouge">actions</code> ：操作</p>

<h4 id="程序的结构">程序的结构</h4>

<h5 id="开始块">开始块</h5>

<p><code class="highlighter-rouge">BEGIN { actions }</code></p>

<p>BEGIN block，为可选部分。是在程序启动时执行的代码，整个过程中只执行一次。通常用于 <strong>初始化变量</strong>。</p>

<p>BEGIN 是 AWK 的关键字，必须大写。</p>

<h5 id="主体块">主体块</h5>

<p><code class="highlighter-rouge">/pattern/ { actions }</code></p>

<p>Body Block，必选部分。</p>

<p>awk 读取的每一行都会执行一次主体块中的命令。</p>

<h5 id="结束块">结束块</h5>

<p><code class="highlighter-rouge">END { actions }</code></p>

<p>END Block，结束块也是可选的。</p>

<p>结束块是在程序结束时执行的代码。END 也是 AWK 的关键字，必须大写。</p>

<h4 id="awk-内部运转流程">AWK 内部运转流程</h4>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="err">每个文件</span><span class="p">:</span>
	<span class="k">for</span> <span class="err">每一行</span><span class="p">:</span>
 		<span class="k">for</span> <span class="err">每一组</span> <span class="p">(</span><span class="err">条件</span><span class="o">/</span><span class="err">模板</span><span class="p">)</span><span class="o">/</span><span class="err">操作</span><span class="p">:</span>
			<span class="k">if</span> <span class="err">存在条件</span><span class="p">:</span>
				<span class="k">if</span> <span class="err">条件为真</span>
			<span class="k">else</span> <span class="k">if</span> <span class="err">存在模板</span><span class="p">:</span>
				<span class="k">if</span> <span class="err">匹配模板</span><span class="p">:</span>
					<span class="k">if</span> <span class="err">存在操作</span><span class="p">:</span>
						<span class="err">执行操作</span>
					<span class="k">else</span><span class="p">:</span>
                  		<span class="nx">print</span> <span class="err">当前行</span>
         	<span class="k">else</span> <span class="p">(</span><span class="err">没有模板</span><span class="p">):</span>
				<span class="err">执行操作</span>
</code></pre></div></div>

<h3 id="选项">选项</h3>

<p>可选。</p>

<h3 id="模板">模板</h3>

<p>可选。</p>

<p class="notice--info">awk 在逐行处理数据流时，会把模板作为 <strong>条件</strong> 来进行检查、判断。</p>

<p>如果没有指定模板，文本流中的每一行都会执行对应的操作；如果指定了模板，则只有与模板匹配的、符合条件的行才会执行对应的操作。</p>

<p>模板可以是：</p>

<h4 id="空">空</h4>

<p>模板可以是空的，即可以被省略，此时意味着 <strong>每个输入行都满足条件</strong>，因此所有行都会被处理。如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $0}'</span> file
</code></pre></div></div>

<h4 id="正则表达式">/正则表达式/</h4>

<p>awk 使用 ERE，扩展正则表达式。</p>

<p>正则表达式必须放在一对斜线中间 <code class="highlighter-rouge">/ /</code>，如果正则表达式中需要使用 <strong>斜线</strong>，需要 <strong>转义</strong>。</p>

<h5 id="正则表达式操作"><code class="highlighter-rouge">'/正则表达式/{操作}'</code></h5>

<p>这样的形式是把 <strong>匹配</strong> 该正则表达式的 <strong>行</strong> 进行对应的操作。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'/^adm/{print $0}'</span> /etc/passwd
</code></pre></div></div>

<p>查找以 adm 开头的行。</p>

<h5 id="正则1正则2操作"><code class="highlighter-rouge">'/正则1/,/正则2/{操作}'</code></h5>

<p>这样的形式是指定一个 <strong>匹配</strong> 的 <strong>行的范围</strong>。正则1指定起始行，正则2指定结束行，针对从起始行开始一直到结束行的所有行进行操作。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'/Lee/,/Kevin/{print $0}'</span> file
</code></pre></div></div>

<h5 id="正则1正则2操作-1"><code class="highlighter-rouge">'(/正则1/)&amp;&amp;(/正则2/){操作}'</code></h5>

<p>如果多个正则表达式需要逻辑运算，可以先用括号包围起来，再使用逻辑运算符。</p>

<p>通过 last 登陆记录统计最近所有用户的登陆次数。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>last | <span class="nb">awk</span> <span class="s1">'BEGIN{print "登陆次数","\t","用户"} \
&gt; ($1 !~ /\(/)&amp;&amp;($1 !~ /reboot/)&amp;&amp;($1 != "") \
&gt; {c[$1]++} END{for(i in c){print c[i],"\t\t",i}}'</span>
登陆次数         用户
66               neo
1                wtmp
5                trinity
10               root
</code></pre></div></div>

<p>其中的正则表达式 <code class="highlighter-rouge">($1 !~ /\(/)&amp;&amp;($1 !~ /reboot/)&amp;&amp;($1 != "")</code> 是为了排除结果中非用户的行。</p>

<h5 id="mn-重复次数">
<code class="highlighter-rouge">{m,n}</code> 重复次数</h5>

<p class="notice">在使用 <code class="highlighter-rouge">{m,n}</code> 来 <strong>匹配</strong> 前一个字母的 <strong>重复次数</strong> 时，必须要指定 <code class="highlighter-rouge">--posix</code> 和 <code class="highlighter-rouge">--re-interval</code> 其中的一个选项。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="nt">--posix</span> <span class="s1">'/go{2,5}gle/{print $0}'</span> file
google
goooogle
</code></pre></div></div>

<h4 id="关系表达式">关系表达式</h4>

<p>使用运算符进行操作，可以是字符串或数字的 <strong>比较测试</strong>。这种模板通过比较测试来定义判断的条件。</p>

<h5 id="awk-支持的关系运算符">awk 支持的关系运算符：</h5>

<table>
  <thead>
    <tr>
      <th>关系运算符</th>
      <th>含义</th>
      <th>用法示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&lt;</td>
      <td>小于</td>
      <td>x &lt; y</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>小于等于</td>
      <td>x &lt;= y</td>
    </tr>
    <tr>
      <td>==</td>
      <td>等于</td>
      <td>x == y</td>
    </tr>
    <tr>
      <td>!=</td>
      <td>不等于</td>
      <td>x != y</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>大于等于</td>
      <td>x &gt;= y</td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td>大于</td>
      <td>x &gt; y</td>
    </tr>
    <tr>
      <td><strong>~</strong></td>
      <td>与对应的正则匹配则为真</td>
      <td>x ~ /正则/</td>
    </tr>
    <tr>
      <td><strong>!~</strong></td>
      <td>与对应的正则不匹配则为真</td>
      <td>x !~ /正则/</td>
    </tr>
  </tbody>
</table>

<h5 id="定位每行字段数等于-5-的行查看第-4-个字段">定位每行字段数等于 5 的行，查看第 4 个字段：</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'NF==5 {print $4}'</span> file
</code></pre></div></div>

<h5 id="查看第-3-行到第-6-行的内容">查看第 3 行到第 6 行的内容：</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'NR&gt;=3 &amp;&amp; NR&lt;=6 {print $0}'</span> file
</code></pre></div></div>

<h5 id="在关系表达式中使用正则">在关系表达式中使用正则：</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="nt">--posix</span> <span class="s1">'$2~/go{1,5}/{print $1,$2}'</span> file
</code></pre></div></div>

<h4 id="begin-块end-块">BEGIN 块，END 块</h4>

<p class="notice--primary">😈 说实在的，这些东西放在 pattern 里，完全没有逻辑可言，毕竟它们算不上条件，无法进行判断，它们更像是 include，所以其实应该属于 “操作”。</p>

<p>BEGIN 块通常用来显示 <strong>表头</strong>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{print "Album","Artist","Title"} {print $1,$3,$5} END{print "aaa","ccc","ddd"}'</span> music
</code></pre></div></div>

<h3 id="操作">操作</h3>

<ul>
  <li>操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开。</li>
  <li>所有操作的最外层必须用大括号 <code class="highlighter-rouge">{ }</code> 引用。</li>
  <li>在操作中使用 <strong>位置变量</strong> 时，<strong>不能用双引号</strong> 引用，即 <code class="highlighter-rouge">"$1"</code>，会被当作普通字符串看待。</li>
</ul>

<p>操作中使用的元素有：</p>

<ul>
  <li>变量或数组 ：<code class="highlighter-rouge">$3</code>、<code class="highlighter-rouge">ant[3]</code>
</li>
  <li>输出命令 ：<code class="highlighter-rouge">print</code>
</li>
  <li>内建函数 ：<code class="highlighter-rouge">split()</code>、<code class="highlighter-rouge">length()</code>
</li>
  <li>控制流语句 ：<code class="highlighter-rouge">if</code>、<code class="highlighter-rouge">while</code>
</li>
</ul>

<h4 id="简单操作">简单操作</h4>

<p>大括号中只有一个命令，如输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $2}'</span> file
</code></pre></div></div>

<h4 id="简单操作的组合">简单操作的组合</h4>

<p>可以把多个命令都放在一对大括号中，用分号 <code class="highlighter-rouge">;</code> 分隔开：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $1; print $3; print $5}'</span> file
</code></pre></div></div>

<p>也可以把每个命令放在单独的一对大括号中，再把所有大括号直接连接在一起：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $1} {print $3} {print $5}'</span> file
</code></pre></div></div>

<h4 id="流控制语句">流控制语句</h4>

<p>通过使用流控制语句，进行基于条件的操作。</p>

<h5 id="if-语句常规结构">
<code class="highlighter-rouge">if</code> 语句常规结构</h5>

<p>在多数编程语言中，如 JS，<code class="highlighter-rouge">if</code> 语句的结构是这样的：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(...)</span>
  <span class="p">{</span>
  <span class="nx">actions</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>将其写到一行：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span> <span class="nx">actions</span> <span class="p">}</span>
</code></pre></div></div>

<h5 id="awk-中的-if-语句结构">AWK 中的 <code class="highlighter-rouge">if</code> 语句结构</h5>

<p>AWK 在操作中沿用了这个格式，因此在操作中使用控制语句是这样的：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{if(...){actions}}'</span> file
</code></pre></div></div>

<p>如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{if(NR==1) {print $1; print $2}}'</span> file
</code></pre></div></div>

<h5 id="ifelse"><code class="highlighter-rouge">if...else...</code></h5>

<p>与 <code class="highlighter-rouge">if</code> 的用法一样，<code class="highlighter-rouge">if...else...</code> 以及 <code class="highlighter-rouge">if...elseif...else</code> 都可以这样使用。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(...) {actions} else {actions}
if(...) {actions} else if(...) {actions} else {actions}
</code></pre></div></div>

<p>如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span> <span class="nb">awk</span> <span class="nt">-F</span>: <span class="s1">'{if($3&lt;1000) {print $1,"系统用户"} else{ print $1,"普通用户"} }'</span> /etc/passwd
root 系统用户
bin 系统用户
neo 普通用户
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>shit
罗大佑:88
崔健:40
窦唯:20

<span class="nv">$ </span><span class="nb">awk</span> <span class="nt">-F</span>: <span class="s1">'BEGIN{print "姓名\t\t年龄"} \
&gt; {if($2&lt;=30) {print $1 "\t\t青年"} \
&gt; else if($2&gt;30 &amp;&amp; $2&lt;50) {print $1 "\t\t中年"} \
&gt; else{print $1 "\t\t老年"}}'</span> shit
姓名            年龄
罗大佑          老年
崔健            中年
窦唯            青年
</code></pre></div></div>

<h5 id="操作中省略--">操作中省略 <code class="highlighter-rouge">{ }</code>
</h5>

<p>如果控制语句中的操作命令只有 <strong>一个</strong>，则可以 <strong>省略</strong> 命令外面的 <strong>大括号</strong>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{if(NR==1) print $2 }'</span> file
</code></pre></div></div>

<h4 id="循环控制语句">循环控制语句</h4>

<p>语法基于以下循环语句的结构：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="err">初始化</span><span class="p">;</span><span class="err"> 布尔表达式</span><span class="p">;</span><span class="err"> 更新</span><span class="p">)</span><span class="err"> </span><span class="p">{</span><span class="nx">actions</span><span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="err">变量 </span><span class="k">in</span><span class="err"> 数组</span><span class="p">)</span><span class="err"> </span><span class="p">{</span><span class="nx">actions</span><span class="p">}</span>
<span class="k">while</span><span class="p">(</span><span class="err"> 布尔表达式 </span><span class="p">)</span><span class="err"> </span><span class="p">{</span><span class="nx">actions</span><span class="p">}</span>
<span class="k">do</span><span class="err"> </span><span class="p">{</span><span class="nx">actions</span><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="err">条件</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="for-循环">
<code class="highlighter-rouge">for</code> 循环</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ for(i=1;i&lt;=6;i++) {print i}}'</span>
1
2
3
4
5
6
</code></pre></div></div>

<h5 id="while-循环">
<code class="highlighter-rouge">while</code> 循环</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="nt">-v</span> <span class="nv">i</span><span class="o">=</span>1 <span class="s1">'BEGIN{while(i&lt;=4){print i;i++}}'</span>
1
2
3
4

<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{i=1;while(i&lt;=4){print i;i++}}'</span>
1
2
3
4
</code></pre></div></div>

<h5 id="do--while-循环">
<code class="highlighter-rouge">do ... while</code> 循环</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{i=1;do{print "test";i++}while(i&lt;1)}'</span>
<span class="nb">test</span>

<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{i=1;do{print "test";i++}while(i&lt;=3)}'</span>
<span class="nb">test
test
test</span>
</code></pre></div></div>

<h5 id="跳出循环">跳出循环</h5>

<p><code class="highlighter-rouge">continue</code> 跳出当前循环，<code class="highlighter-rouge">break</code> 跳出整个循环。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{for(i=0;i&lt;6;i++){if(i==3){continue};print i}}'</span>
0
1
2
4
5

<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{for(i=0;i&lt;6;i++){if(i==3){break};print i}}'</span>
0
1
2
</code></pre></div></div>

<h5 id="退出脚本">退出脚本</h5>

<p>如果使用了 END，<code class="highlighter-rouge">exit</code> 便不是退出 awk，而是直接跳转去执行 END：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{print "start";exit} {print $0} END{print "over"}'</span> file
start
over
</code></pre></div></div>

<p>如果没有使用 END，<code class="highlighter-rouge">exit</code> 导致退出 awk，不再执行其余命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{print 1;exit;print 2;print 3}'</span>
1
</code></pre></div></div>

<h5 id="跳过某行">跳过某行</h5>

<p>使用 <code class="highlighter-rouge">next</code> 命令，让 awk 可以跳过当前行不处理，直接开始处理下一行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>shit
1
2
3

<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{if(NR==2){next};print $0}'</span> shit
1
3
</code></pre></div></div>

<h3 id="分隔符">分隔符</h3>

<p>awk 默认使用空格、制表符做为输入和输出的字段分隔符。</p>

<h4 id="输入字段分隔符">输入字段分隔符</h4>

<p>Field Separator，由内建变量 <code class="highlighter-rouge">FS</code> 表示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"This-is-how-it-works"</span> | <span class="nb">awk</span> <span class="s1">'BEGIN{RS="-"}{print $3}'</span>
how
</code></pre></div></div>

<h4 id="输出字段分隔符">输出字段分隔符</h4>

<p>Output Field Separator，由内建变量 <code class="highlighter-rouge">OFS</code> 表示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"This,is,how,it,works"</span> | <span class="nb">awk</span> <span class="s1">'BEGIN{FS=",";OFS=" _ "}{print $1,$4}'</span>
This _ it
</code></pre></div></div>

<p class="notice--info">如果输出的格式表达式中使用了 <strong>逗号</strong> 来分隔，在输出中对应地会在该位置用 OFS 来分隔。</p>

<h4 id="输入行分隔符">输入行分隔符</h4>

<p>Row Separator，由内建变量 <code class="highlighter-rouge">RS</code> 表示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"This is how it works"</span> | <span class="nb">awk</span> <span class="s1">'BEGIN{RS=" "}{print $0}'</span>
This
is
how
it
works
</code></pre></div></div>

<p>awk 在处理行时，只要遇到空格就换行，导致输出行中每行只有一个单词。</p>

<p>####　输出行分隔符</p>

<p>Output Record Separator，由内建变量 <code class="highlighter-rouge">ORS</code> 表示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">df</span> | <span class="nb">awk</span> <span class="s1">'BEGIN{ORS=" "}{print $5}'</span>
Use% 62% 0% 1% 2% 0% 18% 1% 1% 0%
</code></pre></div></div>

<h3 id="数组">数组</h3>

<p>AWK 中使用的数组，本质上是 <strong>关联数组</strong>，索引不仅可以用 “数字”，还可以用 “任意字符串”。</p>

<h4 id="数组赋值">数组赋值</h4>

<p>数组 <strong>无需声明</strong>，可以直接为数组中的元素赋值：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant[0]="a";ant[1]="b";ant[2]="c"; {print ant[1]} }'</span>
</code></pre></div></div>

<h4 id="判断数组元素是否存在">判断数组元素是否存在</h4>

<p class="notice--success">直接 <strong>引用</strong> 一个数组中 <strong>不存在</strong> 的元素时，awk 会 <strong>自动创建</strong> 这个元素，并且为其赋值为 <strong>空字符串</strong>。称之为引用时创建。</p>

<p>语法：<code class="highlighter-rouge">if(索引 in 数组名)</code> 或 <code class="highlighter-rouge">if(!(索引 in 数组名))</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant[0]="a";ant[1]="b";ant[2]="c"; if(1 in ant) \
&gt; {print ant[1]} }'</span>
b
</code></pre></div></div>

<h4 id="用字符串索引">用字符串索引</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant["lipi"]="aabb";ant["coco"]="3fsd";ant["nike"]="shit";\
&gt; print ant["coco"]}'</span>
3fsd
</code></pre></div></div>

<h4 id="删除数组">删除数组</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant["lipi"]="aabb";ant["coco"]="3fsd";ant["nike"]="shit";\
&gt; print ant["lipi"]; delete ant; print ant["coco"] }'</span>
aabb

</code></pre></div></div>

<h4 id="删除数组元素">删除数组元素</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant["lipi"]="aabb";ant["coco"]="3fsd";ant["nike"]="shit";\
&gt; print ant["lipi"]; delete ant["coco"]; print ant["coco"] }'</span>
aabb

</code></pre></div></div>

<h4 id="输出数组所有元素">输出数组所有元素</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant[1]="aabb";ant[2]="3fsd";ant[3]="shit";for(i=1;i&lt;=3;i++) \
&gt; {print i,ant[i]}; }'</span>
1 aabb
2 3fsd
3 shit
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ ant["lipi"]="aabb";ant["coco"]="3fsd";ant["nike"]="shit";\
&gt; for(i in ant) {print ant[i] }}'</span>
shit
aabb
3fsd
</code></pre></div></div>

<p class="notice"><strong>关联数组</strong> 打印出来的元素是 <strong>无序</strong> 的，因此与赋值时顺序不一样。</p>

<h4 id="范例-2">范例</h4>

<h5 id="范例一">范例一</h5>

<p>利用数组来统计日志文件中每个 IP 地址 <strong>出现的次数</strong>。</p>

<p>假设日志文件的内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>testlog
192.168.1.11
192.168.1.1
192.168.1.8
192.168.1.1
192.168.1.88
192.168.1.10
192.168.1.1
</code></pre></div></div>

<h6 id="知识准备">知识准备</h6>

<p>awk 在使用数组时，有一个有意思的现象可以利用：</p>

<ul>
  <li>先给一个 <strong>变量</strong> a 赋值 <strong>字符串</strong>，如果把该变量做 <strong>自加操作</strong> 的话，初始的变量值，即字符串，会被 <strong>当作数字 0</strong> 参与运算：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ a="test";print a;a=a+1;print a;a++;print a}'</span>
<span class="nb">test
</span>1
2
</code></pre></div></div>

<ul>
  <li>如果变量的初始值为 <strong>空</strong> 的字符串，也会被当作数字 0 来处理，结果一样：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{ a="";print a;a=a+1;print a;a++;print a}'</span>

1
2
</code></pre></div></div>

<h6 id="编程思路">编程思路</h6>

<p>直接引用一个数组中不存在的元素时，awk 会自动创建这个元素，并且为其赋值为 <strong>空字符串</strong>。</p>

<p>把日志中每个不同的 <strong>IP 地址</strong> ，即每个字段做为数组的 <strong>索引</strong>。</p>

<p>同一个字段第一次出现时，该数组元素的索引是 IP 地址；第二次出现，将该数组元素进行 <strong>自加</strong> 一次，值变成数字 0，并加 1；依此类推。</p>

<p>统计完毕时，该地址出现了多少次，该数组元素的值就是多少。</p>

<h6 id="实现思路">实现思路</h6>

<p>因为日志做了简化，每个 <code class="highlighter-rouge">$1</code> 即是 IP 地址。</p>

<p>因为每行数据都要处理，因此不需要模板，可以省略。</p>

<p>在主体程序块中只需一句变量自加的语句即可，<code class="highlighter-rouge">count[$1]++</code>。</p>

<p>在结尾时可以用循环语句把每个 IP 地址出现的次数一一列出，放在 END 即可。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{count[$1]++} END{for(i in count){print i,"\t",count[i]}}'</span> testlog
192.168.1.8      1
192.168.1.10     1
192.168.1.11     1
192.168.1.88     1
192.168.1.1      3
</code></pre></div></div>

<h5 id="范例二">范例二</h5>

<p>上面这个方法非常适合于统计 <strong>字符串出现的次数</strong>，因此如果是字符串，要怎么来统计？</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>testfile
human: water rice meat fruit
monkey: fruit water
goat: water grass
rabbit: water grass fruit
lion: water meat
</code></pre></div></div>

<p>因为数据结构不太一样了，所以我们要重新考虑一下。</p>

<ul>
  <li>鉴于每一行的单词数不一样，我们可能会用到变量 <code class="highlighter-rouge">NF</code>，即每记录的字段总数。</li>
  <li>要想为每个记录的所有字段迭代的话，还需要循环语句。</li>
  <li>同样是把每个单词做为数组的索引</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{for(i=1;i&lt;=NF;i++){count[$i]++}} END{for(j in count){print j,"\t",count[j]}}'</span> testfile
lion:    1
water    5
meat     2
fruit    3
rice     1
human:   1
goat:    1
rabbit:  1
grass    2
monkey:  1
</code></pre></div></div>

<h5 id="范例三">范例三</h5>

<p class="notice--success">数组在 AWK 中使用时，特别适用于处理 <strong>重复的行</strong>，无论这些行是否相邻。</p>

<p>虽然 <code class="highlighter-rouge">uniq</code> 可以去掉相邻的重复行，但对于不相邻的就无能为力了。</p>

<h6 id="过滤重复的行">过滤重复的行</h6>

<p>重复的行只显示一次：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{ if (!a[$0]) print $0; a[$0]++ }'</span>
</code></pre></div></div>

<p>可以 <strong>简写</strong> 为：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'!a[$0]++'</span> file
</code></pre></div></div>

<p>此处省略了操作，因此 AWK 默认会使用 <code class="highlighter-rouge">print</code>。</p>

<h6 id="过滤空行">过滤空行</h6>

<p>不显示空行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'NF'</span> file
</code></pre></div></div>

<h6 id="只显示重复的行">只显示重复的行</h6>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'c[$0]++; c[$0]==2'</span> shit
</code></pre></div></div>

<h3 id="内建函数">内建函数</h3>

<p>AWK 为程序开发者提供了丰富的内建函数。</p>

<h4 id="算术函数">算术函数</h4>

<h5 id="取整函数">取整函数</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{print int(3.14)}'</span>  
3
</code></pre></div></div>

<h5 id="随机数函数">随机数函数</h5>

<p><code class="highlighter-rouge">rand</code> 的功能是随机返回一个 0 到 1 的小数。</p>

<p>但如果单独使用时，一次生成的值是不变的：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{print rand()}'</span>        
0.237788
<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{print rand()}'</span>        
0.237788
</code></pre></div></div>

<p class="notice--success">虽然一次可以生成多个不同随机数，但下一次运行你会发现，生成的还是这些。<code class="highlighter-rouge">rand</code> 每一次都是使用同一个种子开始计算随机数，如此设计是为了便于调试代码，因为每次运行都可以生成同样的随机序列。但是，如果希望每次运行都生成不同的随机序列，需要让 <code class="highlighter-rouge">rand</code> 每次使用不同的种子，可以借助 <code class="highlighter-rouge">srand</code> 来完成。</p>

<h6 id="01-之间的小数">0~1 之间的小数</h6>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{srand();print rand()}'</span>
</code></pre></div></div>

<p>这样就可以确保每次运行该命令时，得到的一定是不同的随机数。</p>

<h6 id="小于-100-的整数">小于 100 的整数</h6>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'BEGIN{srand();print int(100*rand())}'</span>
</code></pre></div></div>

<h4 id="字符串函数">字符串函数</h4>

<h5 id="替换文本">替换文本</h5>

<h6 id="gsub"><code class="highlighter-rouge">gsub</code></h6>

<p><code class="highlighter-rouge">gsub(原字符串, 新字符串, 正文)</code></p>

<p>global substitution，正文中的原字符串，会被 <strong>全部</strong> 替换成新字符串，如果正文省略，则会默认使用 <code class="highlighter-rouge">$0</code>。</p>

<p>把 <code class="highlighter-rouge">l</code> 替换成 <code class="highlighter-rouge">L</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{gsub("l","L",$0);print $0}'</span> <span class="nb">test
</span>HeLLo WorLd <span class="o">!</span>
</code></pre></div></div>

<p>把第一个字段中的小写字母替换成数字 8：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{gsub("[a-z]","8",$1);print $0}'</span> <span class="nb">test
</span>H8888 World <span class="o">!</span>
</code></pre></div></div>

<h6 id="sub"><code class="highlighter-rouge">sub</code></h6>

<p><code class="highlighter-rouge">sub</code> 功能与 <code class="highlighter-rouge">gsub</code> 相似，只不过它只会替换第一个匹配，而非全部。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{gsub("l","L",$0);print $0}'</span> <span class="nb">test
</span>HeLlo World <span class="o">!</span>
</code></pre></div></div>

<h5 id="字符串长度">字符串长度</h5>

<p><code class="highlighter-rouge">length()</code> 用于获取字符串的长度：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>p
Hello World <span class="o">!</span>
What Are You Doing?

<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{for(i=1;i&lt;=NF;i++){print $i,length($i)}}'</span> <span class="nb">test
</span>Hello 5
World 5
<span class="o">!</span> 1
What 4
Are 3
You 3
Doing? 6
</code></pre></div></div>

<p>如果省略传入的参数，则默认把 <code class="highlighter-rouge">$0</code> 做为参数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{print $0,length()}'</span> <span class="nb">test
</span>Hello World <span class="o">!</span> 13
What Are You Doing? 19
</code></pre></div></div>

<h2 id="输入控制">输入控制</h2>

<h3 id="read">READ</h3>

<p>从标准输入中读取一行。</p>

<p><code class="highlighter-rouge">read [ -p ][  -r ][ -s ][ -u[ n ] ] [  VariableName?Prompt ] [ VariableName ... ]</code></p>

<p>read 命令从 <strong>标准输入</strong> 中读取 <strong>一行</strong>，并将输入行的 <strong>每个字段的值</strong> 指定给 <strong>特定变量</strong>，用 IFS（内部字段分隔符）变量中的字符作为 <strong>分隔符</strong>。</p>

<p>read 后面的变量可以有 <strong>一个或多个</strong>，如果输入多个字段，则第一个字段给第一个变量，第二个字段给第二个变量，如果输入字段数量过多，则最后剩下的所有字段都给最后一个变量。</p>

<p>如果没有指定变量名，读取的数据将被自动赋值给特定的变量 <strong>REPLY</strong>。</p>

<h4 id="范例-3">范例</h4>

<p><code class="highlighter-rouge">read 1987name</code></p>

<p>从标准输入读取输入并赋值给变量1987name。</p>

<p><code class="highlighter-rouge">read first last</code></p>

<p>从标准输入读取输入到第一个空格或者回车，将输入的第一个单词放到变量first中，并将该行其他的输入放在变量last中。</p>

<p><code class="highlighter-rouge">read</code></p>

<p>从标准输入读取一行并赋值给特定变量REPLY。</p>

<p><code class="highlighter-rouge">read -a arrayname</code></p>

<p>把单词清单读入arrayname的数组里。</p>

<p><code class="highlighter-rouge">read -p "text"</code></p>

<p>打印提示（text），等待输入，并将输入存储在REPLY中。</p>

<p><code class="highlighter-rouge">read -r line</code></p>

<p>允许输入包含反斜杠。</p>

<p><code class="highlighter-rouge">read -t 3</code></p>

<p>指定读取等待时间为3秒。</p>

<p><code class="highlighter-rouge">read -n 2 var</code></p>

<p>从输入中读取两个字符并存入变量var，不需要按回车读取。</p>

<p><code class="highlighter-rouge">read -d ":" var</code></p>

<p>用定界符“:”结束输入行。</p>

<h2 id="输出控制">输出控制</h2>

<h3 id="块操作">块操作</h3>

<h4 id="tee"><code class="highlighter-rouge">tee</code></h4>

<p>读取标准输入，输出一份到标准输出，一份到文件。</p>

<p>常用于把输入 <strong>另存</strong> 为文件。</p>

<p><img src="10.6.3.tee.png" alt=""></p>

<p><code class="highlighter-rouge">tee -a file</code></p>

<p><code class="highlighter-rouge">-a</code>  追加到文件</p>

<h5 id="范例-4">范例</h5>

<p><code class="highlighter-rouge">last | tee last.list | cut -d " " -f 1</code>	另存一份</p>

<p><code class="highlighter-rouge">ls -l /home | tee -a ~/homefile | less</code>  追加到文件</p>

<h4 id="cat"><code class="highlighter-rouge">cat</code></h4>

<p>把一个或多个文件或标准输入合并在一起，发送给标准输出。</p>

<p><code class="highlighter-rouge">cat [OPTION]... [FILE]...</code></p>

<p><code class="highlighter-rouge">-v</code>	显示不可打印字符</p>

<p><code class="highlighter-rouge">-E</code>	显示行尾符 $</p>

<p><code class="highlighter-rouge">-T</code>	显示 tab 键，用 ^I表示</p>

<p><code class="highlighter-rouge">-A</code>	相当于 -vET</p>

<p><code class="highlighter-rouge">-b</code>	非空行显示行号</p>

<p><code class="highlighter-rouge">-n</code>	所有行显示行号</p>

<h4 id="tac"><code class="highlighter-rouge">tac</code></h4>

<p>功能与 cat 一致，只不过是反向显示，首行变末行。</p>

<p><code class="highlighter-rouge">tac file</code></p>

<h4 id="nl"><code class="highlighter-rouge">nl</code></h4>

<p>把文件内容发送到标准输出，并在每行前面加上行号。</p>

<p><code class="highlighter-rouge">nl [OPTION]... [FILE]...</code></p>

<p><code class="highlighter-rouge">-b</code>	指定行号显示方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	`-ba`	所有行显示行号

	`-bt`	非空行显示行号（默认值）
</code></pre></div></div>

<p><code class="highlighter-rouge">-n</code>	指定行号对齐方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	`-n ln`	左对齐

	`-n rn`	右对齐

	`-n rz`	右对齐，并用0填充空位
</code></pre></div></div>

<p><code class="highlighter-rouge">-w</code>	指定行号占用的字符数</p>

<h4 id="more"><code class="highlighter-rouge">more</code></h4>

<p>以翻页方式查看文件内容。</p>

<p><code class="highlighter-rouge">more file</code></p>

<p>每页的最后一行会显示出当前显示的百分比，还可以在最后一行输入命令：</p>

<p>空格	向下翻一页</p>

<p>回车	向下翻一行</p>

<p>/字符串	向下查找关键字</p>

<p>:f	立刻显示出文件名以及目前显示的行数；</p>

<p>q	立即退出 more</p>

<p>b	往回翻页，对管道不起作用</p>

<h4 id="less"><code class="highlighter-rouge">less</code></h4>

<p><code class="highlighter-rouge">less file</code></p>

<p>可以输入的命令：</p>

<p>空格	向下翻一页；</p>

<p>pagedown	向下翻一页；</p>

<p>pageup	向上翻一页；</p>

<p>/字符串	向下查找</p>

<p>?字符串	向上查找</p>

<p>n	重复查找</p>

<p>N	反向重复查找</p>

<p>g	到第一行</p>

<p>G	到最后一行</p>

<p>q	退出</p>

<h4 id="head"><code class="highlighter-rouge">head</code></h4>

<p>-n	显示的行数，缺省时默认显示 10 行</p>

<p><code class="highlighter-rouge">head -n 6 file</code>	显示前6行</p>

<p><code class="highlighter-rouge">head -n -6 file</code>	去掉后6行，显示剩下的所有</p>

<h4 id="tail"><code class="highlighter-rouge">tail</code></h4>

<p><code class="highlighter-rouge">tail -n 6 file</code>	显示后 6 行</p>

<p><code class="highlighter-rouge">tail -n +10 file</code>	去掉前 10 行，显示剩余的行</p>

<p><code class="highlighter-rouge">tail -f log</code>	持续监测 log 文件，一旦有新内容追加，马上显示出来</p>

<h4 id="od"><code class="highlighter-rouge">od</code></h4>

<p>把输入 <strong>转换</strong> 为 <strong>八进制</strong> 或其它格式，发送到标准输出。</p>

<p>od 命令用指定格式显示由 File 参数指定的文件。如果 File 参数没有给定，od 命令读取标准输入。</p>

<p>在第一个语法格式中，输出格式是由 -t 标志指定。如果没有指定格式类型，-t o2 是缺省值。</p>

<p>在第二个语法格式中，输出格式由标志组合指定。Offset 参数指定了文件中文件输出的开始点。缺省情况下，Offset 参数解释为八进制字节。如果附加了 . 点后缀，参数解释为十进制的；如果参数前导以 x 或 0x 开始，处理为十六进制。 如果 b 后缀添加到参数，解释为块是 512 字节；如果 B 后缀添加到参数上，解释为块是 1024 字节。</p>

<p>Label 参数解释为首字节显示的伪地址。如果使用了该参数，它在 （） 括号中给出，遵循 Offset 参数。相对于 Offset 参数，后缀有同样的意义。</p>

<p>当 od 命令读取标准输入时，Offset 参数和 Label 参数前头必须有个 +（加号）。</p>

<p>环境变量的设置如 LANG 和 LC_ALL 影响着 od 命令的操作。</p>

<p>使用 <strong>类型字符串</strong> 来格式化输出以显示文件：</p>

<p><code class="highlighter-rouge">od [  -v ] [  -A AddressBase ] [  -N Count ] [  -j Skip ] [  -t TypeString ... ] [ File ... ]</code></p>

<p>要使用 <strong>标志</strong> 来格式化输出以显示文件：</p>

<p><code class="highlighter-rouge">od [  -a ] [  -b ] [  -c ] [  -C ] [  -d ] [  -D ] [  -e ] [  -f ] [  -F ] [  -h ] [  -H ] [  -i ] [  -I ] [  -l ] [  -L ] [  -o ] [  -O ] [  -p ] [  -P ] [  -s ] [  -v ] [  -x ] [  -X ] [ [  -S [ N ] ] [  -w [ N ] ] [ File ] [ [ + ] Offset [ . | b | B ] [ + ] Label [ . | b | B ] ] [ File ... ]</code></p>

<p><code class="highlighter-rouge">-t</code>	后面可以接各种类型的输出</p>

<p><code class="highlighter-rouge">a</code>	利用默认的字符来输出</p>

<p><code class="highlighter-rouge">c</code>	使用 ASCII 字符来输出</p>

<p><code class="highlighter-rouge">d[size]</code>	用十进制输出数据，每整数占用的字节数</p>

<p><code class="highlighter-rouge">f[size]</code>	用浮点数值输出数据，每整数占用的字节数</p>

<p><code class="highlighter-rouge">o[size]</code>	用八进制来输出数据，每整数占用的字节数</p>

<p><code class="highlighter-rouge">x[size]</code>	用十六进制输出数据，每整数占用的字节数</p>

<p><strong>范例</strong></p>

<p><code class="highlighter-rouge">od -t c file</code></p>

<p>以 ASCII 方式来查看文件内容</p>

<p><code class="highlighter-rouge">od -t oCc file</code></p>

<p>以 8 进制列出储存值与 ASCII 的对照表</p>

<h4 id="printf"><code class="highlighter-rouge">printf</code></h4>

<p>格式化输出</p>

<p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p>

<p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p>

<p class="notice--info">printf 不是管道命令，无法直接读取标准输入，需要 <strong>把文件内容先读取出来</strong>，作为 printf 的处理对象。而且处理时 <strong>不会自动换行</strong>，必须手动在格式中加入换行符，否则所有内容都显示在一行。</p>

<h5 id="语法-3">语法</h5>

<p><code class="highlighter-rouge">printf FORMAT [ARGUMENT]... </code></p>

<h6 id="format">FORMAT</h6>

<p>FORMAT 格式字符串，用来描述输出的排列方式，需用 <strong>引号</strong> 括起来。</p>

<p>此字符串包含 <code class="highlighter-rouge">按字面显示的字符</code> 以及 <code class="highlighter-rouge">格式替代符</code>。</p>

<p>一般字符按字面显示，转义序列需解释后再输出成对应的字符。</p>

<ul>
  <li>格式替代符</li>
</ul>

<p>格式替代符是特殊的占位符，用来描述如何显示对应的参数。</p>

<p>格式替代符由两部分组成：<code class="highlighter-rouge">%</code> + <code class="highlighter-rouge">指示符</code>。</p>

<p><code class="highlighter-rouge">%s</code> 字符串</p>

<p><code class="highlighter-rouge">%d</code>, <code class="highlighter-rouge">%i</code> 十进制整数</p>

<p><code class="highlighter-rouge">%b</code> 相对应的参数被视为含有要被处理的转义序列字符串</p>

<p><code class="highlighter-rouge">%c</code> ASCII字符。显示相对应参数的第一个字符</p>

<p><code class="highlighter-rouge">%e</code>, <code class="highlighter-rouge">%E</code>, <code class="highlighter-rouge">%f</code> 浮点格式</p>

<p><code class="highlighter-rouge">%g</code> %e 或 %f 转换，看哪一个较短，则删除结尾的零</p>

<p><code class="highlighter-rouge">%G</code> %E 或 %f 转换，看哪一个较短，则删除结尾的零</p>

<p><code class="highlighter-rouge">%o</code> 不带正负号的八进制值</p>

<p><code class="highlighter-rouge">%u</code> 不带正负号的十进制值</p>

<p><code class="highlighter-rouge">%x</code> 不带正负号的十六进制值，使用 a~f 表示 10~15</p>

<p><code class="highlighter-rouge">%X</code> 不带正负号的十六进制值，使用 A~F 表示 10~15</p>

<p><code class="highlighter-rouge">%%</code> 字面意义的 %</p>

<p><code class="highlighter-rouge">%8s</code>  总长 8 位，字符串</p>

<p><code class="highlighter-rouge">%8i</code>  总长 8 位，整数</p>

<p><code class="highlighter-rouge">%8.2f</code>  整数 8 位，小数点后2位</p>

<ul>
  <li>转义序列</li>
</ul>

<p><code class="highlighter-rouge">\a</code>  警告声</p>

<p><code class="highlighter-rouge">\b</code>  回退键</p>

<p><code class="highlighter-rouge">\f</code>  换页</p>

<p><code class="highlighter-rouge">\n</code>  换行</p>

<p><code class="highlighter-rouge">\r</code>  回车</p>

<p><code class="highlighter-rouge">\t</code>  水平制表符</p>

<p><code class="highlighter-rouge">\v</code>  垂直制表符</p>

<p><code class="highlighter-rouge">\xNN</code>  两位数字，查询 ASCII</p>

<h6 id="arguments">arguments</h6>

<p>是与格式替代符相对应的参数列表，如一系列的 <strong>字符串或变量值</strong>。</p>

<h5 id="范例-5">范例</h5>

<ul>
  <li>仅列出姓名与成绩，用 tab 分隔</li>
</ul>

<p><code class="highlighter-rouge">printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat printf.txt)</code></p>

<p><code class="highlighter-rouge">%s</code> 代表一个不固定长度的字串，而字串与字串中间以 <code class="highlighter-rouge">\t </code> 来分隔。</p>

<ul>
  <li>第二行以后，分别以字串、整数、小数点来显示：</li>
</ul>

<p><code class="highlighter-rouge">printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt | grep -v Name)</code></p>

<h5 id="查-ascii-对照">查 ASCII 对照</h5>

<ul>
  <li>16 进制的 45 对应 ASCII 的哪个字符？</li>
</ul>

<p><code class="highlighter-rouge">printf '\x45\n'</code></p>

<p><code class="highlighter-rouge">E</code></p>

<h4 id="wc"><code class="highlighter-rouge">wc</code></h4>

<p><strong>统计</strong> 文件的字符数、行数、单词数。</p>

<p><code class="highlighter-rouge">wc -lwm</code></p>

<p><code class="highlighter-rouge">-l</code>  行数</p>

<p><code class="highlighter-rouge">-w</code>  单词数</p>

<p><code class="highlighter-rouge">-m</code>  字符数</p>

<h5 id="范例-6">范例</h5>

<ul>
  <li>统计字、行、字符数</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/man_db.conf | wc
131   723   5171    # 默认同时列出行数、单词数、字符数
</code></pre></div></div>

<ul>
  <li>分析 last 输出信息，计算登陆系统的总人次</li>
</ul>

<p>last 最后两行并非帐号内容，分别以 reboot 和 wtmp 开头，另外还有一行以(unknown开头的行也是无用行，因此需要去掉这三行及空行。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>last | <span class="nb">grep</span> <span class="o">[</span>a-zA-Z] | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'wtmp'</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'reboot'</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'unknown'</span> |wc <span class="nt">-l</span>
</code></pre></div></div>

<p>先取出非空行，然后去除上述关键字那三行，再计算行数。</p>

<h3 id="行操作">行操作</h3>

<h4 id="sort"><code class="highlighter-rouge">sort</code></h4>

<p>sort 命令用于 <strong>给行排序</strong>，可以按不同的数据型态（如数字或文字）来排序。</p>

<p>排序的字符与 <strong>语系</strong> 的编码有关，因此，排序时建议使用 <strong>LANG=C</strong> 来统一语系。</p>

<p>sort 默认按每行第一个字符，按字母顺序排序。</p>

<p><code class="highlighter-rouge">sort -fbMnrtuk file or STDIN</code></p>

<p><code class="highlighter-rouge">-f</code>  忽略大小写</p>

<p><code class="highlighter-rouge">-b</code>  忽略前置空白字符</p>

<p><code class="highlighter-rouge">-M</code>  根据月份英文名字排序</p>

<p><code class="highlighter-rouge">-n</code>  用纯数字排序</p>

<p><code class="highlighter-rouge">-r</code>  反向排序</p>

<p><code class="highlighter-rouge">-u</code>  相同的数据仅保留一行（去重复）</p>

<p><code class="highlighter-rouge">-t</code>  分隔符，默认用 [tab] 分隔</p>

<p><code class="highlighter-rouge">-k</code>  切割之后，依据第几段排序</p>

<h5 id="范例-7">范例</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/passwd | sort   # 按第一段（帐号）排序
cat /etc/passwd | sort -t ':' -k 3 -n   # 按第三段排序
last | cut -d ' ' -f 1 | sort   # 按第一段排序
last | cut -d ' ' -f 1 | sort -u    # 去掉重复项
</code></pre></div></div>

<h4 id="uniq"><code class="highlighter-rouge">uniq</code></h4>

<p>查找省略 <strong>连续重复</strong> 的行。</p>

<p><code class="highlighter-rouge">uniq -ic</code></p>

<p><code class="highlighter-rouge">-i</code>  忽略大小写</p>

<p><code class="highlighter-rouge">-c</code>  统计重复次数</p>

<h5 id="范例一-1">范例一</h5>

<p>查看登陆次</p>

<table>
  <tbody>
    <tr>
      <td>用 last 列出历史登陆记录</td>
      <td>只保留帐号栏</td>
      <td>去掉 unknown</td>
      <td>去掉 reboot</td>
      <td>排序</td>
      <td>去掉重复项并统计重复次数</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>last | <span class="nb">cut</span> <span class="nt">-d</span> <span class="s1">' '</span> <span class="nt">-f</span> 1 | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'unknown'</span> | <span class="nb">grep</span> <span class="nt">-v</span> <span class="s1">'reboot'</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span>
      1
     66 liloli
      5 neo
     10 root
      1 wtmp
</code></pre></div></div>

<h5 id="范例二-1">范例二</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>shit
human: water rice meat fruit
monkey: fruit water
monkey: fruit water
monkey: fruit water
monkey: fruit water
monkey: fruit water
monkey: fruit water
goat: water grass
monkey: fruit water
rabbit: water grass fruit
lion: water meat


<span class="nv">$ </span><span class="nb">uniq </span>shit <span class="nt">-c</span>
      1 human: water rice meat fruit
      6 monkey: fruit water
      1 goat: water grass
      1 monkey: fruit water
      1 rabbit: water grass fruit
      1 lion: water meat
</code></pre></div></div>

<h4 id="cut"><code class="highlighter-rouge">cut</code></h4>

<p>把文件的每一行 <strong>截取一部分</strong>，发送给标准输出。</p>

<p><code class="highlighter-rouge">cut [options] strings</code></p>

<p><code class="highlighter-rouge">-d</code>  指定分隔符</p>

<p><code class="highlighter-rouge">-f</code>  按段截取，接范围</p>

<p><code class="highlighter-rouge">-c</code>  按列截取，接范围</p>

<p>cut 主要的用途在于 <strong>截取</strong> 文本文件或标准输入中，每一行里的指定 <strong>字符串</strong>。</p>

<p><code class="highlighter-rouge">cut -d '分隔符' -f fields</code></p>

<p>有特定 <strong>分隔符</strong> 的文件，截取 <strong>某几段</strong></p>

<p><code class="highlighter-rouge">cut -c 字符区间</code></p>

<p>用于 <strong>排列整齐</strong> 的文件，截取 <strong>某几列</strong></p>

<h5 id="截取指定段">截取指定段</h5>

<p><code class="highlighter-rouge">echo ${PATH} | cut -d ':' -f 5</code>	 取第5个值</p>

<p><code class="highlighter-rouge">echo ${PATH} | cut -d ':' -f 3,5</code> 	取第3、第5个值</p>

<p><code class="highlighter-rouge">echo ${PATH} | cut -d ':' -f 3-5</code> 	取第3到第5个值</p>

<p><code class="highlighter-rouge">last | cut -d ' ' -f 1</code> 	last 输出的信息只保留用户名</p>

<h5 id="截取指定列">截取指定列</h5>

<p><code class="highlighter-rouge">export | cut -c 12-</code>	截取第 12 列之后的字符</p>

<p><code class="highlighter-rouge">export | cut -c 12-20</code>	截取第 12-20 列的字符</p>

<p><code class="highlighter-rouge">export | cut -c -20 | head -n 6</code>	截取第 20 列之前的字符</p>

<p><code class="highlighter-rouge">export | cut -c 1-5,20,30-35 | head -n 6</code>	截取指定列的字符</p>

<h4 id="join"><code class="highlighter-rouge">join</code></h4>

<p>join 把两个文件的 <strong>相关连的行连接在一起</strong>。</p>

<p>使用 join 之前，应该先把文件内容排序。</p>

<p><code class="highlighter-rouge">join [-ti12] file1 file2</code></p>

<p><code class="highlighter-rouge">-t</code>  分隔符</p>

<p><code class="highlighter-rouge">-i</code>  忽略大小写</p>

<p><code class="highlighter-rouge">-1</code>  第一个文件的关键字段</p>

<p><code class="highlighter-rouge">-2</code>  第二个文件的关键字段</p>

<p>join 默认分隔符为 <strong>空格</strong>，比较 <strong>第一个字段</strong>，如果相同，就把两个文件的这两行数据连接在一起。</p>

<h5 id="范例-8">范例</h5>

<ul>
  <li>把 /etc/passwd 与 /etc/shadow 同一用户的数据整合至一行</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>join -t ':' /etc/passwd /etc/shadow | head -n 3
# 因为两文件关键字段均为第一段，故省略不写 -1,-2
root:x:0:0:root:/root:/bin/bash:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin:\*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin:\*:16372:0:99999:7:::
</code></pre></div></div>

<p>🚩  连接时，第二个文件的第一字段被删除，避免重复。</p>

<ul>
  <li>整合 /etc/passwd 和 /etc/group，关键字为 GID</li>
</ul>

<p>GID 为 /etc/passwd 的第4段，为 /etc/group 的第3段</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>join -t ':' -1 4 /etc/passwd -2 3 /etc/group | head -n 3

0:root:x:0:root:/root:/bin/bash:root:x:
1:bin:x:1:bin:/bin:/sbin/nologin:bin:x:
2:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:
# 连接时，GID 被提到行首，并删除原始位置上的 GID
</code></pre></div></div>

<h4 id="paste"><code class="highlighter-rouge">paste</code></h4>

<p>paste 不检查文件内容，把 <strong>多个文件相同的行合并在一起</strong>，中间用 tab 分隔，输出到标准输出。</p>

<p><code class="highlighter-rouge">paste [-d] file1 file2 ...</code></p>

<p><code class="highlighter-rouge">-d</code>  分隔符，默认为 tab</p>

<p><code class="highlighter-rouge">-</code>  代替 STDIN</p>

<ul>
  <li>拼合 <code class="highlighter-rouge">/etc/passwd</code> 和 <code class="highlighter-rouge">/etc/shadow</code>
</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>paste /etc/passwd /etc/shadow

root:x:0:0:root:/root:/bin/bash root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin bin:\*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:\*:16372:0:99999:7:::
</code></pre></div></div>

<ul>
  <li>输出 /etc/group，然后与上例连在一起，取前三行</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/group | paste /etc/passwd /etc/shadow - | head -n 3
#  - 代表 STDIN ，即 cat /etc/group的输出     ^
</code></pre></div></div>

<h3 id="字符串操作">字符串操作</h3>

<p>这里的工具要么是处理简单的字符串，要么是把整个文件内容做为一个大的字符串，或是一个文本流来一起处理。</p>

<h4 id="tr"><code class="highlighter-rouge">tr</code></h4>

<p>可以对来自标准输入的 <strong>单个字符</strong> 进行 <strong>替换</strong>、<strong>压缩</strong> 和 <strong>删除</strong>。</p>

<h5 id="语法-4">语法</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tr [OPTION] SET1 [SET2]
</code></pre></div></div>

<p>SET1 为查找的对象，SET2 为替换的内容，除普通的 <strong>字符串</strong>，它们还支持 <strong>字符类</strong> 表示，如 <code class="highlighter-rouge">[:lower:]</code>、<code class="highlighter-rouge">[:space:]</code>。</p>

<p class="notice--info">SET1 中的字符串在操作时会按单个字符来查找，如 <code class="highlighter-rouge">'hold'</code> 不会去查找 <code class="highlighter-rouge">hold</code> 这个单词，而是去查找 <code class="highlighter-rouge">h</code>、<code class="highlighter-rouge">o</code>、<code class="highlighter-rouge">l</code>、<code class="highlighter-rouge">d</code> 这些单个的字符，如果是删除就只删除这些单个的字符，如果是替换则只替换成 SET2 中相同位置的单个字符。SET1 <code class="highlighter-rouge">'abc'</code>，SET 2 <code class="highlighter-rouge">'xyz'</code>，则所有字母 <code class="highlighter-rouge">a</code> 被换成 <code class="highlighter-rouge">x</code>，依此类推。</p>

<h6 id="option"><code class="highlighter-rouge">[OPTION]</code></h6>

<p>条件类：</p>

<p><code class="highlighter-rouge">-c</code> 查找对象为 SET1 中各个 <strong>字符的补集</strong>。<code class="highlighter-rouge">-c 'ab\n'</code> 代表除 <code class="highlighter-rouge">a</code>、<code class="highlighter-rouge">b</code>、换行符以外的所有字符。</p>

<p><code class="highlighter-rouge">-t</code> 如果 SET1 的字符数比 SET2 的多，则先把 SET1 切成同样多的，再操作。</p>

<p>操作类：</p>

<p><code class="highlighter-rouge">-d</code>  <strong>删除</strong> SET1，此时会忽略 SET2</p>

<p><code class="highlighter-rouge">-s</code>  把连续重复的字符以单独一个字符表示，<strong>压缩</strong> 成一个</p>

<p>[SET1] 和 [SET2] 代表是用</p>

<h5 id="字符类">字符类</h5>

<p>[:alnum:]：字母和数字</p>

<p>[:alpha:]：字母</p>

<p>[:cntrl:]：控制（非打印）字符</p>

<p>[:digit:]：数字</p>

<p>[:graph:]：图形字符</p>

<p>[:lower:]：小写字母</p>

<p>[:print:]：可打印字符</p>

<p>[:punct:]：标点符号</p>

<p>[:space:]：空白字符</p>

<p>[:upper:]：大写字母</p>

<p>[:xdigit:]：十六进制字符</p>

<h5 id="小写字母-换-大写字母">小写字母 换 大写字母</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>last | <span class="nb">tr</span> <span class="s1">'[a-z]'</span> <span class="s1">'[A-Z]'</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">tr</span> <span class="s1">'[:lower:]'</span> <span class="s1">'[:upper:]'</span>
</code></pre></div></div>

<h5 id="花括号-换-圆括号">花括号 换 圆括号</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">tr</span> <span class="s1">'{}'</span> <span class="s1">'()'</span> &lt; inputfile <span class="o">&gt;</span> outputfile
</code></pre></div></div>

<h5 id="空白字符-换-制表符">空白字符 换 制表符</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"This is for testing"</span> | <span class="nb">tr</span> <span class="o">[</span>:space:] <span class="s1">'\t'</span>
</code></pre></div></div>

<h5 id="压缩连续的空格">压缩连续的空格</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"This   is   for testing"</span> | <span class="nb">tr</span> <span class="nt">-s</span> <span class="o">[</span>:space:] <span class="s1">'\t'</span>
</code></pre></div></div>

<h5 id="删除冒号">删除冒号</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat</span> /etc/passwd | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">':'</span>
</code></pre></div></div>

<h5 id="删除所有数字">删除所有数字</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"my username is 432234"</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="o">[</span>:digit:]
my username is
</code></pre></div></div>

<h5 id="删除所有非数字">删除所有非数字</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"my username is 432234"</span> | <span class="nb">tr</span> <span class="nt">-cd</span> <span class="o">[</span>:digit:]
432234
</code></pre></div></div>

<h4 id="col"><code class="highlighter-rouge">col</code></h4>

<p>col 是一种文本过滤器，它可以过滤来自标准输入或文件的文本。它会尝试 <strong>删除</strong> 文本中的 <strong>RI</strong> （逆向换行符），并把 <strong>空格</strong> 替换 成 <strong>tab</strong> 。</p>

<p><code class="highlighter-rouge">col -xb</code></p>

<p><code class="highlighter-rouge">-x</code>  把 tab 键转换成空格</p>

<ul>
  <li>用 cat -A 显示所有特殊字符，把 tab 换成空格</li>
</ul>

<p><code class="highlighter-rouge">cat -A /etc/man_db.conf</code>  此时会看到很多 ^I 的符号，那就是 tab</p>

<p><code class="highlighter-rouge">cat /etc/man_db.conf | col -x | cat -A | more</code></p>

<h4 id="expand"><code class="highlighter-rouge">expand</code></h4>

<p>expand 用多个空格替换 tab</p>

<p><code class="highlighter-rouge">expand [-t] file</code></p>

<p><code class="highlighter-rouge">-t</code>  替换空格的个数</p>

<p><code class="highlighter-rouge">grep '^MANPATH' /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A</code></p>

<h4 id="unexpand"><code class="highlighter-rouge">unexpand</code></h4>

<p>把空格转换成 tab</p>

<p>用法同 EXPAND。</p>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	</p>
<hr>
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/linux" class="page__taxonomy-item" rel="tag">linux</a><span class="sep">  </span>
    
		
      <a href="/tag/%E6%95%B0%E6%8D%AE%E6%B5%81" class="page__taxonomy-item" rel="tag">数据流</a><span class="sep">  </span>
    
		
      <a href="/tag/%E9%87%8D%E5%AE%9A%E5%90%91" class="page__taxonomy-item" rel="tag">重定向</a><span class="sep">  </span>
    
		
      <a href="/tag/%E6%8E%92%E5%BA%8F" class="page__taxonomy-item" rel="tag">排序</a><span class="sep">  </span>
    
		
      <a href="/tag/%E8%BF%87%E6%BB%A4" class="page__taxonomy-item" rel="tag">过滤</a><span class="sep">  </span>
    
		
      <a href="/tag/%E7%AE%A1%E9%81%93" class="page__taxonomy-item" rel="tag">管道</a><span class="sep">  </span>
    
		
      <a href="/tag/grep" class="page__taxonomy-item" rel="tag">grep</a><span class="sep">  </span>
    
		
      <a href="/tag/sed" class="page__taxonomy-item" rel="tag">sed</a><span class="sep">  </span>
    
		
      <a href="/tag/awk" class="page__taxonomy-item" rel="tag">awk</a>
    
    </span>
  













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://linotes.netlify.com/categories/#tools" class="page__taxonomy-item" rel="tag">tools</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2015-02-01T00:00:00+08:00">February 01, 2015</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="https://linotes.netlify.com/tools/cron/" class="pagination--pager" title="上一页
">Linux 的使用 - 任务计划</a>
    
    
      <a href="https://linotes.netlify.com/tools/filesystem/" class="pagination--pager" title="下一页
">Linux 的使用 - 文件系统</a>
    
  </nav>


    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">相关文章</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/kernel/filedescriptor/" rel="permalink">文件描述符简介
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash03/" rel="permalink">Bash 入门 03
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">循环，变量，函数，捕捉信号
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash02/" rel="permalink">Bash 入门 02
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">正则表达式，SED，AWK，条件结构，交互式脚本
</p>
-->

  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://linotes.netlify.com/programming/bash01/" rel="permalink">Bash 入门 01
</a>
      
    </h2>
    

<!--
    <p class="archive__item-excerpt" itemprop="description">Bash 与 Bash 脚本，脚本的编写与调试，Bash 环境
</p>
-->

  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
    
    
    
    
    <li><a href="https://linotes.netlify.com/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">© 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://linotes.netlify.com/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>








  </body>
</html>
