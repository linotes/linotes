<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Nginx Web Server - LINOTES</title>
<meta name="description" content="用简洁清晰的语言讨论技术">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Nginx Web Server">
<meta property="og:url" content="https://liloli.github.io/server/nginx_webserver/">


  <meta property="og:description" content="用简洁清晰的语言讨论技术">



  <meta property="og:image" content="https://liloli.github.io/assets/images/header/nginx.jpeg">



  <meta name="twitter:site" content="@liloli">
  <meta name="twitter:title" content="Nginx Web Server">
  <meta name="twitter:description" content="用简洁清晰的语言讨论技术">
  <meta name="twitter:url" content="https://liloli.github.io/server/nginx_webserver/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://liloli.github.io/assets/images/header/nginx.jpeg">
  

  



  <meta property="article:published_time" content="2016-01-03T00:00:00+08:00">





  

  


<link rel="canonical" href="https://liloli.github.io/server/nginx_webserver/">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "Hawk Zhang",
      "url": "https://liloli.github.io",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="https://liloli.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://liloli.github.io/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- <link rel="stylesheet" href="/assets/css/vim.css"> -->



  









<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://liloli.github.io/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/app/rsync/" >Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/server/vsftpd/" >Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/kernel/filedescriptor/" >文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/tools/tools.datastream/" >数据流处理</a>
            </li>
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url('https://liloli.github.io/assets/images/header/nginx.jpeg');"
>
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Nginx Web Server

        
      </h1>
      
        <p class="page__lead">
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://liloli.github.io/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:liloli@gmail.com">
            <meta itemprop="email" content="liloli@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Nginx Web Server">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="January 03, 2016">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-copy"></i> Nginx Web Server</h4></header>
              <ul class="toc__menu">
  <li><a href="#提供静态内容">提供静态内容</a>
    <ul>
      <li><a href="#根目录与索引文件">根目录与索引文件</a></li>
      <li><a href="#尝试多个选项">尝试多个选项</a></li>
      <li><a href="#优化服务性能">优化服务性能</a></li>
    </ul>
  </li>
  <li><a href="#nginx-反向代理">nginx 反向代理</a>
    <ul>
      <li><a href="#把请求传递给代理服务器">把请求传递给代理服务器</a></li>
      <li><a href="#传递请求标头">传递请求标头</a></li>
      <li><a href="#缓冲区的配置">缓冲区的配置</a></li>
      <li><a href="#选择出站的-ip-地址">选择出站的 IP 地址</a></li>
    </ul>
  </li>
  <li><a href="#压缩与解压缩">压缩与解压缩</a>
    <ul>
      <li><a href="#启用压缩">启用压缩</a></li>
      <li><a href="#启用解压缩">启用解压缩</a></li>
      <li><a href="#发送压缩文件">发送压缩文件</a></li>
    </ul>
  </li>
  <li><a href="#把-nginx-作为应用程序网关">把 nginx 作为应用程序网关</a>
    <ul>
      <li><a href="#关于-uwsgi-和-django">关于 uWSGI 和 Django</a></li>
      <li><a href="#配置-nginx与-uwsgi-和-django-配合使用">配置 nginx，与 uWSGI 和 Django 配合使用</a></li>
      <li><a href="#小结">小结</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <h2 id="提供静态内容">提供静态内容</h2>

<h3 id="根目录与索引文件">根目录与索引文件</h3>

<h4 id="根目录">根目录</h4>

<p>使用 <code class="highlighter-rouge">root</code> 指令来设定根目录，web 服务会从中查找需要服务的文件。为了获取某个请求的文件路径，nginx 会把请求 URI 追加到 <code class="highlighter-rouge">root</code> 设定的路径后面。这个指令可以放在 <code class="highlighter-rouge">http {}</code>、<code class="highlighter-rouge">server {}</code> 或 <code class="highlighter-rouge">location {}</code> 中的任何层级。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="n">root</span> /<span class="n">www</span>/<span class="n">data</span>;

    <span class="n">location</span> / {
    }

    <span class="n">location</span> /<span class="n">images</span>/ {
    }

    <span class="n">location</span> ~ \.(<span class="n">mp3</span>|<span class="n">mp4</span>) {
        <span class="n">root</span> /<span class="n">www</span>/<span class="n">media</span>;
    }
}
</code></pre></div></div>

<p>本例中，<code class="highlighter-rouge">root</code> 指令为一个虚拟服务器指定根目录，应用于所有的 location 块。</p>

<p>对于以 <code class="highlighter-rouge">/images/</code> 开头的 URI，nginx 会在文件系统的 <code class="highlighter-rouge">/www/data/images/</code> 目录中查找对应的文件。</p>

<p>而对于以 <code class="highlighter-rouge">.mp3</code> 或 <code class="highlighter-rouge">.mp4</code> 结尾的 URI 来说，nginx 会从 <code class="highlighter-rouge">/www/media/</code> 目录中查找。</p>

<h4 id="索引文件">索引文件</h4>

<p>如果请求以斜线结尾，nginx 认为请求的是一个目录，它会在该目录中查找索引文件。<code class="highlighter-rouge">index</code> 指令用于设定索引文件的文件名，默认值为 <code class="highlighter-rouge">index.html</code>。</p>

<p>在 <code class="highlighter-rouge">index</code> 指令中可以设定多个文件名，nginx 会按设定的顺序来查找：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> / {
    <span class="n">index</span> <span class="n">index</span>.$<span class="n">geo</span>.<span class="n">html</span> <span class="n">index</span>.<span class="n">htm</span> <span class="n">index</span>.<span class="n">html</span>;
}
</code></pre></div></div>

<p>此处使用的  <code class="highlighter-rouge">$geo</code> 变量是个自定义变量，由 <code class="highlighter-rouge">geo</code> 指令所设定，该变量值取决于客户端的 IP 地址。</p>

<p>为了返回索引文件，nginx 会检查其是否存在，然后进行内部重定向。把索引文件名追加到 URI 后面，形成新的 URI，就重定向到这个新 URI。内部的这个重定向会引发一个新的 location 的查找，有可能结果会落到另一个 location 上：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> / {
    <span class="n">root</span> /<span class="n">data</span>;
    <span class="n">index</span> <span class="n">index</span>.<span class="n">html</span> <span class="n">index</span>.<span class="n">php</span>;
}

<span class="n">location</span> ~ \.<span class="n">php</span> {
    <span class="n">fastcgi_pass</span> <span class="n">localhost</span>:<span class="m">8000</span>;
    <span class="c">#...
</span>}
</code></pre></div></div>

<p>本例中，如果请求中的 URI 是 <code class="highlighter-rouge">/path/</code>，而且 <code class="highlighter-rouge">/data/path/index.html</code> 不存在，但 <code class="highlighter-rouge">/data/path/index.php</code> 存在，则内部重定向 <code class="highlighter-rouge">/path/index.php</code> 会映射给第二个 location，于是，请求就被代理了。</p>

<h5 id="文件不存在的处理">文件不存在的处理</h5>

<p>继续上面的范例，如果请求的 URI 为 <code class="highlighter-rouge">/images/some/path/</code>，nginx 会把 <code class="highlighter-rouge">/www/data/images/some/path/index.html</code> 交出去，如果存在的话。如果不存在，默认会返回 HTTP 404 代码，代表无法找到文件。</p>

<p>可以配置 nginx，让其在找不到文件的情况下，不返回 404，而是返回一个自动生成的文件列表。通过在 <code class="highlighter-rouge">autoindex</code> 指令中使用 <code class="highlighter-rouge">on</code> 参数来实现：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">images</span>/ {
    <span class="n">autoindex</span> <span class="n">on</span>;
}
</code></pre></div></div>

<h3 id="尝试多个选项">尝试多个选项</h3>

<p><code class="highlighter-rouge">try_files</code> 指令可用于检查特定的文件或目录是否存在。</p>

<p>该指令可以指定多个文件名，检查也是依给定的次序进行的，使用最先找到的文件来处理请求。</p>

<p>如果存在，nginx 会进行一个内部重定向，如果不存在，则会重定向到一个默认的文件或返回特定的状态码。</p>

<h4 id="重定向到默认文件">重定向到默认文件</h4>

<p>例如，若要检查匹配请求 URI 的文件是否存在，可以使用 <code class="highlighter-rouge">try_files</code> 指令和 <code class="highlighter-rouge">$uri</code> 变量：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="n">root</span> /<span class="n">www</span>/<span class="n">data</span>;

    <span class="n">location</span> /<span class="n">images</span>/ {
        <span class="n">try_files</span> $<span class="n">uri</span> /<span class="n">images</span>/<span class="n">default</span>.<span class="n">gif</span>;
    }
}
</code></pre></div></div>

<p>文件是以 URI 的形式指定的，而 URI 由当前的 location 或虚拟服务器中的 <code class="highlighter-rouge">root</code> 或 <code class="highlighter-rouge">alias</code> 指令指定的。本例中，如果与源 URI 对应的文件不存在（<code class="highlighter-rouge">$uri</code> 的作用），nginx 会进行一个内部的重定向，即定向到 <code class="highlighter-rouge">try_files</code> 的 <strong>最后一个参数</strong>，因此，返回的是 <code class="highlighter-rouge">/www/data/images/default.gif</code></p>

<h4 id="返回状态码">返回状态码</h4>

<p>最后一个参数也可以是一个状态码，可以直接用等号加状态码来表示，也可以是某个 location 的名称：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> / {
    <span class="n">try_files</span> $<span class="n">uri</span> $<span class="n">uri</span>/ $<span class="n">uri</span>.<span class="n">html</span> =<span class="m">404</span>;
}
</code></pre></div></div>

<p>上例中，如果 <code class="highlighter-rouge">try_files</code> 的所有参数都无法解析为一个现存的文件或目录，则返回 404 错误。</p>

<h4 id="重定向到其他-location">重定向到其他 location</h4>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> / {
    <span class="n">try_files</span> $<span class="n">uri</span> $<span class="n">uri</span>/ @<span class="n">backend</span>;
}

<span class="n">location</span> @<span class="n">backend</span> {
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">backend</span>.<span class="n">example</span>.<span class="n">com</span>;
}
</code></pre></div></div>

<p>上例中，如果源 URI 和在其后面追加斜线都无法解析到现有文件或目录，请求会被重定向到名为 <code class="highlighter-rouge">@backend</code> 的 location 中，它会把请求传递给一个代理服务器。</p>

<h3 id="优化服务性能">优化服务性能</h3>

<p>无论提供什么内容，加载的速度都是关键因素。对配置文件进行一点优化会显著提升其工作效率，性能也得到提升。</p>

<h4 id="启用-sendfile">启用 <code class="highlighter-rouge">sendfile</code></h4>

<p>nginx 默认自己处理文件传输，发送前，它会把文件复制到缓冲区中。启用 <code class="highlighter-rouge">sendfile</code> 指令会停用把数据复制到缓冲区这一步，可以实现从一个文件描述符直接向另一个描述符复制数据。</p>

<p>另外，为了防止一个快速连接完全占据工人进程，可以使用 <code class="highlighter-rouge">sendfile_max_chunk</code> 指令，以限制每个 <code class="highlighter-rouge">sendfile()</code> 调用可以传输的数据量。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">mp3</span> {
    <span class="n">sendfile</span>           <span class="n">on</span>;
    <span class="n">sendfile_max_chunk</span> <span class="m">1</span><span class="n">m</span>;
    <span class="c">#... 此处限制为 1 MB
</span>}
</code></pre></div></div>

<h4 id="启用-tcp_nopush">启用 <code class="highlighter-rouge">tcp_nopush</code></h4>

<p>与 <code class="highlighter-rouge">sendfile on;</code> 一起，使用 <code class="highlighter-rouge">tcp_nopush</code> 指令，可以让 nginx 在 <code class="highlighter-rouge">sendfile()</code> 获取的数据块后面，使用同一个数据包，来发送 HTTP 响应标头。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">mp3</span> {
    <span class="n">sendfile</span>   <span class="n">on</span>;
    <span class="n">tcp_nopush</span> <span class="n">on</span>;
    <span class="c">#...
</span>}
</code></pre></div></div>

<h4 id="启用-tcp_nodelay">启用 <code class="highlighter-rouge">tcp_nodelay</code></h4>

<p>使用 <code class="highlighter-rouge">tcp_nodelay</code> 指令可以覆盖 Nagle 算法，该算法最初是为了解决在较慢的网络中的小数据包的问题。该算法会把一定数量的小数据包合并为一个大数据包，然后用 200 ms 的延迟发送该数据包。而现今，在提供大型静态文件时，可以忽略数据包的大小，立即发送数据。延迟也会影响在线的程序，如 ssh、在线游戏、在线交易等。<code class="highlighter-rouge">tcp_nodelay</code> 指令默认被设置为 <code class="highlighter-rouge">on</code>，表示禁用 Nagle 算法。</p>

<blockquote>
  <p>Nagle 算法 ：用于自动连接许多的小缓冲器消息；这一过程称为 nagling，通过减少必须发送包的个数来增加网络软件系统的效率。</p>
</blockquote>

<p>只为保活（keepalive）连接使用该指令：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">mp3</span>  {
    <span class="n">tcp_nodelay</span>       <span class="n">on</span>;
    <span class="n">keepalive_timeout</span> <span class="m">65</span>;
    <span class="c">#...
</span>}
</code></pre></div></div>

<h4 id="优化积压队列">优化积压队列</h4>

<p>nginx 能以多快的速度处理传入连接，这是很重要的一个因素。通常的规则是，建立好一个连接以后，会把该连接置于某个侦听套接字的侦听列队中。在普通的负载下，要么队列会比较小，要么可能根本就没有队列。但在高负载的情况下，队列会增长的特别快，会导致性能参差不齐、连接断开以及延迟增加。</p>

<p>要想查看当前侦听的队列，可运行以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat <span class="nt">-tnlpa</span>
</code></pre></div></div>

<p>网站在经历较大的流量时，要想获得最佳性能，往往需要提升队列中可接受的最大连接数，在操作系统中和 nginx 中都需要进行配置。</p>

<h5 id="修改操作系统对应参数">修改操作系统对应参数</h5>

<p>把内核参数 <code class="highlighter-rouge">net.core.somaxconn</code> 的值从默认的 128 调整到足够高的值，来应对流量井喷。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.somaxconn<span class="o">=</span>4096
</code></pre></div></div>

<p>然后用文本编辑器在 <code class="highlighter-rouge">/etc/sysctl.conf</code> 中添加一行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net.core.somaxconn <span class="o">=</span> 4096
</code></pre></div></div>

<h5 id="修改-nginx-的配置">修改 nginx 的配置</h5>

<p>如果把内核参数 <code class="highlighter-rouge">somaxconn</code> 调整到 512 以上，需要在 <code class="highlighter-rouge">listen</code> 指令中修改 <code class="highlighter-rouge">backlog</code> 参数与其对应：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="n">listen</span> <span class="m">80</span> <span class="n">backlog</span>=<span class="m">4096</span>;
    <span class="c"># ...
</span>}
</code></pre></div></div>

<h2 id="nginx-反向代理">nginx 反向代理</h2>

<p>通常使用代理在几台服务器之间分配负载，或是无缝显示来自不同网站的内容，再或是把请求通过 HTTP 以外的协议，传递给应用程序服务器。</p>

<h3 id="把请求传递给代理服务器">把请求传递给代理服务器</h3>

<p>在 nginx 代理一个请求时，它会把请求发送给一个专门的代理服务器，取得响应，然后将其转给客户端。可以把请求发给一个 HTTP 服务器，可以是另一个 nginx 或其他服务器；也可以用特定协议发给非 HTTP 服务器，运行的可以是 PHP 或 Python 编写的程序。支持的其他协议包括 FastCGI、uwsgi、SCGI、memcached。</p>

<p>####　传给 HTTP 代理服务器</p>

<p>要想把请求传递给 HTTP 代理服务器，需要在 <code class="highlighter-rouge">location</code> 中配置 <code class="highlighter-rouge">proxy_pass</code> 指令：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">some</span>/<span class="n">path</span>/ {
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>/<span class="n">link</span>/;
}
</code></pre></div></div>

<p>注意，此处设定的代理服务器的地址后面跟了一段 URI，即 <code class="highlighter-rouge">/link/</code>。像这种情况，如果在网址后面跟了一个 URI，它会用来 <strong>替换</strong> 掉请求中的 URI。因此，如果请求中的 URI 为 <code class="highlighter-rouge">/some/path/page.html</code>，它会被代理为 <code class="highlighter-rouge">http://www.example.com/link/page.html</code>。如果设定地址时后面没有跟 URI，或无法确定要替换哪部分 URI，则会使用完整的请求 URI。</p>

<p>也可以指定 IP 地址和端口：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> ~ \.<span class="n">php</span> {
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">8000</span>;
}
</code></pre></div></div>

<h4 id="传给非-http-代理服务器">传给非 HTTP 代理服务器</h4>

<p>要想把请求传给非 HTTP 代理服务器，要使用正确的 <code class="highlighter-rouge">**_pass</code> 指令：</p>

<p><code class="highlighter-rouge">fastcgi_pass</code> ：把请求传给 FastCGI 服务器</p>

<p><code class="highlighter-rouge">uwsgi_pass</code> ：把请求传给 uwsgi 服务器</p>

<p><code class="highlighter-rouge">scgi_pass</code> ：把请求传给 SCGI 服务器</p>

<p><code class="highlighter-rouge">memcached_pass</code> ：把请求传给 memcached 服务器</p>

<p>注意，在这类情况下，用来指定地址的规则不太一样。</p>

<p>…</p>

<p><code class="highlighter-rouge">proxy_pass</code> 指令也可指向一组命名的服务器，此时会根据指定的方法，把请求在组中的服务器之间分配。</p>

<h3 id="传递请求标头">传递请求标头</h3>

<p>nginx 默认会 <strong>重新定义</strong> 被代理的请求中的两个标头字段，即 <code class="highlighter-rouge">Host</code> 和 <code class="highlighter-rouge">Connection</code>，并删除空的标头字段。</p>

<p><code class="highlighter-rouge">Host</code> 被设置为 <code class="highlighter-rouge">$proxy_host</code> 变量，<code class="highlighter-rouge">Connection</code> 被设置为 <code class="highlighter-rouge">close</code>。</p>

<p>对标头的修改要使用 <code class="highlighter-rouge">proxy_set_header</code> 指令来完成，该指令可以用在 <code class="highlighter-rouge">location</code> 或更高的层级。也可以在特定的 <code class="highlighter-rouge">server</code> 或 <code class="highlighter-rouge">http</code> 块中使用。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">some</span>/<span class="n">path</span>/ {
    <span class="n">proxy_set_header</span> <span class="n">Host</span> $<span class="n">host</span>;
    <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span> $<span class="n">remote_addr</span>;
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">localhost</span>:<span class="m">8000</span>;
}
</code></pre></div></div>

<p>这里，<code class="highlighter-rouge">Host</code> 字段被设置为 <code class="highlighter-rouge">$host</code> 变量。</p>

<p>如果希望某些字段不要传递给代理服务器，可以将其赋个空值：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">some</span>/<span class="n">path</span>/ {
    <span class="n">proxy_set_header</span> <span class="n">Accept</span>-<span class="n">Encoding</span> <span class="s2">""</span>;
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">localhost</span>:<span class="m">8000</span>;
}
</code></pre></div></div>

<h3 id="缓冲区的配置">缓冲区的配置</h3>

<p>nginx 默认会把来自代理服务器的响应放到缓冲区。响应先是保存在内部的缓冲区中，直到响应全部接收完毕才发给客户端。缓冲区的使用有助于优化对慢客户端的性能。因为，如果把响应同步地从 nginx 发给客户端，会浪费代理服务器的时间。而使用了缓冲区以后，nginx 允许代理服务器快速地处理响应，由 nginx 来保存这个响应，客户端下载需要多长时间，它就可以保管多久。</p>

<h4 id="启用缓冲区">启用缓冲区</h4>

<p>负责启用、禁用缓冲区的指令是 <code class="highlighter-rouge">proxy_buffering</code>，默认设置为 <code class="highlighter-rouge">on</code>，启用缓冲区。</p>

<p><code class="highlighter-rouge">proxy_buffers</code> 指令可控制为一个请求所分配的缓冲区的大小和数量。代理服务器返回的响应，其第一部分被保存在一个单独的缓冲区，大小由 <code class="highlighter-rouge">proxy_buffer_size</code> 设定。这一部分通常包含一个相对较小的响应标头，可以做的比响应的其余部分的标头更小。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">some</span>/<span class="n">path</span>/ {
    <span class="n">proxy_buffers</span> <span class="m">16</span> <span class="m">4</span><span class="n">k</span>;
    <span class="n">proxy_buffer_size</span> <span class="m">2</span><span class="n">k</span>;
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">localhost</span>:<span class="m">8000</span>;
}
</code></pre></div></div>

<p>本例中，缓冲区的默认数量被提升，用于响应的第一部分的缓冲区也比默认的要小。</p>

<p>如果缓冲区被禁用，nginx 从代理服务器接收到的响应会同步地发送给客户端，这样的举动是那些快速的互动客户端所需要的。</p>

<h4 id="禁用缓冲区">禁用缓冲区</h4>

<p>要想在特定的位置禁用缓冲区，可以在对应的 <code class="highlighter-rouge">location</code> 中加入 <code class="highlighter-rouge">proxy_buffering off;</code>：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">some</span>/<span class="n">path</span>/ {
    <span class="n">proxy_buffering</span> <span class="n">off</span>;
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">localhost</span>:<span class="m">8000</span>;
}
</code></pre></div></div>

<p>本例中，nginx 只会使用由 <code class="highlighter-rouge">proxy_buffer_size</code> 配置的缓冲区来保存响应的当前部分。</p>

<p>…</p>

<p>反向代理通常用于负载均衡。</p>

<h3 id="选择出站的-ip-地址">选择出站的 IP 地址</h3>

<p>如果代理服务器有多个网络接口，有时需要选择一个源 IP 地址，用来连接到代理服务器或后端服务器。在代理服务器配置为只接受来自特定 IP 网络或地址范围的连接时，这一点就更加有用。</p>

<p>用特定网络接口的 IP  地址来配置 <code class="highlighter-rouge">proxy_bind</code> 指令：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">app1</span>/ {
    <span class="n">proxy_bind</span> <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>;
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">example</span>.<span class="n">com</span>/<span class="n">app1</span>/;
}

<span class="n">location</span> /<span class="n">app2</span>/ {
    <span class="n">proxy_bind</span> <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">2</span>;
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">example</span>.<span class="n">com</span>/<span class="n">app2</span>/;
}
</code></pre></div></div>

<p>IP 地址也可以用变量来表示，如 <code class="highlighter-rouge">$server_addr</code> 变量会把接受请求的网络接口的 IP 地址传给 nginx。</p>

<h2 id="压缩与解压缩">压缩与解压缩</h2>

<p>对响应进行压缩通常会明显地减小要传输的数据的大小，然而，因为压缩是发生在运行时，它也会增加一些处理的开销，对性能会有影响。nginx 会在给客户端发送响应之前进行压缩，会对已经压缩的请求（有可能是代理服务器压缩的）不会二次压缩。</p>

<h3 id="启用压缩">启用压缩</h3>

<p>要想启用压缩，需要使用 <code class="highlighter-rouge">gzip</code> 指令，并配置 <code class="highlighter-rouge">on</code> 参数。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gzip</span> <span class="n">on</span>;
</code></pre></div></div>

<h4 id="对其他-mime-类型启用压缩">对其他 MIME 类型启用压缩</h4>

<p>nginx 默认只会压缩 MIME 类型的 text/html。要想压缩其它 MIME 类型的响应，要用 <code class="highlighter-rouge">gzip_types</code> 来指定：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gzip_types</span> <span class="n">text</span>/<span class="n">plain</span> <span class="n">application</span>/<span class="n">xml</span>;
</code></pre></div></div>

<h4 id="响应的最小长度">响应的最小长度</h4>

<p>要想设定需要压缩的响应的最小长度，使用 <code class="highlighter-rouge">gzip_min_length</code> 指令，其默认值为 20 字节，这里调整为 1000：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gzip_min_length</span> <span class="m">1000</span>;
</code></pre></div></div>

<h4 id="压缩被代理的请求">压缩被代理的请求</h4>

<p>nginx 默认不会压缩来自代理服务器的请求，一个请求是否来自代理服务器，是根据请求中的 <code class="highlighter-rouge">Via</code> 标头字段判断的。要想配置对这些请求的压缩，需要使用 <code class="highlighter-rouge">gzip_proxied</code> 指令。该指令有多个参数，用来指定 nginx 要为哪些类型的被代理的请求进行压缩。</p>

<p>例如：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gzip_proxied</span> <span class="n">no</span>-<span class="n">cache</span> <span class="n">no</span>-<span class="n">store</span> <span class="n">private</span> <span class="n">expired</span> <span class="n">auth</span>;
</code></pre></div></div>

<p>只有那些 <strong>不会被缓存到代理服务器的请求</strong>，它们得到的响应才应该被压缩。基于这个宗旨，<code class="highlighter-rouge">gzip_proxied</code> 指令所指定的参数会让 nginx 检查响应中的 <code class="highlighter-rouge">Cache-Control</code> 标头字段，如果字段的值为 <code class="highlighter-rouge">no-cache</code>、<code class="highlighter-rouge">no-store</code>、<code class="highlighter-rouge">private</code>，就会压缩响应。</p>

<p>另外，必须加上 <code class="highlighter-rouge">expired</code> 参数，为的是检查 <code class="highlighter-rouge">Expires</code> 标头字段的值。还可以加上 <code class="highlighter-rouge">auth</code> 参数，用于检查是否含有 <code class="highlighter-rouge">Authorization</code> 标头字段。被授权的响应是专门为终端用户准备的，通常不会被缓存。</p>

<p>与其它指令一样，用于配置压缩的这些指令同样可以用于 <code class="highlighter-rouge">http</code>、<code class="highlighter-rouge">server</code>、<code class="highlighter-rouge">location</code> 中。</p>

<p>常见的 gzip 压缩配置如下：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="n">gzip</span> <span class="n">on</span>;
    <span class="n">gzip_types</span>      <span class="n">text</span>/<span class="n">plain</span> <span class="n">application</span>/<span class="n">xml</span>;
    <span class="n">gzip_proxied</span>    <span class="n">no</span>-<span class="n">cache</span> <span class="n">no</span>-<span class="n">store</span> <span class="n">private</span> <span class="n">expired</span> <span class="n">auth</span>;
    <span class="n">gzip_min_length</span> <span class="m">1000</span>;
    ...
}
</code></pre></div></div>

<h3 id="启用解压缩">启用解压缩</h3>

<p>有些客户端不支持 <code class="highlighter-rouge">gzip</code> 编码的响应，而同时，人们希望保存压缩的数据，或实时把响应压缩再将其保存到缓存中。要想同时也满足不支持压缩的客户端，在发送给客户端时，nginx 可以实时解压缩。</p>

<p>要想启用实时解压缩，需要使用 <code class="highlighter-rouge">gunzip</code> 指令：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> /<span class="n">storage</span>/ {
    <span class="n">gunzip</span> <span class="n">on</span>;
    ...
}
</code></pre></div></div>

<p><code class="highlighter-rouge">gunzip</code> 指令可以与 <code class="highlighter-rouge">gzip</code> 在同一个 context 中使用：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="n">gzip</span> <span class="n">on</span>;
    <span class="n">gzip_min_length</span> <span class="m">1000</span>;
    <span class="n">gunzip</span> <span class="n">on</span>;
    ...
}
</code></pre></div></div>

<p>注意，该指令是在一个单独的模块中定义的，有可能不会默认安装。</p>

<h3 id="发送压缩文件">发送压缩文件</h3>

<p>要想把压缩后的文件发给客户端，而不是发原文件，需要在适当的 context 中使用 <code class="highlighter-rouge">gzip_static</code> 指令，配置 <code class="highlighter-rouge">on</code> 参数。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">location</span> / {
    <span class="n">gzip_static</span> <span class="n">on</span>;
}
</code></pre></div></div>

<p>本例中，针对指向 <code class="highlighter-rouge">/path/to/file</code> 的请求，nginx 会尝试并发送文件  <code class="highlighter-rouge">/path/to/file.gz</code>，如果文件不存在，或客户端不支持 gzip，nginx 会发送未经压缩的原文件。</p>

<p>注意，<code class="highlighter-rouge">gzip_static</code> 指令不会启用实时压缩，它仅仅是使用一个事先被压缩好的文件。要想在运行时压缩内容，必须使用 <code class="highlighter-rouge">gzip</code> 指令。</p>

<p>该指令是在一个单独的模块中定义的，有可能不会默认安装。</p>

<h2 id="把-nginx-作为应用程序网关">把 nginx 作为应用程序网关</h2>

<p>nginx 是一个高性能、可扩展、安全的、可靠的 WEB 服务器和反向代理。nginx 使用所有的重要的 WEB 加速技术来管理 HTTP 连接和流量。多年来，nginx 的多种能力，如 负载均衡、SSL 代理、连接与请求策略、静态内容、内容缓存等功能，可以快速、高效地帮助用户建立可靠、快速的网站。</p>

<p>nginx 还可以充当安全的应用程序网关，它提供一定数量的专用内建接口，把流量从用户传递给应用程序。就这一点而言，nginx 不仅可以把 HTTP、HTTPS 的流量代理给一个启用 HTTP 的应用程序容器，它还可以与大多数流行的轻量应用程序服务器和 WEB 架构直接对话。这种对话是借助优化的应用程序实现的，即像 FastCGI、Memcached、scgi、uwsgi 这样的模块所带来的网关接口。</p>

<p>大多数常用的应用程序容器都嵌入了对外 HTTP 接口，并附带一些路由功能，但把 nginx 作为应用程序网关的一个重要原因，是它提供了一体化的解决方案：HTTP 连接管理，负载均衡、内容缓存、流量安全。应用程序的后端安全地呆在 nginx 的后方，以实现更好的扩展性和性能。在 nginx 后面群集应用程序实例，也很容易构建高可用的应用程序。</p>

<h3 id="关于-uwsgi-和-django">关于 uWSGI 和 Django</h3>

<p>关于专用的接口：因为 HTTP 非常有用，它从来没有为现代、轻量的应用程序的部署优化过。近几年来，逐步形成了一些标准化的接口，用于配合各种应用程序架构和容器。其中一个接口是 Web Server Gateway Interface，WSGI，网页服务网关接口，处于 WEB 服务器和基于 Python 的应用程序之间的接口。</p>

<p>使用 uwsgi 协议的应用程序服务器中，最常见的是 uWSGI 应用程序服务器容器，即 WSGI 协议自己的实现品。</p>

<p>除此之外，uWSGI 应用程序服务器还支持 HTTP、FastCGI、SCGI，uwsgi 协议是与应用程序对话最快的，建议使用。</p>

<h3 id="配置-nginx与-uwsgi-和-django-配合使用">配置 nginx，与 uWSGI 和 Django 配合使用</h3>

<p>本节示例如何配置 nginx，与 uWSGI 服务器和 Python 开发环境一起工作。</p>

<p>nginx 0.8.40 以后的版本原生支持：通过 uwsgi 协议，把流量从用户传递给 Python 应用程序。nginx 默认支持 uswgi。</p>

<p>Django 也许是最常用的 Python web 框架，此处用它做范例。</p>

<p>仅用于说明目的，这是用 Django 调用 uWSGI 服务器的一种方法：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /usr/local/sbin/uwsgi \</span>
     <span class="nt">--chdir</span><span class="o">=</span>/var/django/projects/myapp <span class="se">\</span>
     <span class="nt">--module</span><span class="o">=</span>myapp.wsgi:application <span class="se">\</span>
     <span class="nt">--env</span> <span class="nv">DJANGO_SETTINGS_MODULE</span><span class="o">=</span>myapp.settings <span class="se">\</span>
     <span class="nt">--master</span> <span class="nt">--pidfile</span><span class="o">=</span>/usr/local/var/run/uwsgi/project-master.pid <span class="se">\</span>
     <span class="nt">--socket</span><span class="o">=</span>127.0.0.1:29000 <span class="se">\</span>
     <span class="nt">--processes</span><span class="o">=</span>5 <span class="se">\</span>
     <span class="nt">--uid</span><span class="o">=</span>505 <span class="nt">--gid</span><span class="o">=</span>505 <span class="se">\</span>
     <span class="nt">--harakiri</span><span class="o">=</span>20 <span class="se">\</span>
     <span class="nt">--max-requests</span><span class="o">=</span>5000 <span class="se">\</span>
     <span class="nt">--vacuum</span> <span class="se">\</span>
     <span class="nt">--daemonize</span><span class="o">=</span>/usr/local/var/log/uwsgi/myapp.log
</code></pre></div></div>

<p>针对上面这些选项的使用，可以如下配置 nginx：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
    <span class="c"># ...
</span>    <span class="n">upstream</span> <span class="n">django</span> {
        <span class="n">server</span> <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">29000</span>;
    }

    <span class="n">server</span> {
        <span class="n">listen</span> <span class="m">80</span>;
        <span class="n">server_name</span> <span class="n">myapp</span>.<span class="n">example</span>.<span class="n">com</span>;
        <span class="n">root</span> /<span class="n">var</span>/<span class="n">www</span>/<span class="n">myapp</span>/<span class="n">html</span>;

        <span class="n">location</span> / {
            <span class="n">index</span> <span class="n">index</span>.<span class="n">html</span>;
        }

        <span class="n">location</span> /<span class="n">static</span>/  {
            <span class="n">alias</span> /<span class="n">var</span>/<span class="n">django</span>/<span class="n">projects</span>/<span class="n">myapp</span>/<span class="n">static</span>/;
        }

        <span class="n">location</span> /<span class="n">main</span> {
            <span class="n">include</span> /<span class="n">etc</span>/<span class="n">nginx</span>/<span class="n">uwsgi_params</span>;
            <span class="n">uwsgi_pass</span> <span class="n">django</span>;
            <span class="n">uwsgi_param</span> <span class="n">Host</span> $<span class="n">host</span>;
            <span class="n">uwsgi_param</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span> $<span class="n">remote_addr</span>;
            <span class="n">uwsgi_param</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">For</span> $<span class="n">proxy_add_x_forwarded_for</span>;
            <span class="n">uwsgi_param</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">Proto</span> $<span class="n">http_x_forwarded_proto</span>;
        }
    }
}
</code></pre></div></div>

<p>配置中定义了一个名为 <code class="highlighter-rouge">django</code> 的后端，组中服务器的端口号为 29000，与 uWSGI 服务器 <code class="highlighter-rouge">socket</code> 参数绑定的相同。</p>

<p>提供静态内容是简单的工作，只需从 <code class="highlighter-rouge">/var/django/projetcts/myapp/static</code> 直接读取。访问应用程序服务器的流量如果是指向 <code class="highlighter-rouge">/main</code>的，则会被代理，从 HTTP 转换成 uwsgi 协议，流量被传递给运行于 uWSGI 应用程序服务器的 Django 程序。</p>

<h3 id="小结">小结</h3>

<p>在构建、部署现代 WEB 应用程序的众多方法中，轻量级、异构的应用程序环境变得越来越流行。更加新的、标准化的应用程序接口协议，如 uwsgi 和 FastCGI 使得用户与程序之间的通信变得更快。</p>

<p>在应用程序容器之前使用 nginx，已经成为一种通用的做法，这样能让程序从沉重的 HTTP 流量管理中摆脱出来，更有利于保护应用程序免遭用户流量意外峰值的冲击，避免恶意行为、拒绝服务攻击等。</p>

<p>把真实世界、外部 HTTP 流量与真实的应用程序分开，让开发者可以把精力集中在程序的逻辑上，把 WEB 加速和一些基础的 HTTP 流量安全任务交给 nginx。</p>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	<hr />
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/nginx" class="page__taxonomy-item" rel="tag">nginx</a>
    
    </span>
  </p>













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://liloli.github.io/categories/#server" class="page__taxonomy-item" rel="tag">server</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2016-01-03T00:00:00+08:00">January 03, 2016</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  <a href="https://twitter.com/intent/tweet?via=liloli&text=Nginx+Web+Server%20https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_webserver%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_webserver%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_webserver%2F" class="btn btn--google-plus" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Google Plus"><i class="fab fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_webserver%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="https://liloli.github.io/server/nginx_security/" class="pagination--pager" title="Nginx 安全控制
">向前</a>
    
    
      <a href="https://liloli.github.io/server/vsftpd/" class="pagination--pager" title="vsftpd 的配置
">向后</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/time/" rel="permalink">Bash 脚本 - 时间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/storage/" rel="permalink">Bash 脚本 - 存储空间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/numbers/" rel="permalink">Bash 脚本 - 数字
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/input/" rel="permalink">Bash 脚本 - 输入
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap">
  <input type="text" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  <div id="results" class="results"></div>
</div>
      </div>
    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
      <li><a href="https://twitter.com/liloli"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
      <li><a href="https://www.facebook.com/lilolibj"><i class="fab fa-fw fa-facebook-square" aria-hidden="true"></i> Facebook</a></li>
    
    
      <li><a href="https://github.com/liloli"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    <li><a href="https://liloli.github.io/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://liloli.github.io/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>



  
  
  <script src="https://liloli.github.io/assets/js/lunr/lunr.min.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-store.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-en.js"></script>





    
  <script>
    var disqus_config = function () {
      this.page.url = "https://liloli.github.io/server/nginx_webserver/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/server/nginx_webserver"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://liloli.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  



  </body>
</html>
