<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Nginx 的负载均衡 - LINOTES</title>
<meta name="description" content="用简洁清晰的语言讨论技术">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Nginx 的负载均衡">
<meta property="og:url" content="https://liloli.github.io/server/nginx_loadbalancer/">


  <meta property="og:description" content="用简洁清晰的语言讨论技术">



  <meta property="og:image" content="https://liloli.github.io/assets/images/header/nginx.jpeg">



  <meta name="twitter:site" content="@liloli">
  <meta name="twitter:title" content="Nginx 的负载均衡">
  <meta name="twitter:description" content="用简洁清晰的语言讨论技术">
  <meta name="twitter:url" content="https://liloli.github.io/server/nginx_loadbalancer/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://liloli.github.io/assets/images/header/nginx.jpeg">
  

  



  <meta property="article:published_time" content="2016-01-03T00:00:00+08:00">





  

  


<link rel="canonical" href="https://liloli.github.io/server/nginx_loadbalancer/">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "Hawk Zhang",
      "url": "https://liloli.github.io",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="https://liloli.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://liloli.github.io/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- <link rel="stylesheet" href="/assets/css/vim.css"> -->



  









<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://liloli.github.io/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/app/rsync/" >Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/server/vsftpd/" >Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/kernel/filedescriptor/" >文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/tools/tools.datastream/" >数据流处理</a>
            </li>
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url('https://liloli.github.io/assets/images/header/nginx.jpeg');"
>
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Nginx 的负载均衡

        
      </h1>
      
        <p class="page__lead">
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://liloli.github.io/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:liloli@gmail.com">
            <meta itemprop="email" content="liloli@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Nginx 的负载均衡">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="January 03, 2016">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-copy"></i> Nginx 的负载均衡</h4></header>
              <ul class="toc__menu">
  <li><a href="#http-负载均衡器">HTTP 负载均衡器</a>
    <ul>
      <li><a href="#把-http-流量代理给一组服务器">把 HTTP 流量代理给一组服务器</a></li>
      <li><a href="#选择一种负载平衡方法">选择一种负载平衡方法</a></li>
      <li><a href="#服务器权重">服务器权重</a></li>
      <li><a href="#被动健康检查">被动健康检查</a></li>
      <li><a href="#与多个工人进程共享数据">与多个工人进程共享数据</a></li>
    </ul>
  </li>
  <li><a href="#tcp--udp-负载均衡器">TCP / UDP 负载均衡器</a>
    <ul>
      <li><a href="#反向代理的配置">反向代理的配置</a></li>
      <li><a href="#tcp--udp-负载均衡的配置">TCP / UDP 负载均衡的配置</a></li>
      <li><a href="#被动健康检查-1">被动健康检查</a></li>
      <li><a href="#tcp--udp-负载均衡范例">TCP / UDP 负载均衡范例</a></li>
    </ul>
  </li>
  <li><a href="#配置-nginx-来接受代理协议">配置 nginx 来接受代理协议</a>
    <ul>
      <li><a href="#配置-gninx-接受代理协议">配置 gninx 接受代理协议</a></li>
      <li><a href="#把负载均衡器的-ip-地址改为客户端的-ip-地址">把负载均衡器的 IP 地址改为客户端的 IP 地址</a></li>
      <li><a href="#记录源-ip-地址">记录源 IP 地址</a></li>
      <li><a href="#代理协议用于后端-tcp-连接">代理协议用于后端 TCP 连接</a></li>
      <li><a href="#范例">范例</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p>负载均衡是指在多个后端服务器中有效地分配网络流量。</p>

<h2 id="http-负载均衡器">HTTP 负载均衡器</h2>

<p>跨多个应用程序实例的负载平衡是一种常用的技术，用于优化资源利用率、最大化吞吐量、减少迟延以及确保容错配置。</p>

<h3 id="把-http-流量代理给一组服务器">把 HTTP 流量代理给一组服务器</h3>

<p>要想把 HTTP 流量负载平衡给一组服务器的话，首先需要用 <code class="highlighter-rouge">upstream</code> 指令来定义一个组，置于 <code class="highlighter-rouge">http</code> 内。该组中的服务器用 <code class="highlighter-rouge">server</code> 指令来配置。即嵌套关系为 <code class="highlighter-rouge">http { upstream { server }}</code></p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
    <span class="n">upstream</span> <span class="n">backend</span> {
        <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>;
        <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>;
        <span class="n">server</span> <span class="m">192</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span> <span class="n">backup</span>;
		<span class="c"># 这三个是服务器组的成员，而非虚拟服务器
</span>    }


    <span class="n">server</span> {
	<span class="c"># 这是虚拟服务器
</span>        <span class="n">location</span> / {
            <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">backend</span>;
        }
    }
}
</code></pre></div></div>

<p><code class="highlighter-rouge">upstream</code> 定义一组服务器，命名为 backend。由三个服务器配置组成。</p>

<p>要想把请求传递给服务器组，必须用 <code class="highlighter-rouge">proxy_pass</code> 指令来指定组名。如果是其它协议，可以用 <code class="highlighter-rouge">fastcgi_pass</code>，<code class="highlighter-rouge">memcached_pass</code>，<code class="highlighter-rouge">scgi_pass</code>，<code class="highlighter-rouge">uwsgi_pass</code> 等指令。</p>

<p>这个虚拟服务器把所有请求都交给 backend 这个后端的服务器组。</p>

<p>因为没有显式指定负载均衡的办法，nginx 使用默认值，Round Robin。</p>

<h3 id="选择一种负载平衡方法">选择一种负载平衡方法</h3>

<p>开源的 nginx 支持四种负载均衡的方法，nginx plus 还支持另外一种。</p>

<h4 id="循环">循环</h4>

<p>Round Robin</p>

<p>所有的请求由组中的成员服务器轮流处理，同时还可以考虑各服务器的权重。这种方法是默认使用的方法，无需显式指定。</p>

<h4 id="最小连接数">最小连接数</h4>

<p>请求会发送给活动连接数最少的服务器，可以考虑服务器的权重。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">backend</span> {
    <span class="n">least_conn</span>;
    <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>;
    <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>;
}
</code></pre></div></div>

<h4 id="ip-哈希">IP 哈希</h4>

<p>由客户端 IP 地址来决定用哪个服务器来处理请求。此时，会使用 IPv4 的头三个八位字节，或 IPv6 的全部地址来计算哈希值。该方法可以保证，来自相同地址的请求会使用同一个服务器来处理。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">backend</span> {
    <span class="n">ip_hash</span>;
    <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>;
    <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>;
}
</code></pre></div></div>

<p>如果要从轮询中临时移除其中的一个服务器，可以在其后面标记 <code class="highlighter-rouge">down</code> 参数，以保留保留当前客户端 IP 地址的哈希值。本来该这个服务器处理的请求会自动发给下一个。</p>

<h4 id="一般哈希">一般哈希</h4>

<p>用哪个服务器来处理请求，是由用户定义的密钥决定的，可以是一个字符串、变量或其组合。例如，密钥可以是一对源 IP 地址与端口的组合，或如下例子中的请求的网址：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">backend</span> {
    <span class="n">hash</span> $<span class="n">request_uri</span> <span class="n">consistent</span>;
    <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>;
    <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>;
}
</code></pre></div></div>

<p>其中 <code class="highlighter-rouge">consistent</code> 参数会启用 ketama consistent-hash 负载均衡。所有请求被平均地分配给所有后端服务器，基于这个用户定义的哈希密钥。如果后端服务器增加或减少了一个，只需要重新映射几个密钥即可。如果负载均衡的是缓存服务器，这可以最小化缓存的丢失。</p>

<h3 id="服务器权重">服务器权重</h3>

<p>nginx 为组中的服务器分配请求时，默认是以其权重为基准的。<code class="highlighter-rouge">server</code> 指令中的 <code class="highlighter-rouge">weight</code> 参数就用于设置服务器的权重，默认值为 1。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">backend</span> {
    <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">weight</span>=<span class="m">5</span>;
    <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>;
    <span class="n">server</span> <span class="m">192</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span> <span class="n">backup</span>;
}
</code></pre></div></div>

<h3 id="被动健康检查">被动健康检查</h3>

<p>当 nginx 认为某个服务器不再可用时，它会临时停止向其发送请求，直到觉得它已再次激活。以下这两个参数使用在 <code class="highlighter-rouge">server</code> 指令中，用来配置认定服务器不可用的条件：</p>

<blockquote>
  <p>如果某个请求没能成功地传递给某个服务器，nginx 认定这是一次失败的尝试。</p>
</blockquote>

<p><code class="highlighter-rouge">max_fails</code> ：设定连续失败的次数，超过这个次数就认定服务器不可用</p>

<p><code class="highlighter-rouge">fail_timeout</code> ：在设定的时间内，必须发生 <code class="highlighter-rouge">max_fails</code> 所设定的数量的连续失败，才认为服务器不可用。而且，nginx 会认为该服务器在接下来的同样时长的时间里不可用。</p>

<p>默认值为 1 次、10 秒钟。即，如果某个服务器对某个请求既不接受，也没有响应，nginx 会立即为该服务器在接下来的 10 秒钟内不可用。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">backend</span> {
    <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>;
    <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">max_fails</span>=<span class="m">3</span> <span class="n">fail_timeout</span>=<span class="m">30</span><span class="n">s</span>;
    <span class="n">server</span> <span class="n">backend3</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">max_fails</span>=<span class="m">2</span>;
}
</code></pre></div></div>

<p>backend2 服务器如果在 30 秒内有连续三次通讯失败，则在接下来的 30 秒内认为该服务器不可用。</p>

<h3 id="与多个工人进程共享数据">与多个工人进程共享数据</h3>

<p>如果 <code class="highlighter-rouge">upstream</code> 块中不包含 <code class="highlighter-rouge">zone</code> 指令，每个工人进程会保留服务器组配置的一个副本，维护其自己的相关计数器。计数器包括当前到组中各服务器的连接数，以及向服务器传递请求失败的次数。这种情况下，服务器组的配置不能动态配置。</p>

<p>如果 <code class="highlighter-rouge">upstream</code> 块中含有 <code class="highlighter-rouge">zone</code> 指令，后端服务器组的配置就会保存在内存的某处，在所有工人进程之间共享。这种情况下可以进行动态配置，因为工人进程访问同一个组配置，使用相同的计数器。</p>

<p><code class="highlighter-rouge">zone</code> 指令对于动态配置是必须的，同时，后端组的其它功能也会利益与该指令的使用。</p>

<p>例如，如果组的配置没有共享，每个工人进程会维护自己的计数器，来为失败的尝试计数。这种情况下，每个请求都只得到一个工人进程，如果这个进程没能把请求传递给服务器，其它的工人进程都无从知道。当某些工人进程认为某个服务器不可用时，其它的工人进程可能仍然会向它发送请求。某个服务器若想最终被认定不再可用，在 <code class="highlighter-rouge">fail_timeout</code> 期间失败的次数必须等于 <code class="highlighter-rouge">max_fails</code> 乘以工人进程的数量。另一方面，<code class="highlighter-rouge">zone</code> 指令保证了预期的行为。</p>

<p>类似的情况，如果没有 <code class="highlighter-rouge">zone</code> 指令，“最少连接数” 的负载均衡方法也不会正常工作，至少在负载低的情况下是这样的。该方法会把请求传递给当前连接数最少的那个服务器。如果组的配置没有共享，每个工人进程会使用其自己的连接数计数器，可能会不小心与其它工人进程同时向同一个服务器发送请求。然而，可以通过提升请求数量来避免。在高负载情况下，所有的请求是在所有工人进程之间平均分配的，“最少连接数” 的方法才会正常工作。</p>

<h4 id="设定-zone-的大小">设定 ZONE 的大小</h4>

<p>永远无法确定什么是最佳的 memory-zone 大小，因为使用情况总是在变化。所需要的内存的数量决定于启用了哪些功能，以及后端服务器是如何识别的。</p>

<p>例如，在启用了 <code class="highlighter-rouge">stick_route</code> 会话保持方法以及一个健康检查的情况下，一个 256 KB 的区域可以容纳服务器的数量如下：</p>

<ul>
  <li>128 个服务器。每个都用 <code class="highlighter-rouge">IP 地址:端口号</code> 定义</li>
  <li>88 个服务器。每个都用 <code class="highlighter-rouge">主机名:端口号</code> 定义，主机名只解析为单一 IP 地址</li>
  <li>12 个服务器。每个都用 <code class="highlighter-rouge">主机名:端口号</code> 定义，主机名可解析为多个 IP 地址</li>
</ul>

<h2 id="tcp--udp-负载均衡器">TCP / UDP 负载均衡器</h2>

<p>负载均衡是指在多个后端服务器中有效地分配网络流量。</p>

<h3 id="反向代理的配置">反向代理的配置</h3>

<p>首先需要配置反向代理，以便 nginx 可以把来自客户端的 TCP 连接或 UDP 数据包转发给后端的组或代理服务器。</p>

<p>1. 创建顶层的 <code class="highlighter-rouge">stream</code> 块</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="c"># ...
</span>}
</code></pre></div></div>

<p>2. 在 <code class="highlighter-rouge">stream</code> 中，为每个虚拟服务器定义一个或多个 <code class="highlighter-rouge">server</code> 块</p>

<p>3. 在每个 <code class="highlighter-rouge">server</code> 中加入 <code class="highlighter-rouge">listen</code> 指令，来定义服务器要侦听的 IP 地址及/或端口。对于 UDP 流量，还要加入 <code class="highlighter-rouge">udp</code> 参数。TCP 是 <code class="highlighter-rouge">stream</code> 中默认的协议，无需显式指定。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="n">server</span> {
        <span class="n">listen</span> <span class="m">12345</span>;
        <span class="c"># ...
</span>    }
    <span class="n">server</span> {
        <span class="n">listen</span> <span class="m">53</span> <span class="n">udp</span>;
        <span class="c"># ...
</span>    }
    <span class="c"># ...
</span>}
</code></pre></div></div>

<p>4. 在每个 <code class="highlighter-rouge">server</code> 中加入 <code class="highlighter-rouge">proxy_pass</code> 指令，来定义代理服务器或组，虚拟服务器用来向其转发流量。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">12345</span>;
        <span class="c">#TCP traffic will be forwarded to the "stream_backend" upstream group
</span>        <span class="n">proxy_pass</span> <span class="n">stream_backend</span>;
    }
    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">12346</span>;
        <span class="c">#TCP traffic will be forwarded to the specified server
</span>        <span class="n">proxy_pass</span> <span class="n">backend</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12346</span>;
    }
    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">53</span> <span class="n">udp</span>;
        <span class="c">#UDP traffic will be forwarded to the "dns_servers" upstream group
</span>        <span class="n">proxy_pass</span> <span class="n">dns_servers</span>;
    }
    <span class="c"># ...
</span>}
</code></pre></div></div>

<p>5. 如果代理服务器有多个网络接口，连接到后端服务器时，可以考虑配置  nginx 使用特定的源 IP 地址。如果 nginx 后面的某个代理服务器，被配置为只接受来自特定 IP 网络或 IP 地址范围的连接，该方法可以配合使用。</p>

<p>在 <code class="highlighter-rouge">server</code> 中加入 <code class="highlighter-rouge">proxy_bind</code> 指令，用来绑定特定接口的 IP 地址：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="c"># ...
</span>    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">12345</span>;
        <span class="n">proxy_pass</span> <span class="n">backend</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
        <span class="n">proxy_bind</span> <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">12345</span>;
    }
}
</code></pre></div></div>

<p>6. 另外，也可以考虑调整两个内存中缓冲区的大小，nginx 可以把来自客户端和后端连接的数据放在缓冲区中。</p>

<p>如果数据量比较小，可以减小缓冲区，以节省内存资源。如果数据量比较大，可以增大缓冲区，以减少对套接字读写的操作。</p>

<p>一旦收到某个连接上的数据，nginx 会读取并通过其它连接将其转发。</p>

<p>缓冲区大小是由 <code class="highlighter-rouge">proxy_buffer_size</code> 指令控制的。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="c"># ...
</span>    <span class="n">server</span> {
        <span class="n">listen</span>            <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">12345</span>;
        <span class="n">proxy_pass</span>        <span class="n">backend</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
        <span class="n">proxy_buffer_size</span> <span class="m">16</span><span class="n">k</span>;
    }
}
</code></pre></div></div>

<h3 id="tcp--udp-负载均衡的配置">TCP / UDP 负载均衡的配置</h3>

<p>1. 创建一组服务器，或一个后端组，以分担总流量。在顶层 <code class="highlighter-rouge">stream {}</code> 中，定义一个或多个 <code class="highlighter-rouge">upstream {}</code> 配置块，命名后端组。如命名为 stream_backend，用于 TCP 服务器；命名为 dns_servers，用于 UDP 服务器。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="n">upstream</span> <span class="n">stream_backend</span> {
        <span class="c"># ...
</span>    }
    <span class="n">upstream</span> <span class="n">dns_servers</span> {
        <span class="c"># ...
</span>    }
    <span class="c"># ...
</span>}
</code></pre></div></div>

<p>要确保后端组的名称会被 <code class="highlighter-rouge">proxy_pass</code> 指令引用。</p>

<p>2. 在后端组中添加后端服务器。在 <code class="highlighter-rouge">upstream {}</code> 块中，为每个后端服务器添加一个 <code class="highlighter-rouge">server</code> 指令，在其中指定其 IP 地址或主机名及端口号。注意，不需要为每个服务器定义协议，因为需要为整个后端组来定义，用 <code class="highlighter-rouge">listen</code> 指令。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="n">upstream</span> <span class="n">stream_backend</span> {
        <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
        <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
        <span class="n">server</span> <span class="n">backend3</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12346</span>;
        <span class="c"># ...
</span>    }
    <span class="n">upstream</span> <span class="n">dns_servers</span> {
        <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">130</span>:<span class="m">53</span>;
        <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">131</span>:<span class="m">53</span>;
        <span class="c"># ...
</span>    }
    <span class="c"># ...
</span>}
</code></pre></div></div>

<p>3. 配置后端组使用的负载均衡方法。可以在以下方法中选择：</p>

<ul>
  <li>轮流 ：nginx 默认使用轮流的机制来进行负载均衡，按后端组中的顺序，把流量轮流重定向到每个服务器。因为是默认的方法，就无需显式指定。</li>
  <li>最小连接数 ：nginx 选择当前连接数最小的服务器。</li>
  <li>哈希值 ：nginx 基于一个用户定义的密钥来选择服务器。</li>
</ul>

<p>4. 还可以为每个后端服务器单独设定各自的参数，包括连接最大数、服务器权重等：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">stream_backend</span> {
    <span class="n">hash</span>   $<span class="n">remote_addr</span> <span class="n">consistent</span>;
    <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span> <span class="n">weight</span>=<span class="m">5</span>;
    <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
    <span class="n">server</span> <span class="n">backend3</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12346</span> <span class="n">max_conns</span>=<span class="m">3</span>;
}
<span class="n">upstream</span> <span class="n">dns_servers</span> {
    <span class="n">least_conn</span>;
    <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">130</span>:<span class="m">53</span>;
    <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">131</span>:<span class="m">53</span>;
    <span class="c"># ...
</span>}
</code></pre></div></div>

<p>另一个办法是把流量代理到一个单独的服务器，而不是后端组。如果用主机名来标识服务器，并配置该主机名可以解析到多个 IP 地址，nginx 会把流量在所有 IP 地址间轮流负载均衡。这种情况下，必须在 <code class="highlighter-rouge">prox_pass</code> 指令中指定服务器的端口号，而且在 IP 地址或主机名之前不能指定协议。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="c"># ...
</span>    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">12345</span>;
        <span class="n">proxy_pass</span> <span class="n">backend</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
    }
}
</code></pre></div></div>

<h3 id="被动健康检查-1">被动健康检查</h3>

<p>如果连接到某个到后端服务器的尝试超时了，或出错了错误，nginx 可以把服务器标记为不可用，并在一段时间内停止向其发送请求。</p>

<p>与 HTTP 负载均衡中的被动健康检查相同。</p>

<h3 id="tcp--udp-负载均衡范例">TCP / UDP 负载均衡范例</h3>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="n">upstream</span> <span class="n">stream_backend</span> {
        <span class="n">least_conn</span>;
        <span class="n">server</span> <span class="n">backend1</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span> <span class="n">weight</span>=<span class="m">5</span>;
        <span class="n">server</span> <span class="n">backend2</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span> <span class="n">max_fails</span>=<span class="m">2</span> <span class="n">fail_timeout</span>=<span class="m">30</span><span class="n">s</span>;
        <span class="n">server</span> <span class="n">backend3</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span> <span class="n">max_conns</span>=<span class="m">3</span>;
    }

    <span class="n">upstream</span> <span class="n">dns_servers</span> {
        <span class="n">least_conn</span>;
        <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">130</span>:<span class="m">53</span>;
        <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">131</span>:<span class="m">53</span>;
        <span class="n">server</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">136</span>.<span class="m">132</span>:<span class="m">53</span>;
    }

    <span class="n">server</span> {
        <span class="n">listen</span>        <span class="m">12345</span>;
        <span class="n">proxy_pass</span>    <span class="n">stream_backend</span>;
        <span class="n">proxy_timeout</span> <span class="m">3</span><span class="n">s</span>;
        <span class="n">proxy_connect_timeout</span> <span class="m">1</span><span class="n">s</span>;
    }

    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">53</span> <span class="n">udp</span>;
        <span class="n">proxy_pass</span> <span class="n">dns_servers</span>;
    }

    <span class="n">server</span> {
        <span class="n">listen</span>     <span class="m">12346</span>;
        <span class="n">proxy_pass</span> <span class="n">backend4</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12346</span>;
    }
}
</code></pre></div></div>

<p>本例中，所有的 TCP 和 UDP 代理相关的功能都在 <code class="highlighter-rouge">stream</code> 块中配置。</p>

<p>共有两个命名的 <code class="highlighter-rouge">upstream</code> 块，每个包含三个服务器，提供相同的内容。每个服务器的 <code class="highlighter-rouge">server</code> 指令中，服务器名后面跟着端口号。所有连接是按照 “最小连接数” 方法来分配给各服务器的。</p>

<p>下面的三个 <code class="highlighter-rouge">server</code> 块则定义了三个虚拟服务器：</p>

<ul>
  <li>
    <p>第一个服务器侦听端口 12345，会把所有 TCP 连接代理给后端服务器组 stream_backend。注意，<code class="highlighter-rouge">stream</code> 块中定义的 <code class="highlighter-rouge">proxy_pass</code> 不允许包含协议。</p>

    <p>两个可选的超时参数：<code class="highlighter-rouge">proxy_connect_timeout</code> 指令用于指定与服务组中的服务器建立连接所需要的时间，<code class="highlighter-rouge">proxy_timeout</code> 指令用于指定超时的时间，在把一个请求向组中的服务器代理之后，超过该时间就认为超时。</p>
  </li>
  <li>第二个服务器侦听端口 53，把所有 UDP 数据包都代理给名为 dns_servers 的后端组。如果没有指定 <code class="highlighter-rouge">udp</code> 参数，套接字会用来侦听 TCP 连接。</li>
  <li>第三个虚拟服务器侦听端口 12346，把 TCP 连接代理给 backend4.example.com，该域名可解析为多个 IP 地址，通过它们来进行负载均衡。</li>
</ul>

<h2 id="配置-nginx-来接受代理协议">配置 nginx 来接受代理协议</h2>

<p>代理协议使得 gninx 可以接收到客户端的连接信息，这些信息是经由代理服务器和负载均衡器传递过来的。</p>

<p>借助代理协议，nginx 可以从 HTTP, SSL, HTTP/2, SPDY, WebSocket, TCP 获得源 IP 地址。知道了客户端的源 IP 地址，有利于为网站设置特定的语言、维护 IP 地址的黑名单、日志及统计信息。</p>

<p>通过代理协议传递来的信息包括客户端的 IP 地址、代理服务器的 IP 地址，以及它们的端口。</p>

<p>nginx 有几种办法来从信息中获取源 IP 地址：</p>

<ul>
  <li>用 <code class="highlighter-rouge">$proxy_protocol</code> 和 <code class="highlighter-rouge">$proxy_protocol_addr_port</code> 变量来获取源 IP 地址及端口。用 <code class="highlighter-rouge">$remote_addr</code> 和 <code class="highlighter-rouge">$remote_port</code> 变量来获取负载均衡器的 IP 地址及端口。</li>
  <li><code class="highlighter-rouge">Real-IP</code> 模块会重写 <code class="highlighter-rouge">$remote_addr</code> 和 <code class="highlighter-rouge">$remote_port</code> 变量的值，用源客户端 IP 地址和端口来替换负载均衡器的 IP 地址及端口。<code class="highlighter-rouge">$realip_remote_addr</code> 和 <code class="highlighter-rouge">$realip_remote_port</code>  变量会保存负载均衡器的 IP 地址和端口，<code class="highlighter-rouge">$proxy_protocol_addr</code> 及 <code class="highlighter-rouge">$proxy_protocol_port</code> 变量会保存源客户端的 IP 地址和端口。</li>
</ul>

<h3 id="配置-gninx-接受代理协议">配置 gninx 接受代理协议</h3>

<p>若想配置 nginx 使其接受代理协议标头，需在 <code class="highlighter-rouge">http</code> 或 <code class="highlighter-rouge">stream</code> 块中添加 <code class="highlighter-rouge">server</code> 块，然后在 <code class="highlighter-rouge">server</code> 块中为 <code class="highlighter-rouge">listen</code> 指令添加 <code class="highlighter-rouge">proxy_protocol</code> 参数：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
    <span class="c">#...
</span>    <span class="n">server</span> {
        <span class="n">listen</span> <span class="m">80</span>   <span class="n">proxy_protocol</span>;
        <span class="n">listen</span> <span class="m">443</span>  <span class="n">ssl</span> <span class="n">proxy_protocol</span>;
        <span class="c">#...
</span>    }
}

<span class="n">stream</span> {
    <span class="c">#...
</span>    <span class="n">server</span> {
        <span class="n">listen</span> <span class="m">12345</span> <span class="n">proxy_protocol</span>;
        <span class="c">#...
</span>    }
}
</code></pre></div></div>

<p>现在就可以使用 <code class="highlighter-rouge">$proxy_protocol_addr</code> 和 <code class="highlighter-rouge">$proxy_protocol_port</code> 变量来保存客户端的 IP 地址和端口了，还可以额外配置 HTTP 和 Stream 中的 Real-IP 模块，用客户端的 IP 地址和端口来替换 <code class="highlighter-rouge">$remote_addr</code> 和 <code class="highlighter-rouge">$remote_port</code> 变量所保存的负载均衡器的 IP 地址和端口。</p>

<h3 id="把负载均衡器的-ip-地址改为客户端的-ip-地址">把负载均衡器的 IP 地址改为客户端的 IP 地址</h3>

<p>可以把负载均衡器或 TCP 代理的地址，换成从代理协议接收到的客户端的 IP 地址。可以用 HTTP 和 Stream 中的 Real-IP 模块来实现。有了这些模块，可以用  <code class="highlighter-rouge">$remote_addr</code> 和 <code class="highlighter-rouge">remote_port</code> 变量来保存客户端的 IP 地址及端口，而 <code class="highlighter-rouge">$realip_remote_addr</code> 和 <code class="highlighter-rouge">$realip_remote_port</code> 变量会保存负载均衡器的 IP 地址和端口。</p>

<p>若想把 IP 地址从负载均衡器的换成客户端的：</p>

<ol>
  <li>确保已配置 nginx 接受代理协议标头。</li>
  <li>确保安装了 HTTP 和 Stream Real-IP 模块：</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nginx <span class="nt">-V</span> 2&gt;&amp;1 | <span class="nb">grep</span> <span class="nt">--</span> <span class="s1">'http_realip_module'</span>
nginx <span class="nt">-V</span> 2&gt;&amp;1 | <span class="nb">grep</span> <span class="nt">--</span> <span class="s1">'stream_realip_module'</span>
</code></pre></div></div>

<p>如果没安装，可以用这些模块来重新编译 nginx。</p>

<p>在 <code class="highlighter-rouge">http</code> 或 <code class="highlighter-rouge">stream</code> 中，使用 <code class="highlighter-rouge">set_real_ip_from</code> 指令来指定 TCP 代理或负载均衡器的 IP 地址或 CIDR 地址范围：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="c">#...
</span>    <span class="n">set_real_ip_from</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">1</span>.<span class="m">0</span>/<span class="m">24</span>;
    <span class="c">#...
</span>}
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">http</code> 块中，把负载均衡器的 IP 地址改成从代理协议标头中收到的客户端 IP 地址，把 <code class="highlighter-rouge">proxy_protocol</code> 参数指定给 <code class="highlighter-rouge">real_ip_header</code> 指令：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
    <span class="n">server</span> {
        <span class="c">#...
</span>        <span class="n">real_ip_header</span> <span class="n">proxy_protocol</span>;
     }
}
</code></pre></div></div>

<h3 id="记录源-ip-地址">记录源 IP 地址</h3>

<p>如果知道了客户端的源 IP 地址，就可以配置正确的日志了：</p>

<p>对于 HTTP，配置  nginx ，用 <code class="highlighter-rouge">$proxy_protocol_addr</code> 变量和 <code class="highlighter-rouge">proxy_set_header</code> 指令，把客户端 IP 地址传递给后端服务器：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
    <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span>       $<span class="n">proxy_protocol_addr</span>;
    <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">For</span> $<span class="n">proxy_protocol_addr</span>;
}
</code></pre></div></div>

<p>把变量 <code class="highlighter-rouge">$proxy_protocol_addr</code> 添加到 <code class="highlighter-rouge">log_format</code> 指令中:</p>

<p>在 <code class="highlighter-rouge">http</code> 块中：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
   <span class="c">#...
</span>   <span class="n">log_format</span> <span class="n">combined</span> <span class="s1">'$proxy_protocol_addr - $remote_user [$time_local] '</span>
                       <span class="s1">'"$request" $status $body_bytes_sent '</span>
                       <span class="s1">'"$http_referer" "$http_user_agent"'</span>;
}
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">stream</code> 块中：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="c">#...
</span>    <span class="n">log_format</span> <span class="n">basic</span> <span class="s1">'$proxy_protocol_addr - $remote_user [$time_local] '</span>
                     <span class="s1">'$protocol $status $bytes_sent $bytes_received '</span>
                     <span class="s1">'$session_time'</span>;
}
</code></pre></div></div>

<h3 id="代理协议用于后端-tcp-连接">代理协议用于后端 TCP 连接</h3>

<p>对于一个 TCP 数据流，可以为 nginx 与后端服务器之间的连接启用代理协议。若想启用代理协议，在 <code class="highlighter-rouge">stream &gt; server</code> 块中使用 <code class="highlighter-rouge">proxy_protocol</code> 指令：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> {
    <span class="n">server</span> {
        <span class="n">listen</span> <span class="m">12345</span>;
        <span class="n">proxy_pass</span> <span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
        <span class="n">proxy_protocol</span> <span class="n">on</span>;
    }
}
</code></pre></div></div>

<h3 id="范例">范例</h3>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">http</span> {
    <span class="n">log_format</span> <span class="n">combined</span> <span class="s1">'$proxy_protocol_addr - $remote_user [$time_local] '</span>
                        <span class="s1">'"$request" $status $body_bytes_sent '</span>
                        <span class="s1">'"$http_referer" "$http_user_agent"'</span>;
    <span class="c">#...
</span>
    <span class="n">server</span> {
        <span class="n">server_name</span> <span class="n">localhost</span>;

        <span class="n">listen</span> <span class="m">80</span>   <span class="n">proxy_protocol</span>;
        <span class="n">listen</span> <span class="m">443</span>  <span class="n">ssl</span> <span class="n">proxy_protocol</span>;  
					<span class="c"># 在 443 端口接受 HTTPS 流量
</span>					<span class="c"># 接受代理协议从负载均衡器传来的客户端 IP 地址
</span>
        <span class="n">ssl_certificate</span>      /<span class="n">etc</span>/<span class="n">nginx</span>/<span class="n">ssl</span>/<span class="n">public</span>.<span class="n">example</span>.<span class="n">com</span>.<span class="n">pem</span>;
        <span class="n">ssl_certificate_key</span>  /<span class="n">etc</span>/<span class="n">nginx</span>/<span class="n">ssl</span>/<span class="n">public</span>.<span class="n">example</span>.<span class="n">com</span>.<span class="n">key</span>;

        <span class="n">location</span> /<span class="n">app</span>/ {
            <span class="n">proxy_pass</span>       <span class="n">http</span>://<span class="n">backend1</span>;
            <span class="n">proxy_set_header</span> <span class="n">Host</span>            $<span class="n">host</span>;
            <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span>       $<span class="n">proxy_protocol_addr</span>;
            <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">For</span> $<span class="n">proxy_protocol_addr</span>;
        }
    }
}

<span class="n">stream</span> {
    <span class="n">log_format</span> <span class="n">basic</span> <span class="s1">'$proxy_protocol_addr - $remote_user [$time_local] '</span>
                     <span class="s1">'$protocol $status $bytes_sent $bytes_received '</span>
                     <span class="s1">'$session_time'</span>;
    <span class="c">#...
</span>    <span class="n">server</span> {
        <span class="n">listen</span>              <span class="m">12345</span> <span class="n">ssl</span> <span class="n">proxy_protocol</span>;
							<span class="c"># 在 12345 端口接受 TCP 流量
</span>							<span class="c"># 接受代理协议从负载均衡器传来的客户端 IP 地址
</span>
        <span class="n">ssl_certificate</span>     /<span class="n">etc</span>/<span class="n">nginx</span>/<span class="n">ssl</span>/<span class="n">cert</span>.<span class="n">pem</span>;
        <span class="n">ssl_certificate_key</span> /<span class="n">etc</span>/<span class="n">nginx</span>/<span class="n">ssl</span>/<span class="n">cert</span>.<span class="n">key</span>;

        <span class="n">proxy_pass</span>          <span class="n">backend</span>.<span class="n">example</span>.<span class="n">com</span>:<span class="m">12345</span>;
        <span class="n">proxy_protocol</span>      <span class="n">on</span>;
		<span class="c"># TCP 服务器会把自己的代理协议数据发送给后端的服务器
</span>    }
}
</code></pre></div></div>

<p>该范例假设在 nginx 前面有一个负载均衡器，用于处理所有的传入 HTTPS 流量，如 Amazon ELB。nginx 在 443 端口接受 HTTPS 流量，在 12345 端口接受 TCP 流量，接受代理协议从负载均衡器传来的客户端 IP 地址。</p>

<p>通过使用 <code class="highlighter-rouge">ssl_certificate</code> 和 <code class="highlighter-rouge">ssl_certificate_key</code> 指令，nginx 结束 HTTPS 的流量，把加密的数据代理给后端服务器：</p>

<ul>
  <li>对于 HTTP：<code class="highlighter-rouge">proxy_pass http://backend1;</code></li>
  <li>对于 TCP：<code class="highlighter-rouge">proxy_pass backend.example.com:12345</code></li>
</ul>

<p>用 <code class="highlighter-rouge">proxy_set_header</code> 指令来包含客户端 IP  地址与端口。</p>

<p><code class="highlighter-rouge">log_format</code> 指令中的 <code class="highlighter-rouge">proxy_protocol_addr</code> 变量也会把客户端的 IP 地址保存到日志中，无论 HTTP 还是 TCP 的流量 。</p>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	<hr />
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/nginx" class="page__taxonomy-item" rel="tag">nginx</a><span class="sep">  </span>
    
		
      <a href="/tag/负载均衡" class="page__taxonomy-item" rel="tag">负载均衡</a>
    
    </span>
  </p>













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://liloli.github.io/categories/#server" class="page__taxonomy-item" rel="tag">server</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2016-01-03T00:00:00+08:00">January 03, 2016</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  <a href="https://twitter.com/intent/tweet?via=liloli&text=Nginx+%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%20https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_loadbalancer%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_loadbalancer%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_loadbalancer%2F" class="btn btn--google-plus" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Google Plus"><i class="fab fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fliloli.github.io%2Fserver%2Fnginx_loadbalancer%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="https://liloli.github.io/server/nginx_intro/" class="pagination--pager" title="Nginx 入门
">向前</a>
    
    
      <a href="https://liloli.github.io/server/nginx_security/" class="pagination--pager" title="Nginx 安全控制
">向后</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/time/" rel="permalink">Bash 脚本 - 时间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/storage/" rel="permalink">Bash 脚本 - 存储空间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/numbers/" rel="permalink">Bash 脚本 - 数字
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/input/" rel="permalink">Bash 脚本 - 输入
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap">
  <input type="text" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  <div id="results" class="results"></div>
</div>
      </div>
    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
      <li><a href="https://twitter.com/liloli"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
      <li><a href="https://www.facebook.com/lilolibj"><i class="fab fa-fw fa-facebook-square" aria-hidden="true"></i> Facebook</a></li>
    
    
      <li><a href="https://github.com/liloli"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    <li><a href="https://liloli.github.io/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://liloli.github.io/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>



  
  
  <script src="https://liloli.github.io/assets/js/lunr/lunr.min.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-store.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-en.js"></script>





    
  <script>
    var disqus_config = function () {
      this.page.url = "https://liloli.github.io/server/nginx_loadbalancer/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/server/nginx_loadbalancer"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://liloli.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  



  </body>
</html>
