<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.1 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Apache 虚拟主机 - LINOTES</title>
<meta name="description" content="Apache，是非常流行的网页服务器软件。通常和脚本语言比如 PHP，数据库 MySQL 一起工作，合称为 LAMP。本文主要参考 apache 官方文档。">



<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="LINOTES">
<meta property="og:title" content="Apache 虚拟主机">
<meta property="og:url" content="https://liloli.github.io/server/vhost/">


  <meta property="og:description" content="Apache，是非常流行的网页服务器软件。通常和脚本语言比如 PHP，数据库 MySQL 一起工作，合称为 LAMP。本文主要参考 apache 官方文档。">



  <meta property="og:image" content="https://liloli.github.io/assets/images/header/network.service.jpg">



  <meta name="twitter:site" content="@liloli">
  <meta name="twitter:title" content="Apache 虚拟主机">
  <meta name="twitter:description" content="Apache，是非常流行的网页服务器软件。通常和脚本语言比如 PHP，数据库 MySQL 一起工作，合称为 LAMP。本文主要参考 apache 官方文档。">
  <meta name="twitter:url" content="https://liloli.github.io/server/vhost/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://liloli.github.io/assets/images/header/network.service.jpg">
  

  



  <meta property="article:published_time" content="2016-01-02T00:00:00+08:00">





  

  


<link rel="canonical" href="https://liloli.github.io/server/vhost/">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "Hawk Zhang",
      "url": "https://liloli.github.io",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="https://liloli.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="LINOTES Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://liloli.github.io/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- <link rel="stylesheet" href="/assets/css/vim.css"> -->



  









<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://liloli.github.io/">LINOTES</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/app/rsync/" >Rsync 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/server/vsftpd/" >Vsftpd 的用法</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/kernel/filedescriptor/" >文件描述符简介</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="https://liloli.github.io/tools/tools.datastream/" >数据流处理</a>
            </li>
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://liloli.github.io/assets/images/header/network.service.jpg');"
>
  
    <div class="wrapper">
      <h1 class="page__title" itemprop="headline">
        
          Apache 虚拟主机

        
      </h1>
      
        <p class="page__lead">Apache，是非常流行的网页服务器软件。通常和脚本语言比如 PHP，数据库 MySQL 一起工作，合称为 LAMP。本文主要参考 apache <a href="https://httpd.apache.org/docs/2.4/configuring.html">官方文档</a>。
</p>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="https://liloli.github.io/assets/images/bio-photo.jpg" alt="Hawk Zhang" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Hawk Zhang</h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">北京</span>
        </li>
      

      

      
        <li>
          <a href="mailto:liloli@gmail.com">
            <meta itemprop="email" content="liloli@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/hawkzhang" itemprop="sameAs">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/liloli" itemprop="sameAs">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">切换菜单</label>
  <ul class="nav__items">
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Apache 虚拟主机">
    <meta itemprop="description" content="Apache，是非常流行的网页服务器软件。通常和脚本语言比如 PHP，数据库 MySQL 一起工作，合称为 LAMP。本文主要参考 apache 官方文档。">
    <meta itemprop="datePublished" content="January 02, 2016">
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-code"></i> Apache 虚拟主机</h4></header>
              <ul class="toc__menu">
  <li><a href="#基于域名的虚拟主机">基于域名的虚拟主机</a>
    <ul>
      <li><a href="#基于域名与基于-ip-的区别">基于域名与基于 IP 的区别</a></li>
      <li><a href="#服务器如何找到正确的虚拟主机">服务器如何找到正确的虚拟主机</a></li>
      <li><a href="#使用方法">使用方法</a></li>
    </ul>
  </li>
  <li><a href="#基于-ip-的虚拟主机">基于 IP 的虚拟主机</a>
    <ul>
      <li><a href="#系统需求">系统需求</a></li>
      <li><a href="#设置方法">设置方法</a></li>
      <li><a href="#多守护进程的配置">多守护进程的配置</a></li>
      <li><a href="#单守护进程的配置">单守护进程的配置</a></li>
      <li><a href="#一个地址-运行-多个基于域名网站">一个地址 运行 多个基于域名网站</a></li>
      <li><a href="#多个地址-运行-多个基于域名的网站">多个地址 运行 多个基于域名的网站</a></li>
      <li><a href="#多个地址-运行-一个网站">多个地址 运行 一个网站</a></li>
      <li><a href="#多个端口-运行-多个网站">多个端口 运行 多个网站</a></li>
      <li><a href="#基于地址的虚拟主机">基于地址的虚拟主机</a></li>
      <li><a href="#基于端口-和-基于地址-的混合使用">基于端口 和 基于地址 的混合使用</a></li>
      <li><a href="#基于域名-和-基于地址-混合使用">基于域名 和 基于地址 混合使用</a></li>
      <li><a href="#虚拟主机用做-反向代理">虚拟主机用做 反向代理</a></li>
      <li><a href="#使用-_default_-虚拟主机">使用 <em>default</em> 虚拟主机</a></li>
      <li><a href="#基于域名-迁移到-基于-ip">基于域名 迁移到 基于 IP</a></li>
      <li><a href="#serverpath-指令">ServerPath 指令</a></li>
    </ul>
  </li>
  <li><a href="#文件描述符的限制">文件描述符的限制</a>
    <ul>
      <li><a href="#分解日志文件">分解日志文件</a></li>
      <li><a href="#动态配置海量虚拟主机">动态配置海量虚拟主机</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p>虚拟主机可以是基于 IP 的，即每个网站有独立的 IP 地址；也可以基于域名的，即每个 IP 地址有多个域名在运行。终端用户对于同一物理服务器上运行多个网站的事实是不知情的。</p>

<p>apache 是最早支持多个基于 IP 的虚拟主机的服务器之一。版本 1.1 之后开始同时支持基于 IP 和基于域名的虚拟主机。</p>

<blockquote>
  <p>基于域名的虚拟主机有时也叫基于主机的，或非 IP 的虚拟主机。</p>
</blockquote>

<p>几乎所有配置指令都能在 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 中使用，除了控制进程创建的以及其它一些指令。具体可以查看<a href="https://httpd.apache.org/docs/2.4/mod/quickreference.html#V">指令速查表</a>。</p>

<h2 id="基于域名的虚拟主机">基于域名的虚拟主机</h2>

<p>每 IP 地址有多个网站。</p>

<h3 id="基于域名与基于-ip-的区别">基于域名与基于 IP 的区别</h3>

<p>基于 IP 的虚拟主机使用连接的 IP 地址来确定正确的虚拟主机。因此需要为每个虚拟主机分配单独的 IP 地址。</p>

<p>基于域名的虚拟主机，服务器依赖于客户端在 HTTP 标头中提交的域名。多个不同的虚拟主机可以使用同一个 IP 地址。</p>

<p>基于域名的虚拟主机通常更简单，因为只需要配置 DNS 服务器把各个域名映射到正确的 IP 地址，然后再配置 apache，令其可以识别不同的虚拟主机就可以了。基于域名的虚拟主机减少了对 IP 地址的需求，因此如果设备不是显式需要基于 IP 的虚拟主机，就可以使用基于域名的。</p>

<h3 id="服务器如何找到正确的虚拟主机">服务器如何找到正确的虚拟主机</h3>

<p>一定要了解一点，基于域名的虚拟主机的解析，其第一步就是基于 IP 的解析。因为首先要通过匹配基于 IP 的虚拟主机来缩小查找范围，之后再进一步选择最合适的基于域名的匹配。如果在所有的虚拟主机段落中，把 IP 地址都用通配符 <code class="highlighter-rouge">*</code> 来代替，则与基于 IP 的映射无关了。</p>

<p>当一个请求到达时，服务器会基于该请求使用的 <strong>IP 地址和端口号</strong> 来寻找最佳匹配的 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 参数。如果最佳匹配不止一个，apache 会进一步拿 <code class="highlighter-rouge">ServerName</code> 和 <code class="highlighter-rouge">ServerAlias</code> 指令与请求中的服务器域名进行比较。如果最佳匹配没有找到对应的 <code class="highlighter-rouge">ServerName</code> 和 <code class="highlighter-rouge">ServerAlias</code>，则使用匹配的虚拟主机列表中的 <strong>第一个</strong>，即针对该 IP 地址和端口号组合的 <strong>默认</strong> 主机。。</p>

<p>如果所有基于域名的虚拟主机中都省略了 <code class="highlighter-rouge">ServerName</code> 指令，服务器则会从系统主机名来获取。这往往会导致错误。</p>

<h3 id="使用方法">使用方法</h3>

<p>第一步是为每一个不同的主机创建一个 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 容器，在每个容器中，至少要有 <code class="highlighter-rouge">ServerName</code> 来标识主机，以及 <code class="highlighter-rouge">DocumentRoot</code> 指定其文件系统根目录。</p>

<h4 id="创建默认虚拟主机">创建默认虚拟主机</h4>

<p>任何与现有 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 不匹配的请求都会由全局配置来处理，不管其主机名或服务器名是什么。</p>

<p class="notice">虚拟主机列表中出现的 <strong>第一个主机</strong> 通常看看作 <strong>默认</strong> 的主机，具有最高优先级。这意味着如果某个请求与列表中所有主机中的 <code class="highlighter-rouge">ServerName</code> 都不匹配的话，会使用第一个虚拟主机。</p>

<p>在服务器中增加了一个基于域名的虚拟主机之后，如果该主机的参数中的 “IP 地址和端口的组合” 与已有的主机发生了重复，请求则会由更精确匹配的虚拟主机来处理。这种情况下，通常需要创建一个 <strong>默认的</strong> 虚拟主机，令其 <code class="highlighter-rouge">ServerName</code> 匹配最基本的服务器域名。在其之后，可以增加新的域名，虽然是相同的接口和端口号，但是需要单独的配置。</p>

<h4 id="域名的继承">域名的继承</h4>

<p><strong>一定要</strong> 在每个基于域名的虚拟主机中用 <code class="highlighter-rouge">ServerName</code> 显式 <strong>指定域名</strong>。</p>

<p>如果没有指定，服务器的域名会从主配置中继承，如果全局配置中也没有指定，则会使用系统启动时第一个侦听的地址的反向 DNS 解析到的域名。无论哪种情况，这个继承下来的域名都会影响基于域名的的虚拟主机的解析，因此一定要在每个虚拟主机配置中显式指定 <code class="highlighter-rouge">ServerName</code>。</p>

<h4 id="范例">范例</h4>

<p>假设当前服务器已有域名 www.example.com 的虚拟主机，现在想再加一个 other.example.com 的虚拟主机，指向同一个 IP 地址。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> *:<span class="m">80</span>&gt;
    <span class="c"># 这第一个虚拟主机同时也是 *:80 的默认主机
</span>    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">ServerAlias</span> <span class="n">example</span>.<span class="n">com</span> *.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/domain"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> *:<span class="m">80</span>&gt;
    <span class="n">ServerName</span> <span class="n">other</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/otherdomain"</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>可以用具体的 IP 地址来替换 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 中的通配符 <code class="highlighter-rouge">*</code>。</p>

<p>许多网站可以用多个域名访问，可以用 <code class="highlighter-rouge">ServerAlias</code> 为网站指定多个域名，放在 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 段落中。本例中的 <code class="highlighter-rouge">ServerAlias</code> 所起的作用就是，指向 example.com 所有主机的请求都会由 www.example.com 这个虚拟主机来处理。一定要保证所有域名都经过了注册，并进行了 DNS 记录的解析，这样才能保证它们能在互联网上正确解析。</p>

<h2 id="基于-ip-的虚拟主机">基于 IP 的虚拟主机</h2>

<p>基于 IP 的虚拟主机会基于收到请求所在的 IP 地址及端口来应用不同的指令。通常用来在不同的 <strong>端口</strong> 或不同的 <strong>接口</strong> 提供不同的网站。</p>

<p>在许多情况下，基于域名的虚拟主机更方便，因为可以多个虚拟主机共享一个地址/端口。</p>

<h3 id="系统需求">系统需求</h3>

<p>服务器必须为每个虚拟主机提供不同的 IP 地址/端口。可以用多个 <strong>物理网络接口</strong> 来实现，也可以用 <strong>虚拟网络接口</strong> 来实现，现在大多操作系统都支持，还可以用多个 <strong>端口号</strong> 来实现。</p>

<h3 id="设置方法">设置方法</h3>

<p>有两种设置方法，一种是为每个域名单独运行一个 httpd 守护进程，另一种是运行一个进程，该进程自己就支持多个虚拟主机。</p>

<h4 id="适合多个守护进程的场景">适合多个守护进程的场景</h4>

<ul>
  <li>数据需要隔离。例如公司甲不希望公司乙的人看到他们的数据，此时可以运行两个守护进程，每个使用不同的 <code class="highlighter-rouge">User</code>、<code class="highlighter-rouge">Group</code>、<code class="highlighter-rouge">Listen</code>、<code class="highlighter-rouge">ServerRoot</code> 。</li>
  <li>负担得起 “侦听计算机上每个 IP 别名” 所需的内存和文件描述符。</li>
</ul>

<h4 id="适合单守护进程的场景">适合单守护进程的场景</h4>

<ul>
  <li>允许多个虚拟主机共享 httpd 配置</li>
  <li>有大量请求要处理，多个守护进程会损失过多性能</li>
</ul>

<h3 id="多守护进程的配置">多守护进程的配置</h3>

<p>为每个虚拟主机单独安装一个 httpd，在各自的配置文件中用 <code class="highlighter-rouge">Listen</code> 指令指定该守护进程所侦听的地址/端口。如：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">192</span>.<span class="m">0</span>.<span class="m">2</span>.<span class="m">100</span>:<span class="m">80</span>
</code></pre></div></div>

<p class="notice--info">强烈建议在此处使用 IP 地址，而不要使用域名。原因见 <a href="https://httpd.apache.org/docs/2.4/dns-caveats.html">DNS caveats</a>。</p>

<h3 id="单守护进程的配置">单守护进程的配置</h3>

<p>单一的守护进程处理所有对主服务器和虚拟主机的请求。</p>

<p>在 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 容器中可以使用 <code class="highlighter-rouge">ServerAdmin</code>、<code class="highlighter-rouge">ServerName</code>、<code class="highlighter-rouge">DocumentRoot</code>、<code class="highlighter-rouge">ErrorLog</code>、<code class="highlighter-rouge">TransferLog</code>、<code class="highlighter-rouge">CustomLog</code> 指令来配置。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">80</span>&gt;
    <span class="n">ServerAdmin</span> <span class="n">webmaster</span>@<span class="n">www1</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/vhosts/www1"</span>
    <span class="n">ServerName</span> <span class="n">www1</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">ErrorLog</span> <span class="s2">"/www/logs/www1/error_log"</span>
    <span class="n">CustomLog</span> <span class="s2">"/www/logs/www1/access_log"</span> <span class="n">combined</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>:<span class="m">80</span>&gt;
    <span class="n">ServerAdmin</span> <span class="n">webmaster</span>@<span class="n">www2</span>.<span class="n">example</span>.<span class="n">org</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/vhosts/www2"</span>
    <span class="n">ServerName</span> <span class="n">www2</span>.<span class="n">example</span>.<span class="n">org</span>
    <span class="n">ErrorLog</span> <span class="s2">"/www/logs/www2/error_log"</span>
    <span class="n">CustomLog</span> <span class="s2">"/www/logs/www2/access_log"</span> <span class="n">combined</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>同样，此处也建议只用 IP 地址来侦听，而不要使用域名。</p>

<p>就优先级而言，具体的侦听 IP 地址要比通配符更优先解析。同时，任何匹配的虚拟主机都要比主配置中的服务器优先解析。</p>

<p>##　虚拟主机范例</p>

<p>为简化文字，下文中 “地址” 专指 IP 地址。</p>

<h3 id="一个地址-运行-多个基于域名网站">一个地址 运行 多个基于域名网站</h3>

<p>服务器上有多个域名解析到同一个地址,希望对 www.example.com 和 www.example.org 给予不同的响应。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确保侦听 80 端口
</span><span class="n">Listen</span> <span class="m">80</span>
&lt;<span class="n">VirtualHost</span> *:<span class="m">80</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example1"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>

    <span class="c"># 其它指令......
</span>&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> *:<span class="m">80</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>

    <span class="c"># 其它指令......
</span>&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p class="notice--info">侦听表达式中的星号 <code class="highlighter-rouge">*</code> 匹配所有地址，因此主配置中的服务器肯定不会匹配。因为 <code class="highlighter-rouge">ServerName www.example.com</code> 是配置文件中的第一个虚拟主机，因此它看作 <strong>默认主机</strong>，具有 <strong>最高优先级</strong>。意味着收到的请求如果不匹配任何一个虚拟主机，就会用默认主机来处理。</p>

<p>以上配置几乎适用于任何基于域名的虚拟主机配置，唯一不适用的情况就是：基于不同的 IP 地址/端口提供不同的内容时。</p>

<p>可以把通配符换成系统中具体的 IP 地址，这样的虚拟主机只能匹配那些从特定 IP 地址收到的 HTTP 请求。</p>

<p>使用通配符 <code class="highlighter-rouge">*</code> 最大的用处就是用在动态 IP 地址的系统中。比如接入 ISP 网络的路由器，然后使用动态 DNS 解析服务。因为 <code class="highlighter-rouge">*</code> 会匹配任何地址，所以不管变成什么地址，该配置都能正常工作。</p>

<h3 id="多个地址-运行-多个基于域名的网站">多个地址 运行 多个基于域名的网站</h3>

<p>假设服务器有两个 IP 地址，在 <code class="highlighter-rouge">172.20.30.40</code> 上，运行主服务器 server.example.com，在 <code class="highlighter-rouge">172.20.30.50</code> 上运行多个虚拟主机。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">80</span>

<span class="c"># 此处为运行于 172.20.30.40 的主服务器
</span><span class="n">ServerName</span> <span class="n">server</span>.<span class="n">example</span>.<span class="n">com</span>
<span class="n">DocumentRoot</span> <span class="s2">"/www/mainserver"</span>

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example1"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>

    <span class="c"># 其它指令......
</span>&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>

    <span class="c"># 其它指令......
</span>&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>只要不是针对 172.20.30.50 的请求，都由主服务器来服务。对于指向 172.20.30.50 的请求，如果主机名未知，或请求中没有 <code class="highlighter-rouge">Host:</code> 标头，则会由默认主机，即 www.example.com 来服务。</p>

<h3 id="多个地址-运行-一个网站">多个地址 运行 一个网站</h3>

<p>操作系统有两个 IP 地址：192.168.1.1 和 172.20.30.40。该机器位于内网和外网之间。</p>

<p>面对外网，域名 server.example.com 会解析到地址 172.20.30.40；而面对内网，同一个域名则会解析到地址 192.168.1.1。</p>

<p>可以把服务器配置成无论响应内网还是外网的请求，都提供相同的网页内容，只需要一个 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 容器：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="m">192</span>.<span class="m">168</span>.<span class="m">1</span>.<span class="m">1</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/server1"</span>
    <span class="n">ServerName</span> <span class="n">server</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">ServerAlias</span> <span class="n">server</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>这样，从哪个方向来的请求都会用这个容器来处理。</p>

<p>另外，在内网中可以直接使用 <code class="highlighter-rouge">server</code> 这个服务器别名来访问，无需用完整的域名 server.example.com。</p>

<p>上例中，如果把 IP 地址换成通配符 <code class="highlighter-rouge">*</code>，服务器会对所有地址提供相同的网站。</p>

<h3 id="多个端口-运行-多个网站">多个端口 运行 多个网站</h3>

<p>多个域名使用同一个 IP 地址、不同端口。</p>

<p>以下范例中，先匹配的是服务器的 IP 地址/端口，然后才进一步匹配域名。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">80</span>
<span class="n">Listen</span> <span class="m">8080</span>

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">80</span>&gt;
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/domain-80"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">8080</span>&gt;
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/domain-8080"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">80</span>&gt;
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/otherdomain-80"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">8080</span>&gt;
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
    <span class="n">DocumentRoot</span> <span class="s2">"/www/otherdomain-8080"</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<h3 id="基于地址的虚拟主机">基于地址的虚拟主机</h3>

<p>服务器有两个 IP 地址 172.20.30.40 和 172.20.30.50，分析解析到 www.example.com 和 www.example.org。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">80</span>

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example1"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<h3 id="基于端口-和-基于地址-的混合使用">基于端口 和 基于地址 的混合使用</h3>

<p>服务器有两个地址 172.20.30.40 和 172.20.30.50，分别解析到 www.example.com 和 www.example.org。对每个地址都会分别使用端口 80 和 8080。这样，就共有四个虚拟主机的配置。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">80</span>
<span class="n">Listen</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">8080</span>
<span class="n">Listen</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>:<span class="m">80</span>
<span class="n">Listen</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>:<span class="m">8080</span>

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">80</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example1-80"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>:<span class="m">8080</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example1-8080"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>:<span class="m">80</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2-80"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>:<span class="m">8080</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2-8080"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<h3 id="基于域名-和-基于地址-混合使用">基于域名 和 基于地址 混合使用</h3>

<p>如果在虚拟主机的参数中出现的地址，再没有出现在其它虚拟主机中，这就是严格意义上的基于 IP 地址的虚拟主机。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">80</span>
&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example1"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example3"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">net</span>
&lt;/<span class="n">VirtualHost</span>&gt;

<span class="c"># 基于 IP 地址
</span>&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example4"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">edu</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">60</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example5"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">gov</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<h3 id="虚拟主机用做-反向代理">虚拟主机用做 反向代理</h3>

<p>配置虚拟主机作反向代理，需要与 <code class="highlighter-rouge">mod_proxy</code> 模块一起使用。</p>

<p><img src="/assets/images/reverse.proxy.png" alt="image-center" class="align-center" /></p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> *:*&gt;
    <span class="n">ProxyPreserveHost</span> <span class="n">On</span>
    <span class="n">ProxyPass</span>        <span class="s2">"/"</span> <span class="s2">"http://192.168.111.2/"</span>
    <span class="n">ProxyPassReverse</span> <span class="s2">"/"</span> <span class="s2">"http://192.168.111.2/"</span>
    <span class="n">ServerName</span> <span class="n">hostname</span>.<span class="n">example</span>.<span class="n">com</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>上例中所有指令解释如下：</p>

<h5 id="virtualhost-"><code class="highlighter-rouge">&lt;VirtualHost *:*&gt;</code></h5>

<p>匹配所有地址/端口。</p>

<h5 id="proxypreservehost-on"><code class="highlighter-rouge">ProxyPreserveHost On</code></h5>

<p>通过该指令，Apache 会将用户请求报文中 <strong>原始的 <code class="highlighter-rouge">Host:</code> 标头</strong> 传递给后端服务器，而不会使用 <code class="highlighter-rouge">ProxyPass</code> 指定的服务器地址。这非常有用，因为它让后端服务器了解了客户端用于访问应用程序的原始、真实地址。</p>

<h5 id="proxypass"><code class="highlighter-rouge">ProxyPass</code></h5>

<p>语法：</p>

<p><code class="highlighter-rouge">ProxyPass [path] !|url [key=value [key=value ...]] [nocanon] [interpolate] [noquery]</code></p>

<p class="notice">ProxyPass 是主要的代理配置指令，它的作用是把后端服务器 <strong>映射</strong> 到本地服务器的空间中。本地服务器扮演的不是传统意义上的代理，而是作为后端服务器的一个 <strong>镜像</strong> 存在。<code class="highlighter-rouge">path</code> 是一个本地虚拟路径，<code class="highlighter-rouge">url</code> 是后端服务器 URL 的一部分，不能包含查询字符串。</p>

<p>本例中，<code class="highlighter-rouge">"/"</code> 为当前服务器的虚拟路径，<code class="highlighter-rouge">"http://192.168.111.2/"</code> 为后端服务器的虚拟路径。即所有访问 hostname.example.com 的请求都会被 apache 转发给 http://192.168.111.2/，注意后端服务器网址中最后的 <strong>斜线 <code class="highlighter-rouge">/</code></strong> 是必须要有的，因为要与前面的 <code class="highlighter-rouge">/</code> 相对应。</p>

<h5 id="proxypassreverse"><code class="highlighter-rouge">ProxyPassReverse</code></h5>

<p>该指令一般和 <code class="highlighter-rouge">ProxyPass</code> 指令配合使用，它会让 Apache 调整 HTTP 重定向应答中 <code class="highlighter-rouge">Location</code>、<code class="highlighter-rouge">Content-Location</code>、<code class="highlighter-rouge">URI</code> 标头中的 URL，这样可以避免出现 “重定向到后端服务器导致反向代理被绕过的” 问题。</p>

<p>只有该指令指定的 HTTP 应答标头会被重写。</p>

<h3 id="使用-_default_-虚拟主机">使用 <code class="highlighter-rouge">_default_</code> 虚拟主机</h3>

<h4 id="在所有端口的-_default_">在所有端口的 <code class="highlighter-rouge">_default_</code></h4>

<p>该虚拟主机用于捕捉那些 <strong>未定义 IP 地址/端口的请求</strong>。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="err">_</span><span class="n">default_</span>:*&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/default"</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>用这种虚拟主机可以有效避免所有请求去往主服务器。</p>

<p>只要请求中有明确的地址/端口，就不会由这个虚拟主机处理。</p>

<p>如果请求中只是没有域名或没有 <code class="highlighter-rouge">Host:</code> 标头，则由匹配的基于域名的第一个虚拟主机处理。</p>

<h4 id="在不同端口的-_default_">在不同端口的 <code class="highlighter-rouge">_default_</code></h4>

<p>服务器运行于多个端口，现在要为 80 端口使用第二个 <code class="highlighter-rouge">_default_</code> 虚拟主机。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="err">_</span><span class="n">default_</span>:<span class="m">80</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/default80"</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="err">_</span><span class="n">default_</span>:*&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/default"</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>匹配 80 端口的默认虚拟主机必须出现在所有带通配符端口的默认虚拟主机之前，它会捕捉所有发送到未指定 IP 地址的请求，永远不会使用主服务器来处理。</p>

<h4 id="在一个端口的-_default_">在一个端口的 <code class="highlighter-rouge">_default_</code></h4>

<p>只希望为 80 端口做一个默认虚拟主机，不要其它默认主机。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="err">_</span><span class="n">default_</span>:<span class="m">80</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/default"</span>
...
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>80 端口上未指定地址的请求会由该虚拟主机处理，所有其它的未指定地址和端口的请求会由主服务器处理。</p>

<p class="notice--success">所有使用 <code class="highlighter-rouge">*</code> 的虚拟主机声明，其优先级均高于 <code class="highlighter-rouge">_default_</code>。</p>

<h3 id="基于域名-迁移到-基于-ip">基于域名 迁移到 基于 IP</h3>

<p>某虚拟主机更换了 <strong>新的 IP 地址</strong>，希望平滑过渡。</p>

<p>基于域名的虚拟主机 www.example.org 应该有它自己的 IP 地址。为了避免域名解析服务器的问题，或防止代理服务器缓存中保存了旧的 IP 地址，可以在把基于域名 <strong>迁移</strong> 到基于 IP 期间，直接在原 IP 地址后面加上新地址，过渡期间同时使用两个地址。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Listen</span> <span class="m">80</span>
<span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">com</span>
<span class="n">DocumentRoot</span> <span class="s2">"/www/example1"</span>

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">50</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example2"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">org</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/example3"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">example</span>.<span class="n">net</span>
    <span class="n">ServerAlias</span> *.<span class="n">example</span>.<span class="n">net</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<h3 id="serverpath-指令"><code class="highlighter-rouge">ServerPath</code> 指令</h3>

<p>服务器现在有两个基于域名的虚拟主机，为了匹配正确的虚拟主机，客户端必须发送正确的 <code class="highlighter-rouge">Host:</code> 标头。较早的 HTTP/1.0 的客户端不会发送这个标头，apache 就无从知道它想访问哪个虚拟主机，于是会用主虚拟主机来服务。为了尽可能地 <strong>与低版本兼容</strong>，可以创建一个 <strong>主虚拟主机</strong> ，它会返回一个页面，其中包含指向各基于域名虚拟主机的链接。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="c"># 主虚拟主机
</span>    <span class="n">DocumentRoot</span> <span class="s2">"/www/subdomain"</span>
    <span class="n">RewriteEngine</span> <span class="n">On</span>
    <span class="n">RewriteRule</span> <span class="s2">"."</span> <span class="s2">"/www/subdomain/index.html"</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/subdomain/sub1"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">sub1</span>.<span class="n">domain</span>.<span class="n">tld</span>
    <span class="n">ServerPath</span> <span class="s2">"/sub1/"</span>
    <span class="n">RewriteEngine</span> <span class="n">On</span>
    <span class="n">RewriteRule</span> <span class="s2">"^(/sub1/.*)"</span> <span class="s2">"/www/subdomain$1"</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">172</span>.<span class="m">20</span>.<span class="m">30</span>.<span class="m">40</span>&gt;
    <span class="n">DocumentRoot</span> <span class="s2">"/www/subdomain/sub2"</span>
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">sub2</span>.<span class="n">domain</span>.<span class="n">tld</span>
    <span class="n">ServerPath</span> <span class="s2">"/sub2/"</span>
    <span class="n">RewriteEngine</span> <span class="n">On</span>
    <span class="n">RewriteRule</span> <span class="s2">"^(/sub2/.*)"</span> <span class="s2">"/www/subdomain$1"</span>
    <span class="c"># ...
</span>&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>因为设置了 <code class="highlighter-rouge">ServerPath</code> 指令，针对 http://www.sub1.domain.tld/sub1/ 的请求始终会由 sub1 这个虚拟主机来服务。</p>

<p>如果请求是针对 http://www.sub1.domain.tld/ 的，在客户端发送了 <code class="highlighter-rouge">Host:</code> 标头的情况下，由 sub1 服务；要是没有 <code class="highlighter-rouge">Host:</code> 标头，则由主虚拟主机服务。</p>

<p class="notice--primary">请注意，比较诡异的是，如果客户端没有发送 <code class="highlighter-rouge">Host:</code> 标头，针对 http://www.sub2.domain.tld/sub1/ 的请求也会由 sub1 来服务，</p>

<p><code class="highlighter-rouge">RewriteRule</code> 指令用于确保发送了 <code class="highlighter-rouge">Host:</code> 标头的客户端可以同时使用两种 URL，即一种是有 URL 前缀，一种是没有的。</p>

<h2 id="文件描述符的限制">文件描述符的限制</h2>

<p>文件描述符有时也称为文件句柄。</p>

<p>当使用了大量虚拟主机，而且每个主机又使用了不同的日志文件时，Apache 可能会遭遇文件描述符耗尽的困境。Apache 使用的文件描述符总数如下：每个不同的错误日志文件一个、每个其他日志文件指令一个、再加 10~20 个作为内部使用。Unix 操作系统限制了每个进程可以使用的文件描述符数量。典型上限是 64 个，但可以进行扩充，直至到达一个很大的硬件限制为止（hard-limi）。</p>

<p>尽管 Apache 会试着增大限制，但如果发生以下情况，则这个机制无法起作用：</p>

<ol>
  <li>操作系统没有提供 <code class="highlighter-rouge">setrlimit()</code> 系统调用</li>
  <li><code class="highlighter-rouge">setrlimit(RLIMIT_NOFILE)</code> 调用无法在系统上正常工作（比如 Solaris 2.3）</li>
  <li>文件描述符的需求量已经超出了硬件的限制</li>
  <li>操作系统对文件描述符作出了其他限制。比如说限制了 stdio 流只能使用 256 以下的文件描述符。(Solaris 2)</li>
</ol>

<p>如果遇到了这样的问题，可以这样解决：</p>

<ul>
  <li>减少日志文件的数量。不在 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 配置段中指定日志文件，只在主日志文件中进行记录。</li>
  <li>如果系统因上述第 1 条或第 2 条原因不能正常工作，可以在启动 Apache 之前，用类似下述的脚本增大文件描述符的限制：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="nb">ulimit</span> <span class="nt">-S</span> <span class="nt">-n</span> 100
<span class="nb">exec </span>httpd
</code></pre></div></div>

<h3 id="分解日志文件">分解日志文件</h3>

<p>要想把多个虚拟主机的日志记录到同一个日志文件中，可能会想事后把它们分开，以对不同的虚拟主机数据进行统计分析。可用以下方法达到这个目的。</p>

<p>首先，将虚拟主机的信息放入日志中。可以用 <code class="highlighter-rouge">LogFormat</code> 指令和 <code class="highlighter-rouge">%v</code> 变量达到这个目的。在日志格式串的开头加入 <code class="highlighter-rouge">%v</code>：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LogFormat</span> <span class="s2">"%v %h %l %u %t \"</span>%<span class="n">r</span>\<span class="s2">" %&gt;s %b"</span> <span class="n">vhost</span>
<span class="n">CustomLog</span> <span class="n">logs</span>/<span class="n">multiple_vhost_log</span> <span class="n">vhost</span>
</code></pre></div></div>

<p>这将用日志的普通格式来创建一个日志文件。但会在每条记录前加上正式的虚拟主机名，即 <code class="highlighter-rouge">ServerName</code> 指令所设定的值。</p>

<p>要想把日志文件分开，每个虚拟主机一个日志文件，可以使用 <code class="highlighter-rouge">awk</code> 程序来完成这个工作。</p>

<h3 id="动态配置海量虚拟主机">动态配置海量虚拟主机</h3>

<h4 id="动机">动机</h4>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;<span class="n">VirtualHost</span> <span class="m">111</span>.<span class="m">22</span>.<span class="m">33</span>.<span class="m">44</span>&gt;
    <span class="n">ServerName</span>                 <span class="n">customer</span>-<span class="m">1</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span>        <span class="s2">"/www/hosts/customer-1.example.com/docs"</span>
    <span class="n">ScriptAlias</span>  <span class="s2">"/cgi-bin/"</span>  <span class="s2">"/www/hosts/customer-1.example.com/cgi-bin"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">111</span>.<span class="m">22</span>.<span class="m">33</span>.<span class="m">44</span>&gt;
    <span class="n">ServerName</span>                 <span class="n">customer</span>-<span class="m">2</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span>        <span class="s2">"/www/hosts/customer-2.example.com/docs"</span>
    <span class="n">ScriptAlias</span>  <span class="s2">"/cgi-bin/"</span>  <span class="s2">"/www/hosts/customer-2.example.com/cgi-bin"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">111</span>.<span class="m">22</span>.<span class="m">33</span>.<span class="m">44</span>&gt;
    <span class="n">ServerName</span>                 <span class="n">customer</span>-<span class="n">N</span>.<span class="n">example</span>.<span class="n">com</span>
    <span class="n">DocumentRoot</span>        <span class="s2">"/www/hosts/customer-N.example.com/docs"</span>
    <span class="n">ScriptAlias</span>  <span class="s2">"/cgi-bin/"</span>  <span class="s2">"/www/hosts/customer-N.example.com/cgi-bin"</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<p>如果主配置文件中有许多个虚拟主机时，我们可能希望把这么多的容器替换成一种更简单的、动态的算法，这样做有两个好处：</p>

<ul>
  <li>配置文件更小，因此 apache 可以更快速地启动，会占用更少的内存。小的配置文件更容易维护，不易出错。</li>
  <li>增加虚拟主机，只需要在文件系统创建对应的目录即可，同时创建 DNS 条目，无需重新配置或重启 apache。</li>
</ul>

<p>主要的弊端在于，无法为每个虚拟主机分配单独的日志文件。然而，即使真可以的话，这么做也不是个好主意，因为这么多日志需要大量的文件描述符。最好的办法还是把日志记录到管道，在管道另一端把不同虚拟主机的日志拆分开。</p>

<h4 id="如何动态配置">如何动态配置</h4>

<p class="notice">一个虚拟主机是由两条信息定义的：其 IP 地址，以及 HTTP 请求中 <code class="highlighter-rouge">Host:</code> 标头的内容。</p>

<p>可以自动把该信息插入返回的文件的路径中，动态海量虚拟主机技术正是基于这个想法实现的。通过使用 <code class="highlighter-rouge">mod_vhost_alias</code> 可以轻松做到，或者，也可以使用 <code class="highlighter-rouge">mod_rewrite</code>。</p>

<p>这两个模块在默认都是禁用的，要想使用，必须在配置和编译 Apache 时启用。</p>

<p>要想动态虚拟主机正常运转，需要从请求中判断一些信息。最重要的是 <strong>服务器域名</strong>，服务器用来生成自引用的 URL 等。域名是由 <code class="highlighter-rouge">ServerName</code> 指令配置的，CGI 要想使用可以通过 <code class="highlighter-rouge">SERVER_NAME</code> 环境变量来获取。在运行时真正使用的值是由 <code class="highlighter-rouge">UseCanonicalName</code> 控制的，如果是 <code class="highlighter-rouge">UseCanonicalName Off</code>，服务器的域名就从请求的 <code class="highlighter-rouge">Host:</code> 标头的内容获取；如果是 <code class="highlighter-rouge">UseCanonicalName DNS</code>，则通过对虚拟主机的 IP 地址的反向 DNS 解析获取。前者用于基于域名的动态虚拟主机，后者用于基于 IP 的。如果因为没有 <code class="highlighter-rouge">Host:</code> 标头而导致 httpd 无法查明服务器域名，或者 DNS 解析失败，则会使用 <code class="highlighter-rouge">ServerName</code> 指定的值。</p>

<p>另一个要判断的是 <strong>文档根目录</strong>，由 <code class="highlighter-rouge">DocumentRoot</code> 指定，CGI 可以通过 <code class="highlighter-rouge">DOCUMENT_ROOT</code> 环境变量来获取。在普通的配置中，httpd 内核模块通过它来把 URI 映射到文件名，但如果是动态配置，这个工作必须由另一个模块来接管，可以是 <code class="highlighter-rouge">mod_vhost_alias</code> 或 <code class="highlighter-rouge">mod_rewrite</code>，它们有自己不同的映射的方法。这两个模块都不会为变量 <code class="highlighter-rouge">DOCUMENT_ROOT</code> 赋值，因此 CGI 和 SSI 都无法正确使用。</p>

<h4 id="mod_vhost_alias"><code class="highlighter-rouge">mod_vhost_alias</code></h4>

<p>上面的范例使用 <code class="highlighter-rouge">mod_vhost_alias</code> 抽象化之后：</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 从 Host: 标头获取服务器域名
</span><span class="n">UseCanonicalName</span> <span class="n">Off</span>

<span class="c"># 可以基于第一个字段把该日志格式按虚拟主机拆分
</span><span class="n">LogFormat</span> <span class="s2">"%V %h %l %u %t \"</span>%<span class="n">r</span>\<span class="s2">" %s %b"</span> <span class="n">vcommon</span>
<span class="n">CustomLog</span> <span class="s2">"logs/access_log"</span> <span class="n">vcommon</span>

<span class="c"># 把服务器域名置入文件名中，用来匹配请求
</span><span class="n">VirtualDocumentRoot</span> <span class="s2">"/www/hosts/%0/docs"</span>
<span class="n">VirtualScriptAlias</span>  <span class="s2">"/www/hosts/%0/cgi-bin"</span>
</code></pre></div></div>

<p>该配置可以修改为基于 IP 的，只需把 <code class="highlighter-rouge">UseCanonicalName</code> 从 <code class="highlighter-rouge">Off</code> 改成 <code class="highlighter-rouge">DNS</code>。服务器域名就不用插入文件名中了，而是由 IP 地址派生出来。变量 <code class="highlighter-rouge">%0</code> 将引用请求的服务器域名，从 <code class="highlighter-rouge">Host:</code> 标头中获取。</p>

<h4 id="简单的动态虚拟主机">简单的动态虚拟主机</h4>

<p>这是对上述系统的调整, 为 ISP 的 web 托管服务器量身定做。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UseCanonicalName</span> <span class="n">Off</span>

<span class="n">LogFormat</span> <span class="s2">"%V %h %l %u %t \"</span>%<span class="n">r</span>\<span class="s2">" %s %b"</span> <span class="n">vcommon</span>
<span class="n">CustomLog</span> <span class="s2">"logs/access_log"</span> <span class="n">vcommon</span>

<span class="c"># 在路径中插入域名中部分字段
</span><span class="n">VirtualDocumentRoot</span> <span class="s2">"/home/%2/www"</span>

<span class="c"># 统一的 cgi-bin 目录
</span><span class="n">ScriptAlias</span>  <span class="s2">"/cgi-bin/"</span>  <span class="s2">"/www/std-cgi/"</span>
</code></pre></div></div>

<p>用变量 <code class="highlighter-rouge">%2</code> 可以选择域名中的第 2 个字段，用于路径名。因此，www.user.example.com 的内容可对应的路径是 <code class="highlighter-rouge">/home/user/www</code>。使用统一的 <code class="highlighter-rouge">cgi-bin</code> 目录，而不是每虚拟机一个。</p>

<h4 id="在同一服务器上使用多个虚拟主机系统">在同一服务器上使用多个虚拟主机系统</h4>

<p>更复杂一些的配置，可以用 httpd 的普通的 <code class="highlighter-rouge">&lt;VirtualHost&gt;</code> 指令来控制各个虚拟主机配置的作用域。</p>

<p>例如，可以配置一个 IP 地址给普通客户的页面，另一个用于商业客户。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UseCanonicalName</span> <span class="n">Off</span>

<span class="n">LogFormat</span> <span class="s2">"%V %h %l %u %t \"</span>%<span class="n">r</span>\<span class="s2">" %s %b"</span> <span class="n">vcommon</span>

&lt;<span class="n">Directory</span> <span class="s2">"/www/commercial"</span>&gt;
    <span class="n">Options</span> <span class="n">FollowSymLinks</span>
    <span class="n">AllowOverride</span> <span class="n">All</span>
&lt;/<span class="n">Directory</span>&gt;

&lt;<span class="n">Directory</span> <span class="s2">"/www/homepages"</span>&gt;
    <span class="n">Options</span> <span class="n">FollowSymLinks</span>
    <span class="n">AllowOverride</span> <span class="n">None</span>
&lt;/<span class="n">Directory</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">111</span>.<span class="m">22</span>.<span class="m">33</span>.<span class="m">44</span>&gt;
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">commercial</span>.<span class="n">example</span>.<span class="n">com</span>

    <span class="n">CustomLog</span> <span class="s2">"logs/access_log.commercial"</span> <span class="n">vcommon</span>

    <span class="n">VirtualDocumentRoot</span> <span class="s2">"/www/commercial/%0/docs"</span>
    <span class="n">VirtualScriptAlias</span>  <span class="s2">"/www/commercial/%0/cgi-bin"</span>
&lt;/<span class="n">VirtualHost</span>&gt;

&lt;<span class="n">VirtualHost</span> <span class="m">111</span>.<span class="m">22</span>.<span class="m">33</span>.<span class="m">45</span>&gt;
    <span class="n">ServerName</span> <span class="n">www</span>.<span class="n">homepages</span>.<span class="n">example</span>.<span class="n">com</span>

    <span class="n">CustomLog</span> <span class="s2">"logs/access_log.homepages"</span> <span class="n">vcommon</span>

    <span class="n">VirtualDocumentRoot</span> <span class="s2">"/www/homepages/%0/docs"</span>
    <span class="n">ScriptAlias</span>         <span class="s2">"/cgi-bin/"</span> <span class="s2">"/www/std-cgi/"</span>
&lt;/<span class="n">VirtualHost</span>&gt;
</code></pre></div></div>

<h4 id="更高效的基于-ip-虚拟主机">更高效的基于 IP 虚拟主机</h4>

<p>如果要改成基于 IP 的虚拟主机，会需要频繁的 DNS 解析，势必增加开销。为了解决这个问题，文件系统可以配置为针对 IP 地址进行响应，而非域名，不再需要 DNS 解析了。日志格式也需要做适当调整。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># get the server name from the reverse DNS of the IP address
</span><span class="n">UseCanonicalName</span> <span class="n">DNS</span>

<span class="c"># include the IP address in the logs so they may be split
</span><span class="n">LogFormat</span> <span class="s2">"%A %h %l %u %t \"</span>%<span class="n">r</span>\<span class="s2">" %s %b"</span> <span class="n">vcommon</span>
<span class="n">CustomLog</span> <span class="s2">"logs/access_log"</span> <span class="n">vcommon</span>

<span class="c"># include the IP address in the filenames
</span><span class="n">VirtualDocumentRootIP</span> <span class="s2">"/www/hosts/%0/docs"</span>
<span class="n">VirtualScriptAliasIP</span>  <span class="s2">"/www/hosts/%0/cgi-bin"</span>
</code></pre></div></div>

        
      </section>




      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
	<hr />
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
		
      <a href="/tag/apache" class="page__taxonomy-item" rel="tag">apache</a><span class="sep">  </span>
    
		
      <a href="/tag/虚拟主机" class="page__taxonomy-item" rel="tag">虚拟主机</a>
    
    </span>
  </p>













  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
	<!--  <hr />    -->
    <span itemprop="keywords">
    
      
      
      <a href="https://liloli.github.io/categories/#server" class="page__taxonomy-item" rel="tag">server</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2016-01-02T00:00:00+08:00">January 02, 2016</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  <a href="https://twitter.com/intent/tweet?via=liloli&text=Apache+%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%20https%3A%2F%2Fliloli.github.io%2Fserver%2Fvhost%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fliloli.github.io%2Fserver%2Fvhost%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=https%3A%2F%2Fliloli.github.io%2Fserver%2Fvhost%2F" class="btn btn--google-plus" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Google Plus"><i class="fab fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fliloli.github.io%2Fserver%2Fvhost%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="https://liloli.github.io/server/reverse.proxy/" class="pagination--pager" title="Apache 反向代理指南
">向前</a>
    
    
      <a href="https://liloli.github.io/server/nginx_basic/" class="pagination--pager" title="Nginx 基本功能
">向后</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/time/" rel="permalink">Bash 脚本 - 时间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/storage/" rel="permalink">Bash 脚本 - 存储空间
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/numbers/" rel="permalink">Bash 脚本 - 数字
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="https://liloli.github.io/bash/input/" rel="permalink">Bash 脚本 - 输入
</a>
      
    </h2>
    
    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>
        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap">
  <input type="text" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  <div id="results" class="results"></div>
</div>
      </div>
    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->


<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
      <li><a href="https://twitter.com/liloli"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
      <li><a href="https://www.facebook.com/lilolibj"><i class="fab fa-fw fa-facebook-square" aria-hidden="true"></i> Facebook</a></li>
    
    
      <li><a href="https://github.com/liloli"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    <li><a href="https://liloli.github.io/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2018 Hawk Zhang. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://liloli.github.io/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>



  
  
  <script src="https://liloli.github.io/assets/js/lunr/lunr.min.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-store.js"></script>
  <script src="https://liloli.github.io/assets/js/lunr/lunr-en.js"></script>





    
  <script>
    var disqus_config = function () {
      this.page.url = "https://liloli.github.io/server/vhost/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/server/vhost"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://liloli.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  



  </body>
</html>
