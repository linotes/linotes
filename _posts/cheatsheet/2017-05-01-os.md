---
toc: true
toc_label: "运维速查 - 操作系统"
toc_icon: "copy"
title: "运维速查 - 操作系统"
tags: 速查 操作系统
categories: "cheatsheet"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/matrix2.jpg
  overlay_filter: rgba(0, 0, 0, 0.8)
---

## Linux 启动顺序

* BIOS
* MBR
* bootloader
* Linux 内核
* systemd
* 读取配置文件
* sysinit.target
* basic.target
* multi-user.target
* graphical.target











## 系统状态监控



### `uptime`

* 当前时间
* 本次启动后所运行的时间
* 已登陆用户数量
* 最近 1 分钟、5 分钟、15 分钟内系统平均负载



### `w`

* 当前时间
* 系统已运行时间
* 已登陆用户：用户名，TTY，远端主机，登陆时间，空闲时间，当前进程
* 登陆用户产生的进程



### `top`

**动态、实时** 查看当前系统状态。

该命令显示的信息内容很丰富，显示的界面中，每一块都由一个或多个命令来控制。

#### 启动时间 及 平均负载

```
top - 16:10:22 up  8:59,  2 users,  load average: 0.00, 0.01, 0.05
```

这部分内容为一行，内容与 `uptime` 返回的结果相同：

* 当前时间
* 本次启动后所运行的时间
* 当前登陆用户数量
* 最近 1 分钟、5 分钟、15 分钟内系统平均负载

#### 任务 及 CPU 状态

```
Tasks: 173 total,   1 running, 172 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.1 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
```

这部分内容至少为两行。在多处理器环境，会显示更多的行。

第一行：总任务数，即总线程数。以及分别处理运行、睡眠、暂停、僵尸状态的数量。

第二行：本次刷新前，在刷新间隔时间内 CPU 的平均状态，默认用百分比来表示。

`us` ：user，运行 un-niced 用户进程的时间

`sy` ：system，运行内核进程的时间

`ni` ：nice，运行 niced 用户进程的时间

`id` ：idle，内核空闲处理器所用的时间

`wa` ：IO-wait，等待 I/O 完成所用的时间

`hi` ：Hardware Interrupt，用于硬件中断的时间

`si` ：Software Interrupt，用于软件中断的时间

`st` ：Steal Time，虚拟 CPU 等待实体 CPU 分配时间片的机率，越大，性能越差

#### 内存占用

这部分内容占两行。

```
KiB Mem :   999964 total,    69656 free,   670256 used,   260052 buff/cache
KiB Swap:  1048572 total,  1042664 free,     5908 used.   113800 avail Mem
```

第一行为物理内存：总量，可用量，已用量，缓冲区大小

第二行为虚拟内存：总量，可用量，已用量，物理可用量

第二行的 `avail` 是物理内存中，可用来启动程序的可用内存的估值。它与 `free` 不同，还要算上可回收的页面缓存和内存片。

#### 进程列表

这部分显示的是当前可用进程的列表。

所有可用的字段有很多，默认只显示了一部分，可以按 `F` 键进入交互设定界面。在这里可以设定显示哪些字段，还可以自定义字段的显示顺序。可以选择按哪个字段进行排序。

在查看界面，可以按 `e` 来切换所用的单位。

```
PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                
  1 root      20   0  193628   4980   2944 S   0.0  0.5   0:03.00 systemd                                
  2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd                               
  3 root      20   0       0      0      0 S   0.0  0.0   0:00.01 ksoftirqd/0   
```











## 进程



### 查看当前进程列表

`ps aux` 和 `ps -ef ` 两者的输出结果差别不大，但显示风格不同。

* aux 是 BSD 风格，-ef 是 System V 风格
* aux 会截断 command 列，而 -ef 不会

```bash
$ ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.5 193628  5092 ?        Ss   06:58   0:03 /usr/lib/systemd/systemd --switched-root --
root          2  0.0  0.0      0     0 ?        S    06:58   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        S    06:58   0:00 [ksoftirqd/0]
... ...
```

`VSZ`: 进程占用的 **虚拟内存空间**

`RSS`: 进程占用的 **实际物理内存空间**

```bash
$ ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 15:16 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system --deseria
root          2      0  0 15:16 ?        00:00:00 [kthreadd]
root          3      2  0 15:16 ?        00:00:00 [ksoftirqd/0]
```



### 查看进程来源

根据 PID 查看进程是由 **哪个应用程序产生的**：

```bash
$ sudo ls -l /proc/2232/exe
lrwxrwxrwx. 1 root root 0 Sep  7 15:18 /proc/2322/exe -> /usr/sbin/mysqld
```



### `ps aux` 返回的结果中，VSZ、RSS 的含义

```bash
$ ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  1.1  0.5 171476 14476 ?        Ss   19:13   0:02 /usr/lib/systemd/systemd --switched-root --system
root          2  0.0  0.0      0     0 ?        S    19:13   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        I<   19:13   0:00 [rcu_gp]
```

`VSZ` ：virtual memory size，进程所占用的 **虚拟内存** 空间

`RSS` ：resident set size，进程占用的 **物理内存** 空间












## 用户



### 用脚本批量添加 20 个用户

要求：

用户名为 user01-20，密码为 “用户名 + 5 个随机字符”：

```bash
#!/bin/bash
for i in `seq -f "%02g" 1 20`
do
	useradd user$i
    echo "user$i `head -10 /dev/urandom | sha1sum | head -c 5`" | passwd -stdin user$i > /dev/null 2>&1
done
```

在命令替换中，使用 `seq` 的格式化参数 `"%02g"` 来实现以 0 开头的 2 位数字格式。

























































### 常用服务 / 工具


#### 解释 FTP 的主动模式和被动模式

主动还是被动是从 **服务端的角度** 来说的。主动模式中数据连接是由服务端发起的，而被动模式中则是由客户端发起的。

##### 主动模式

* 客户端从端口 C 连接到服务器端口 21，告知服务器自己的数据端口为 C+1；
* 服务器从端口 21 返回应答消息，**控制连接建立**；
* 服务器从端口 20 连接到客户端端口 C+1；
* 客户端返回应答消息，**数据连接建立**。

##### 被动模式

* 客户端从端口 C 连接到服务器端口 21，告知服务端自己使用 **被动模式**；
* 服务端返回应答消息，并告知自己数据端口号 S，**控制连接建立**；
* 客户端从 C+1 端口连接到服务器 S 端口；
* 服务端返回应答消息，**数据连接建立**。


#### 限制 apache 每秒新建连接数为 1，峰值为 3

每秒新建连接数需要用 iptables 来控制：

```bash
$ sudo iptables -A INPUT -d 192.168.1.10 -p tcp --dport 80 -m limit --limit 1/second -j ACCEPT
```

峰值就是 apache 同时可以处理的最多连接数，需要修改 apache 的配置文件 `/etc/httpd/conf/httpd.conf`：

```conf
MaxRequestWorkers 3
```

超过该限制之后，尝试建立的新连接，会进入等待队列，直到其它子进程被释放。



#### VI 快捷键

##### 复制行

* `yy` 复制当前行
* `8yy` 从本行起，向下复制 8 行

##### 粘贴行

* `p` 粘贴到当前行下面

##### 删除行

* `dd` 删除当前行
* `8dd` 从本行起，向下删除 8  行
* `d↑` 从本行起，向上删除 2 行
* `d5↑` 从本行起，向上删除 5 行

##### 删除全部

* 先按 `gg` 到首行，然后按 `dG` 删除所有行

##### 显示行号

* `:set nu`

##### 定位到行

* `:15` 定位到第 15 行
* `gg` 定位到首行
* `G` 定位到末行


#### Nginx 作为反向代理时，如何在日志中保存访客的真实 IP 地址？

修改对应的 Nginx 配置文件：

```conf
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
```

```bash
$ sudo nginx -s reload
```


#### LVS、Nginx、HAproxy 有什么区别？如何选择？

这三种软件均可以实现负载均衡。

##### LVS

Linux Virtual Server，负载均衡软件。

* 基于四层的转发
* 只能做端口的转发
* 抗负载能力强，适于并发量大的场景
* 工作稳定，自身有完整的双机热备方案
* 应用范围比较广，可以对所有应用做负载均衡
* 需要向 IDC 多申请一个 IP 来做 Virtual IP，因此需要一定的网络知识

##### Nginx

WEB 服务器，缓存服务器，反向代理服务器，多功能软件。

* 基于七层的转发，可以做基于 URL 和目录的转发
* 对网络的依赖比较小
* 安装和配置比较简单
* 可以承担较高的负载，可支撑超过 1 万次的并发
* 不支持 session 的保持

##### HAproxy

专业的代理服务器。

* 基于七层的转发
* 可以做基于 URL 和目录的转发
* 适于普通并发量的场景
* 支持 session 的保持

##### 选择

随着网站规模的提升根据不同的阶段来使用不同的技术：

###### 第一阶段：

利用 Nginx 或者 HAProxy 进行单点的负载均衡，这一阶段服务器规模刚脱离开单服务器、单数据库的模式，需要一定的负载均衡，但是仍然规模较小，没有专业的维护团队来进行维护，也没有需要进行大规模的网站部署。

上手快，配置简单，在七层上利用 HTTP 协议就可以实现。

###### 第二阶段：

随着网络服务进一步扩大，单点的 Nginx 已经无法满足，此时使用 LVS 或商用 F5 是选。Nginx 是作为 LVS 或 F5 的节点来使用。

###### 第三阶段：

随着网络服务成为主流产品，公司知名度进一步扩展，相关人才的能力以及数量也随之提升，这时无论从开发适合自身产品的定制考虑，还是从降低成本考虑，开源的 LVS 为首选。

最终形成比较理想的状态为：`F5/LVS` <—> `Haproxy` <—> `Squid/Varnish` <—> `AppServer`。


#### Squid、Varinsh 和 Nginx 有什么区别，如何选择？

Squid、Varinsh 和 Nginx 都是可以用来提供网站缓存服务。

##### Squid

* 专业的缓存软件
* 技术资料丰富


##### Varnish

* 专业的缓存软件
* 采用了可视化页面缓存技术，较高的技术优势
* 内存缓存，速度一流
* 因为是内存缓存，容量有限制
* 有强大的管理端口，可以使用正则表达式快速、批量地清除部分缓存

##### Nginx

* Nginx 是 WEB 服务器，使用第三方模块才可以提供缓存服务
* 只能缓存静态文件

##### 选择

优先选择专业的缓存服务 squid 或 varnish。












### 数据库


#### MySQL 如何重置 root 密码？

##### 已知 root 密码的情况

###### 在 shell 中修改

```bash
$















### ETC


#### 在 6-9 内取随机数

```bash
$ echo `expr $[RANDOM%4] + 6`
```
