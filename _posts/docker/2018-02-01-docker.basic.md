---
toc: true
toc_label: "Docker 简介"
toc_icon: "copy"
title: "Docker 简介"
tags: docker
categories: "virtualization"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/docker-cloud-twitter-card.png
  overlay_filter: rgba(0, 0, 0, 0.5)
---




## Docker 产生的背景








### 环境配置的难题

软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？

用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。

如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说："它在我的机器可以跑了"（It works on my machine），言下之意就是，其他机器很可能跑不了。

环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。












### 虚拟机

虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。

虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。

#### 资源占用多

虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。

#### 冗余步骤多

虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。

#### 启动慢

启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。













### Linux 容器

由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 **LXC**）。

**Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。** 或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

**容器** 原生运行于 Linux 中，并与其它的容器共享主机的内核。它以单独的进程运行，不会比其它可执行文件占用更多的内存，因此比较轻量。

相比之下，**虚拟机** 会运行一个完整的操作系统，该操作系统通过虚拟层对宿主的资源进行访问。通常比应用程序需要更多的资源来运行。




#### 容器的特点

容器化之所以愈发流行是因为容器的以下特点：

* 灵活：即使是最复杂的程序都可以被容器化
* 轻量：容器会利用并共享主机的内核
* 无缝：可以实时更新和升级
* 便携：可以在本地构建，部署到云端，随处运行
* 弹性：可以尽情扩展，自动发布容器的复本
* 可堆叠：可以把服务在线垂直堆叠

{% include figure image_path="/assets/images/docker.vs.vm.png" %}




#### 容器比虚拟机的优势

由于容器是进程级别的，相比虚拟机有很多优势。


##### 启动快

容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。


##### 资源占用少

容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。


##### 体积小

容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。



























## Docker 简介

Docker 属于 **Linux 容器的一种封装**，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。

总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。









### Docker 平台

Docker 是一个平台，开发人员与管理员可以在容器中进行 **开发**、**部署**、**运行** 应用程序。用 Linux 容器进行部署应用称为容器化。容器不是一个新概念，但将其用于简化应用的部署却是一个新的概念。

Linux 容器提供了一个宽松、隔离的环境，使用 Docker 可以在容器中运行应用程序，也可以将其完整打包。这种隔离性和安全性让我们可以在宿主机上同时运行多个容器。容器是轻量化的，因为它们没有虚拟层（hypervisor），从而不会带来附加的负载，可以在宿主机内核中直接运行。与虚拟机比起来，在同样的硬件条件下，可以运行更多的容器。甚至可以在虚拟机中运行 docker 容器。

Docker 提供一系列工具和一个平台，用来管理容器的整个生存周期：

* 用容器来开发程序及其支持组件
* 容器成为发布和测试应用的单元
* 一切就绪时，将应用以容器或服务的形式，部署到生产环境，无论生产环境是在本地的数据中心、云端还是二者的混合。










### Docker 引擎

Docker 引擎是一个 C/S 架构的应用，主要组件为：

* 服务端：dockerd 守护进程
* API：REST API，应用程序通过该接口与守护进程通信，通知其进行特定的操作
* 客户端：CLI 客户端，即 `docker` 命令

![image-center](/assets/images/engine-components-flow.png){: .align-center}

docker 的命令行客户端借助脚本或直接的命令，使用 REST API 来控制服务端。有许多其它的 docker 应用使用的是底层的 API 和 CLI。

Docker 守护进程会创建并管理 docker 对象，如镜像、容器、网络、映射卷等。

>REST API：Representational State Transfer is designed to take advantage of existing protocols. While REST can be used over nearly any protocol, it usually takes advantage of HTTP when used for Web APIs. This means that developers do not need to install libraries or additional software in order to take advantage of a REST API design.









### Docker 的用途




#### 对应用程序进行高速、一致的分发

Docker 简化了开发工作的流程，通过使用本地容器，开发人员可以工作于标准的环境中。容器的使用，特别有利于持续集成、持续交付。

>持续集成/持续交付： CI/CD，Continous Integration，Continous Delivery。<br>
>在 CI 环境中，开发人员将会频繁地向主干提交代码。这些新提交的代码在最终合并到主干前，需要经过编译和自动化测试流进行验证。持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并主线之后的质量问题，对可能出现的一些问题进行预警。<br>
>CD 可以让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以释出的状况。它的目标在于让软件的建置、测试与释出变得更快以及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。<br>
> 有时候，持续交付也与持续部署（Continous Deployment）混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。

比如如下场景：

* 开发人员在本地编写代码，然后使用 docker 容器将其工作分享给同事
* 他们使用 docker 将应用置于测试环境中，进行自动、手动测试
* 开发人员发现漏洞时，可以在开发环境中修复，并再次将其部署于测试环境，重新进行测试及检验
* 测试结束后，只需把更新过的镜像推送到生产环境中，即可将修复交付给客户




#### 可靠、弹性的部署

通过基于容器的 docker 平台，可以实现高度便携。docker 容器可以运行于开发人员的笔记本、数据中心的物理机或虚拟机中、云服务商或混合环境中。

Docker 的便携和轻量化的天性，使得在我们在业务需要时，可以更加轻松地、接近实时地进行动态管理工作负载，扩容、缩容应用与服务。




#### 在同样的硬件上完成更多的工作

Docker 是轻量化的、高速的，它是传统虚拟机更有活力的、更合算的替代品，我们可以更加充分的利用现有的计算能力来完成我们的业务目标。Docker 对于高密度环境和中小型部署非常适合，只需使用较少的资源就可完成更多的工作。









### 使用的底层技术

Docker 是用 Go 语言编写的，利用了一些 Linux 内核的特点来实现其功能。




#### 命名空间

Namespaces

Docker 使用命名空间来实现工作空间的隔离。运行一个容器时，docker 会为该容器创建一系列命名空间。

这些命名空间形成了一个 **隔离层**，容器的每个方面都在一个单独的命名空间中运行，其访问被限制在该命名空间中。

Docker 引擎使用到的命名空间主要有：

* `pid` 命名空间：用于进程的隔离
* `net` 命名空间：用于管理网络接口
* `ipc` 命名空间：用于管理对 IPC 资源的访问（IPC：InterProcess Communication）
* `mnt` 命名空间：用于管理文件系统挂载点
* `uts` 命名空间：用于隔离内核和版本标识（UTS：Unix Timesharing System）




#### 控制组

Control Groups，cgroups

Linux 中的 Docker 引擎还依赖于 cgroups 技术。一个 cgroup 会将应用限制于一组特定的资源上。通过 cgroup，Docker 引擎可以为多个容器共享可用的硬件资源，需要时还可以对使用的资源进行限制。例如，可以限制特定容器允许使用的内存数量。




#### 联合文件系统

Uninon File Systems，UFS

UFS 文件系统是通过创建 **层** 来运行的，非常轻量、快速。Docker 引擎使用 UFS 为容器提供构建的组件，Docker 引擎可以使用多个 UFS 的变体，包括 AUFS，btrfs，vfs，DeviceMapper。




#### 容器格式

Container format

Docker 引擎将 namesapces、cgroups、UFS 组合到一个封装（wrapper）中，称为容器格式。默认的容器格式为 `libcontainer`。未来，docker 可能会支持其它的容器格式。
























## Docker 的安装及配置

Docker 有两个版本： Docker Community Edition (CE) 和 Enterprise Edition (EE) 。

针对各平台的安装方法，[官方文档](https://docs.docker.com/install/)中有详细的说明。








### CentOS 中安装 Docker




#### 方法一

用 docker 官方提供的脚本自动安装：

```bash
$ curl -sSL https://get.docker.com/ | sh
```




#### 方法二

手动安装：

```bash
$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2
$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
$ sudo yum install docker-ce
```







### 测试安装是否成功

查看当前安装的 Docker 版本：

`docker --version`

查看更详细的安装信息：

`docker info`

测试安装是否成功：

`docker container run hello-world`

查看当前镜像列表是否有刚刚下载的 hello-world：

`docker image ls`

查看当前容器，包括已经停止运行的：

`docker container ls -a`








### 用非特权用户管理 Docker

为了避免发生权限错误，可以把用户加入 docker 组。

Docker 守护进程会绑定到一个 Unix 套接字上，而不是 TCP 端口上。该套接字的所有者默认是 root，其它用户必须使用 sudo 来访问。这个守护进程始终会以 root 身份运行。

如果不愿意每次都使用 sudo docker，可以创建一个组，命名为 docker，然后把用户加入该组。Docker 守护进程启动时，它创建的 Unix 套接字是允许 docker 组的成员访问的。

docer 组会赋予用户和 root 同等的权限。
{: .notice--warning}


##### 创建组并添加用户

创建组：

```bash
$ sudo groupadd docker
```

把用户添加到组中：

```bash
$ sudo usermod -aG docker $USER
```

退出并重新登陆，以激活新组。

测试是否可以不用 sudo 来运行 docer：

```bash
$ docker run hello-world
```































## Docker 的架构

Docker 使用 C/S 架构。Docker 客户端与 docker 守护进程进行通信，docker 容器的构建、运行、发布均是由 docker daemon 完成的。Docker 的客户端与服务端既可在同一系统中运行，也可以用客户端连接到远端的服务端。它们之间是借助 UNIX 套接字或网络接口，使用 REST API 进行通信。

![image-center](/assets/images/docker.arc.jpg){: .align-center}

常用全局命令

命令 | 说明
--- | ---
查看命令列表  |  `docker`
查看版本  |  `docker --version`
查看版本  |  `docker version`
查看详细安装信息  |  `docker info`








### docker 守护进程

`dockerd` 会侦听 docker API 的请求，它还负责管理 docker 对象，如镜像、容器、网络、映射卷等。`dockerd` 还可以与其它守护进程进行通信，以管理 docker 的服务。






### docker 客户端

`docker` 是客户端，用户主要通过它与 docker 服务端进行交互。在使用 `docker container run` 这样的命令时，客户端会将这些命令发送给 `dockerd`，由它来执行。`docker` 命令需要使用 docker API。docker 客户端可以与多个守护进程进行通信。






### docker 仓库

docker registry

Docker 仓库用来保存 docker 镜像。Docker Hub 是公共的仓库，所有人都可以使用，docker 默认的配置会自动从 Docker Hub 查找镜像。如果需要，也可以运行私有仓库。如果使用 Docker Datacenter，其中就包含 Docer Trusted Registry。

在使用 `docker pull` 或 `docker run` 命令时，所需的镜像会从当前配置的仓库拉取；在使用 `docker push` 时，也会把镜像推送到当前配置的仓库中。

在 Docker store 中，可以购买、销售自己的 docker 镜像，当然也可以免费提供。例如，你可以从软件商手里购买一个镜像，其中包含一个应用或服务，然后使用该镜像将应用部署到你的测试、预发布、生产环境中。通过推送新版本并重新部署，来实现应用的升级。








### docker 对象




#### 镜像

image

镜像是个只读的模板，其中包含用来创建 docker 容器的指令。一个镜像经常是基于另一个镜像的，在原来的基础上进行了一些个性化的定制。例如，可以基于 ubuntu 镜像创建一个新的镜像，但在其中可以安装 Apache 和应用程序，以及必要的配置文件。

容器是由运行一个镜像得到的，**镜像** 是一个可执行的文件包，其中包含了应用程序运行所需的一切：代码、运行时、库、环境变量、配置文件。

**容器** 是镜像的一个运行时实例，执行镜像以后，在内存中得到的就是容器。可以用 `docker ps` 查看当前运行状态的容器。

Docker 把应用程序及其依赖，打包在镜像文件里面。只有通过这个文件，才能生成 Docker 容器。镜像文件可以看作是容器的模板。Docker 根据镜像文件生成容器的实例。同一个镜像文件，可以生成多个同时运行的容器实例。

镜像是二进制文件。实际开发中，一个镜像文件往往通过继承另一个镜像文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的镜像基础上，往里面加入 Apache 服务器，形成你的镜像。

```bash
# 查看本机所有镜像文件
$ docker image ls

# 删除镜像文件
$ docker image rm imagefile
```

镜像文件是通用的，一台机器的镜像文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的镜像文件，而不是自己制作。即使要定制，也应该基于别人的镜像文件进行加工，而不是从零开始制作。

为了方便共享，镜像文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的镜像仓库。此外，出售自己制作的镜像文件也是可以的。


##### 镜像的管理

###### Dockerfile

Dockerfile 文件是一个文本文件，用来配置镜像。Docker 会根据该文件的配置来生成二进制的镜像文件。Dockerfile 中的每条命令都会在镜像中创建 **一层**。如果修改了 Dockerfile，并重新构建镜像，只有 **发生了修改的层** 才会被重建。正因如此，镜像才会轻量化，小而且快。

首先，在项目的根目录下，新建一个文本文件 `.dockerignore`，该文件的目的是告诉 docer 打包时要排除指定的文件。

```conf
.git
node_modules
npm-debug.log
```

然后，在 **项目的根目录** 中，新建一个文本文件 `Dockerfile`：

```conf
# 使用官方库中的 Python 镜像
FROM python:2.7-slim

# 将工作目录设定为 /app
WORKDIR /app

# 将当前目录中的内容复制到容器中的 /app 目录
COPY . /app

# 安装 requirements.txt 文件中指定的所有软件包，包括所有的依赖也会打包进镜像
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# 打开容器的 80 端口
EXPOSE 80

# 定义环境变量
ENV NAME World

# 容器启动时，第一个被运行的程序是 app.py
CMD ["python", "app.py"]
```

**`RUN` 与 `CMD` 的区别：**

`RUN` 是在构建镜像文件期间执行的，执行结果都会打包进镜像文件，一个 Dockerfile 中可以有多条 `RUN`

`CMD` 是在容器启动以后执行的，一个 Dockerfile 中只能有一条 `CMD`

另外，如果在 Dockerfile 中指定了 `CMD`，而启动容器时又在 `docker container run` 后面显式指定了要运行的程序，如 `/bin/bash`，则该参数会 **覆盖** Dockerfile 中的 `CMD` 定义。
{: .notice--primary}

###### 构建镜像

配置完 `Dockerfile` 就可以用来构建镜像了。

```bash
$ docker image build -t whathefuck .
# 或
$ docker image build -t whathefuck:0.0.1 .
```

其中 `-t` 用于指定镜像文件的名字和标签，t 代表 tag，格式为 `name:tag`，冒号后指定标签，通常用做版本号。如果不指定，默认的标签是 latest。

如果运行成功，用 `docker image ls` 就可以看到新生成的镜像文件 whathefuck 了。

###### 删除镜像

```bash
$ docker image rm whathefuck
```

###### 发布镜像

容器运行成功以后，可以把镜像文件发布到 docker 仓库。首先要在 hub.docker.com 上注册一个账户，然后用以下命令 **登陆** docker hub：

```bash
$ docker login
```

为本地镜像文件标注用户名和版本：

```bash
$ docker image tag [imageName] [username]/[repository]:[tag]
# 范例
$ docker image tag whathefuck:0.0.1 neo/whathefuck:0.0.1
```

或者重新构建一次镜像文件：

```bash
$ docker image build -t [username]/[repository]:[tag] .
```

然后，发布镜像文件：

```bash
$ docker image push [username]/[repository]:[tag]
```

如果在别人的机器上临时登陆 docker hub，安全起见，记得要及时退出：

```bash
$ docker logout
```


##### 命令小结

命令 | 说明
--- | ---
查看镜像列表，隐藏中间步骤镜像  |  `docker image ls`
查看所有镜像列表  |  `docker image ls -a`
删除镜像文件  |  `docker image rm IMAGE`
删除所有镜像文件  |  `docker image rm $(docker IMAGE ls -aq)`
构建镜像  |  `docker build -t IMAGE .`
从特定文件构建镜像  |  `docker build -f NOTdockerfile -t IMAGE.`
登陆 docker hub  |  `docker login`
注销 docker hub  |  `docker logout`
为本地镜像打标签  |  `docker tag IMAGE user/repo:tag`
上传打过标签的镜像  |  `docker push user/repo:tag`




#### 容器

container

镜像文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： 镜像文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。

使用 Docker API 或命令行，容器可以被创建、运行、终止、删除、移动。可以把某个容器连接到一个或多个网络中，可以为其添加存储（映射驱动），还可以基于该容器当前的状态创建一个新的镜像。

默认情况下，一个容器相对来说与其它容器及宿主机是隔离开的。

容器是由其镜像以及创建、启动时的配置参数定义的，容器被删除以后，其状态发生的任何变化，如果没有保存在持久存储设备上，就会丢失。

```bash
# 列出本机正在运行的容器
$ docker container ls

# 列出本机所有容器，包括终止运行的容器
$ docker container ls --all
```

上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的`docker container kill`命令。

终止运行的容器文件，依然会占据硬盘空间，可以使用 `docker container rm [containerID]` 命令删除。运行该命令之后，再使用 `docker container ls --all` 命令，就会发现被删除的容器文件已经消失了。


##### 容器的管理

###### 生成容器

`docker container run` 命令会用镜像文件来生成容器。

```bash
$ docker container run -p 8000:3000 -it whathefuck /bin/bash
# 或者
$ docker container run -p 8000:3000 -it whathefuck:0.0.1 /bin/bash
```

指令解释：

`-p`：端口映射。 把本机的 8000 端口映射为容器的 3000 端口。docker 中运行的进程，其接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。

`-it`：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。

`whathefuck:0.0.1`：`name:tag` ，镜像文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。

`/bin/bash`：容器启动以后，内部要第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。

###### 删除容器

如果容器是在前台运行的，可以使用 `^C` 来结束进程，然后 `exit` 退出容器。

此外，还可以用 `docker container kill [containerID]` 来终止容器。

容器停止运行以后，不会自动消失，可以用 `docker container rm [containerID]` 删除容器文件。

另外，在启动容器的时候，如果用 `docker container run --rm`，当容器终止运行后便会自动删除容器文件。

如：

```bash
$ docker container run --rm -p 8000:3000 -it whathefuck /bin/bash
```


##### 命令小结

命令 | 说明
--- | ---
仅查看运行状态的容器列表  |  `docker container ls`
查看所有容器列表，包括终止运行的  |  `docker container ls -a`
可看所有容器列表，只显示数字 ID  |  `docker container ls -aq`
查看帮助  |  `docker container --help`
查看容器的端口映射  |  `docker container port CONTAINER`
查看容器的 IP 地址  |  `docker container inspect --format '{{ .NetworkSettings.IPAddress }}' CONTAINER`
查看容器的日志  |  `docker container logs CONTAINER`
启动容器  |  `docker container run username/repo:tag`
启动容器，端口映射  |  `docker container run -p 4000:80 IMAGE`
启动容器，后台运行  |  `docker container run -d -p 4000:80 IMAGE`
重新运行已经终止的容器  |  `docker container start -ai IMAGE`
在运行中的容器上执行额外的进程 | `docker container exec -it mysql bash`
优雅终止容器  |  `docker container stop <hash>`
强制终止容器  |  `docker container kill <hash>`
删除容器文件  |  `docker container rm <hash>`
删除所有容器  |  `docker container rm $(docker container ls -aq)`




#### 服务

service

通过服务可以扩展容器，令其穿越多个 docker daemon，所有这些 daemon 一起组成了一个容器群（swarm），其中可以有多个管理者和工人。

容器群的每个成员都是一个 docker daemon，这些 daemon 之间都使用 Docerk API 进行通信。可以用服务来定义所需的状态，如服务副本的数量，这些数量在任何时候必须始终保持不变。

默认情况下，服务是由所有的工人节点进行负载均衡的。对于访问来说，docker 服务看上去就是一个应用。docker 引擎是在 Docker v1.12 版本开始支持容器群模式的。






























## Docker 网络配置

Docker 容器与服务这所以如此强大，其中一个原因就是它们可以被连接在一起，或将其与非 docker workload 连接在一起。Docker 容器与服务甚至不需要知道自己被部署在 docker 上，也不需要知道它们所在的节点所处理的是不是 docker workload，无论 docker 的宿主机运行的是 Linux 还是 windows，都可以用 docker 来管理它们。











### 网络驱动

Docker 的网络子系统是可插拔的。使用各种不同的驱动。系统默认提供的驱动：

* `bridge`
* `overlay`
* `host`
* `Macvlan`
* `none`
* 网络插件：可以安装、使用来自 Docker Store 的第三方的网络插件。




#### 使用 `bridge` 网络

这是默认的网络驱动。如果用户在创建网络时不指定驱动，默认就会使用 `bridge`。如果应用程序运行于独立的容器中，而且它们之间需要通信，通常会使用该驱动。

在网络技术中，桥接网络是链路层的设备，用来在不同的网段间转发流量。网桥可以是硬件设备，也可以是运行于宿主机内核中的软件。

在 docker 中，桥接网络使用的是软件网桥。该网桥使得连接到同一网桥的容器可以互相通信，同时还会将其与那些没有连接到此网桥的容器相互隔离。Docker 的网桥驱动会在宿主机中自动安装规则，这样，连接到不同桥接网络的容器之间就无法直接通信了。

桥接网络适用于那些运行在同一 docker daemon 宿主的容器。要想实现运行在不同 docker daemon 宿主上的容器之间的通信，要么在操作系统层面管理路由，要么可以使用叠加网络，即 overlay network。

在启动 docker 时，会自动创建一个默认桥接网络，名为 bridge。新创建的容器如果没有指定网络类型，默认会使用该网络。当然也可以创建用户定制的桥接网络。用户定义的网桥要比默认的更好用。


##### 自定义网桥与默认网桥的区别

###### 用户自定义的网桥 提供更好的隔离和互通性

连接到同一个用户定义的网桥的容器，它们之间会自动开放 **所有端口**，而对外部世界则全部关闭。容器化的应用彼此间可以轻松地进行通信，同时避免了向外部世界不经意间开放访问权限。

假如一个应用包含一个前端和一个后端数据库。外部世界需要访问前端，如 80 端口，而只有后端自己才需要访问数据库主机和端口。此时使用用户定义的网桥，只需要打开网页端口，而数据库应用不需要打开任何端口，因为网页前端可以通过自定义网桥直接对其访问。

同样的应用栈，如果使用默认的网桥，则前端网页端口和后端数据库端口都需要打开，都要使用 `-p` 选项，这一来，docker 宿主机就需要采用其它方法来限制对数据库端口的访问。

###### 用户自定义的网桥 对容器提供自动 DNS 解析

连接到默认网桥的容器，它们之间只能通过 IP 地址访问，除非使用 `--link` 选项，该选项已经很少使用了。而连接到自定义网桥的容器之间，可以直接使用 **名称** 或 **别名** 来解析。

上面的应用栈，假如分别命名容器为 web 和 db，可以在 db 容器上将二者连接起来，不管它们在哪个 docker 宿主机上运行。

而相同的应用栈如果连接到默认的网桥，就必须使用 `--link` 选项手动创建容器之间的连接，而这些连接则需要在两个方向上分别创建，如果容器再多一些，想实现容器间的通信就会变得更加复杂。另一个办法是更新 `/etc/hosts`，将容器名称和地址加入其中，但这样做会造成一些难以调试的问题。

###### 自定义网桥上的容器可以随时连接、分离

在容器的生存期内，可以 **在线随时** 将其从自定义网桥上连接或分离。

而要想从默认网桥将容器分离的话，必须先将其终止，然后再用不同的网络选项来启动才行。

###### 自定义网桥便于灵活配置

如果所有容器都连接到默认网桥，虽然可以修改配置，但所有的容器都被迫使用相同的配置，如 MTU 或 iptables 规则。另外，对默认网桥的修改发生在 docker 外部，需要重启 docker 才能生效。

而自定义网桥是使用 `docker network create` 来创建和配置的，如果不同组的应用需要不同的网络，可以分别配置不同的自定义网桥。

###### 连接到默认网桥的容器共享环境变量

早期使用时，在两个容器之间共享环境变量的唯一办法就是用 `--link` 选项来链接它们，而这种办法并不适用于自定义网络。然而，有更好的办法：

* 通过使用 docker volume，多个容器可以挂载同一个文件或目录，其中包含共享的信息
* 在 compose file 中定义共享的变量，通过 `docker-compose` 命令来启动多个容器
* 不再使用单一的容器，改为使用 swarm service，利用其共享的 secrets 和 configs 来共享变量

连接到同一个自定义桥接网络上的容器，彼此间会开放所有端口。要想将开放端口以便允许不同网络上的容器或非 docker 主机的访问，该端口必须使用 `-p` 或 `--publish` 选项来打开。


##### 管理自定义网桥

###### 创建自定义网桥：

```bash
$ docker network create my-net
```

可以为自定义网桥指定子网、IP 地址范围、网关等参数，详见 `docker network create` [参数说明](https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options)，也可以用 `docker network create --help` 查看在线帮助信息。
{: .notice}

###### 删除网桥

删除网桥之前，必须先把连接到上面的所有容器断开。

```bash
$ docker network rm my-net
```

>在创建或删除自定义网桥时，以及将容器与自定义网桥连接或断开时，docker 会使用根据操作系统使用特定的工具来管理底层的网络设施，如在 Linux 中增加或删除网桥设备，或配置 iptables 规则等。这些细节都属于实施的细节，不用管它，让 docker 为你来管理自定义网络吧。


##### 将容器连接到自定义网桥

创建新容器时，可以指定一个或多个 `--network` 标签。下面的范例是把一个 Nginx 容器连接到 `my-net` 网络，同时还会打开其 80 端口，使用宿主机的 8080 端口来映射，这样，外部的访客就可以访问该端口了。连接到 `my-net` 网络的所有其它容器可以访问 `my-nginx` 容器的所有端口，反之亦然。

```bash
$ docker create --name my-nginx \
  --network my-net \
  --publish 8080:80 \
  nginx:latest
```

要想把运行中的容器连接到现有的自定义网桥上，可使用 `docker network connect` 命令：

```bash
$ docker network connect my-net my-nginx
```


##### 将容器从自定义网桥断开

要想把容器从自定义网桥断开，可使用 `docker network disconnect` 命令：

```bash
$ docker network disconnect my-net my-nginx
```


##### 使用 IPv6

要想让 docker 容器支持 IPv6，需要在 docker daemon 上[开启对应的选项](https://docs.docker.com/config/daemon/ipv6/)，再重新加载配置，然后就可以创建 IPv6 网络了。

创建网络时，可以使用 `--ipv6`  标签来启用 IPv6，在默认 `bridge` 网络上，无法选择性地禁用 IPv6 。


##### 允许 docker 容器向外转发

默认情况下，连接到默认网桥上的容器不会向外部世界转发流量。要想实现转发，必须修改两处设置，这些不是 docker 命令，但它们却影响 docker 宿主机的内核。

###### 配置 Linux 内核，允许 IP 转发

```bash
$ sysctl net.ipv4.conf.all.forwarding=1
```

###### 修改 `iptables FORWARD` 策略，由 DROP 改为 ACCEPT

```bash
$ sudo iptables -P FORWARD ACCEPT
```

这些修改在系统重启后不会保留，如需要可以将其添加到启动脚本中。





#### 使用 `overlay` 网络

叠加网络

`overlay` 网络驱动会在多个 docker daemon 宿主机之间，创建一个 **分布式** 的网络。该网络叠加在宿主机网络之上，连接于该网络的容器（包括容器群的服务容器）可以安全地相互通信。对于来往于正确的 docker daemon 宿主机与对应的目标容器之间的数据包，docker 可以透明地处理它们的路由。

在初始化一个容器群时，或将某个 docker 主机加入现有的容器群时，会在该 docker 主机上新建 **两个** 网络：

* 名为 `ingress` 的网络：
























### 容器网络的配置



#### 禁用容器的网络




#### docker 与 iptables



#### 容器的网络配置


#### 配置 docker 使用代理服务器












### 常用网络配置命令

命令 | 说明
--- | ---
查看所有网络  |  `docker network ls`
创建网络  |  `docker network create my_app_net`
