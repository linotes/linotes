---
toc: true
toc_label: "Docker 简介"
toc_icon: "copy"
title: "Docker 简介"
tags: docker
categories: "virtualization"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/virtualization.jpeg
  overlay_filter: rgba(0, 0, 0, 0.8)
---




## 简介







### Docker 的概念

Docker 是一个平台，开发人员与管理员可以在容器中进行 **开发**、**部署**、**运行** 应用程序。用 Linux 容器进行部署应用称为容器化。容器不是一个新概念，但将其用于简化应用的部署却是一个新的概念。

容器化之所以愈发流行是因为容器的以下特点：

* 灵活：即使是最复杂的程序都可以被容器化
* 轻量：容器会利用并共享主机的内核
* 无缝：可以实时更新和升级
* 便携：可以在本地构建，部署到云端，随处运行
* 弹性：可以尽情扩展，自动发布容器的复本
* 可堆叠：可以把服务在线垂直堆叠



#### 环境配置的难题

软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？

用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。

如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说："它在我的机器可以跑了"（It works on my machine），言下之意就是，其他机器很可能跑不了。

环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。



#### 虚拟机

虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。

虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。

##### 资源占用多

虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。

##### 冗余步骤多

虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。

##### 启动慢

启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。




#### Linux 容器

由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 **LXC**）。

**Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。** 或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

**容器** 原生运行于 Linux 中，并与其它的容器共享主机的内核。它以单独的进程运行，不会比其它可执行文件占用更多的内存，因此比较轻量。

相比之下，**虚拟机** 会运行一个完整的操作系统，该操作系统通过虚拟层对宿主的资源进行访问。通常比应用程序需要更多的资源来运行。

{% include figure image_path="/assets/images/docker.vs.vm.png" %}

由于容器是进程级别的，相比虚拟机有很多优势。

##### 启动快

容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。

##### 资源占用少

容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。

##### 体积小

容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。



#### Docker 是什么

Docker 属于 **Linux 容器的一种封装**，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。

总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。



#### Docker 的用途

##### 提供一次性的环境

比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

##### 提供弹性的云服务

因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

##### 组建微服务架构

通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。



#### 镜像文件

容器是由运行一个镜像得到的，**镜像** 是一个可执行的文件包，其中包含了应用程序运行所需的一切：代码、运行时、库、环境变量、配置文件。

**容器** 是镜像的一个运行时实例，执行镜像以后，在内存中得到的就是容器。可以用 `docker ps` 查看当前运行状态的容器。

Docker 把应用程序及其依赖，打包在镜像文件里面。只有通过这个文件，才能生成 Docker 容器。镜像文件可以看作是容器的模板。Docker 根据镜像文件生成容器的实例。同一个镜像文件，可以生成多个同时运行的容器实例。

镜像是二进制文件。实际开发中，一个镜像文件往往通过继承另一个镜像文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的镜像基础上，往里面加入 Apache 服务器，形成你的镜像。

```bash
# 查看本机所有镜像文件
$ docker image ls

# 删除镜像文件
$ docker image rm imagefile
```

镜像文件是通用的，一台机器的镜像文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的镜像文件，而不是自己制作。即使要定制，也应该基于别人的镜像文件进行加工，而不是从零开始制作。

为了方便共享，镜像文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的镜像仓库。此外，出售自己制作的镜像文件也是可以的。



#### 容器文件


镜像文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： 镜像文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。

```bash
# 列出本机正在运行的容器
$ docker container ls

# 列出本机所有容器，包括终止运行的容器
$ docker container ls --all
```

上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的`docker container kill`命令。

终止运行的容器文件，依然会占据硬盘空间，可以使用 `docker container rm [containerID]` 命令删除。运行该命令之后，再使用 `docker container ls --all` 命令，就会发现被删除的容器文件已经消失了。



#### `Dockerfile` 文件

Dockerfile 文件是一个文本文件，用来配置镜像。Docker 会根据该文件的配置来生成二进制的镜像文件。































### 安装及配置 Docker

Docker 有两个版本： Docker Community Edition (CE) 和 Enterprise Edition (EE) 。

针对各平台的安装方法，[官方文档](https://docs.docker.com/install/)中有详细的说明。



#### CentOS 中安装 Docker

**方法一**

这种方法安装的是最新版，即 Edge release，**并非稳定版**。用 docker 官方提供的脚本自动安装：

```bash
$ curl -sSL https://get.docker.com/ | sh
```

**方法二**

手动安装：

```bash
$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2
$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
$ sudo yum install docker-ce
```



#### 测试安装是否成功

查看当前安装的 Docker 版本：

`docker --version`

查看更详细的安装信息：

`docker info`

测试安装是否成功：

`docker container run hello-world`

查看当前镜像列表是否有刚刚下载的 hello-world：

`docker image ls`

查看当前容器，包括已经停止运行的：

`docker container ls -a`



#### 用非特权用户管理 Docker

为了避免发生权限错误，可以把用户加入 docker 组。

Docker 守护进程会绑定到一个 Unix 套接字上，而不是 TCP 端口上。该套接字的所有者默认是 root，其它用户必须使用 sudo 来访问。这个守护进程始终会以 root 身份运行。

如果不愿意每次都使用 sudo docker，可以创建一个组，命名为 docker，然后把用户加入该组。Docker 守护进程启动时，它创建的 Unix 套接字是允许 docker 组的成员访问的。

docer 组会赋予用户和 root 同等的权限。
{: .notice--warning}


##### 创建组并添加用户

创建组：

```bash
$ sudo groupadd docker
```

把用户添加到组中：

```bash
$ sudo usermod -aG docker $USER
```

退出并重新登陆，以激活新组。

测试是否可以不用 sudo 来运行 docer：

```bash
$ docker run hello-world
```






























### Docker 常用操作






#### 编辑 `Dockerfile`

首先，在项目的根目录下，新建一个文本文件 `.dockerignore`，该文件的目的是告诉 docer 打包时要排除指定的文件。

```conf
.git
node_modules
npm-debug.log
```

然后，在 **项目的根目录** 中，新建一个文本文件 `Dockerfile`：

```conf
# 使用官方库中的 Python 镜像
FROM python:2.7-slim

# 将工作目录设定为 /app
WORKDIR /app

# 将当前目录中的内容复制到容器中的 /app 目录
COPY . /app

# 安装 requirements.txt 文件中指定的所有软件包，包括所有的依赖也会打包进镜像
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# 打开容器的 80 端口
EXPOSE 80

# 定义环境变量
ENV NAME World

# 容器启动时，第一个被运行的程序是 app.py
CMD ["python", "app.py"]
```

##### `RUN` VS `CMD`

`RUN` 是在构建镜像文件期间执行的，执行结果都会打包进镜像文件，一个 Dockerfile 中可以有多条 `RUN`

`CMD` 是在容器启动以后执行的，一个 Dockerfile 中只能有一条 `CMD`

另外，如果在 Dockerfile 中指定了 `CMD`，而启动容器时又在 `docker container run` 后面显式指定了要运行的程序，如 `/bin/bash`，则该参数会 **覆盖** Dockerfile 中的 `CMD` 定义。
{: .notice--primary}




#### 创建镜像

配置完 `Dockerfile` 就可以用来创建镜像了。

```bash
$ docker image build -t whathefuck .
# 或
$ docker image build -t whathefuck:0.0.1 .
```

其中 `-t` 用于指定镜像文件的名字和标签，t 代表 tag，格式为 `name:tag`，冒号后指定标签，通常用做版本号。如果不指定，默认的标签是 latest。

如果运行成功，用 `docker image ls` 就可以看到新生成的镜像文件 whathefuck 了。



#### 生成容器

`docker container run` 命令会用镜像文件来生成容器。

```bash
$ docker container run -p 8000:3000 -it whathefuck /bin/bash
# 或者
$ docker container run -p 8000:3000 -it whathefuck:0.0.1 /bin/bash
```

指令解释：

`-p`：端口映射。 把本机的 8000 端口映射为容器的 3000 端口。docker 中运行的进程，其接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。

`-it`：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。

`whathefuck:0.0.1`：`name:tag` ，镜像文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。

`/bin/bash`：容器启动以后，内部要第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。

##### 删除容器

如果容器是在前台运行的，可以使用 `^C` 来结束进程，然后 `exit` 退出容器。

此外，还可以用 `docker container kill [containerID]` 来终止容器。

容器停止运行以后，不会自动消失，可以用 `docker container rm [containerID]` 删除容器文件。

另外，在启动容器的时候，如果用 `docker container run --rm`，当容器终止运行后便会自动删除容器文件。

如：

```bash
$ docker container run --rm -p 8000:3000 -it whathefuck /bin/bash
```



#### 发布镜像

容器运行成功以后，可以把镜像文件发布到 docker 仓库。首先要在 hub.docker.com 上注册一个账户，然后用以下命令登陆：

```bash
$ docker login
```

为本地镜像文件标注用户名和版本：

```bash
$ docker image tag [imageName] [username]/[repository]:[tag]
# 范例
$ docker image tag whathefuck:0.0.1 neo/whathefuck:0.0.1
```

或者重新构建一次镜像文件：

```bash
$ docker image build -t [username]/[repository]:[tag] .
```

然后，发布镜像文件：

```bash
$ docker image push [username]/[repository]:[tag]
```



#### 命令小结


##### 查看整体信息

命令 | 说明
--- | ---
查看命令列表  |  `docker`
查看帮助  |  `docker container --help`
查看版本  |  `docker --version`
查看版本  |  `docker version`
查看详细安装信息  |  `docker info`


##### 镜像操作

命令 | 说明
--- | ---
查看镜像列表，隐藏中间步骤镜像  |  `docker image ls`
查看所有镜像列表  |  `docker image ls -a`
删除镜像文件  |  `docker image rm IMAGE`
删除所有镜像文件  |  `docker image rm $(docker IMAGE ls -aq)`
构建镜像  |  `docker build -t IMAGE .`
从特定文件构建镜像  |  `docker build -f NOTdockerfile -t IMAGE.`
登陆 docker hub  |  `docker login`
注销 docker hub  |  `docker logout`
为本地镜像打标签  |  `docker tag IMAGE user/repo:tag`
上传打过标签的镜像  |  `docker push user/repo:tag`


##### 容器操作

命令 | 说明
--- | ---
仅查看运行状态的容器列表  |  `docker container ls`
查看所有容器列表，包括终止运行的  |  `docker container ls -a`
可看所有容器列表，只显示数字 ID  |  `docker container ls -aq`
查看容器的端口映射  |  `docker container port CONTAINER`
查看容器的 IP 地址  |  `docker container inspect --format '{{ .NetworkSettings.IPAddress }}' CONTAINER`
查看容器的日志  |  `docker container logs CONTAINER`
启动容器  |  `docker container run username/repo:tag`
启动容器，端口映射  |  `docker container run -p 4000:80 IMAGE`
启动容器，后台运行  |  `docker container run -d -p 4000:80 IMAGE`
重新运行已经终止的容器  |  `docker container start -ai IMAGE`
在运行中的容器上执行额外的进程 | `docker container exec -it mysql bash`
优雅终止容器  |  `docker container stop <hash>`
强制终止容器  |  `docker container kill <hash>`
删除容器文件  |  `docker container rm <hash>`
删除所有容器  |  `docker container rm $(docker container ls -aq)`
  |  


##### 网络

命令 | 说明
--- | ---
查看所有网络  |  `docker network ls`
创建网络  |  `docker network create my_app_net`
  |  
