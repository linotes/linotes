---
toc: true
toc_label: "Nginx 简介及基本功能"
toc_icon: "copy"
title: "Nginx 简介及基本功能"
tags: nginx
categories: "server"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/nginx.jpeg
  overlay_filter: rgba(0, 0, 0, 0.8)
---


## Nginx 是如何设计的

本节内容译自 Nginx 官方博客的一篇文章 《[Inside NGINX: How We Designed for Performance & Scale](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)》。

Nginx 之所以在性能方面表现优异，完全得益于其优良的设计。虽然有许多网页服务器和应用服务器同样使用单一线程或进程的架构，Nginx 仍然能异军突起，它精细的事件驱动的架构，使其能够在当代硬件中，轻易地扩展为十万级高并发连接。




### Nginx 进程模型

![image-center](/assets/images/infographic-Inside-NGINX_process-model.png){: .align-center}

要想更好地理解它的设计，需要理解 Nginx 的工作原理。Nginx 有一个主进程，它会进行一些特权级的操作，如读取配置文件、绑定端口；还有一些工人进程和辅助进程。

```bash
># service nginx restart
* Restarting nginx
# ps -ef --forest | grep nginx
root     32475     1  0 13:36 ?        00:00:00 nginx: master process /usr/sbin/nginx
                                                -c /etc/nginx/nginx.conf
nginx    32476 32475  0 13:36 ?        00:00:00  _ nginx: worker process
nginx    32477 32475  0 13:36 ?        00:00:00  _ nginx: worker process
nginx    32479 32475  0 13:36 ?        00:00:00  _ nginx: worker process
nginx    32480 32475  0 13:36 ?        00:00:00  _ nginx: worker process
nginx    32481 32475  0 13:36 ?        00:00:00  _ nginx: cache manager process
nginx    32482 32475  0 13:36 ?        00:00:00  _ nginx: cache loader process
```

在这个四核心的服务器上，Nginx 主进程创建了四个工人进程，以及几个缓存辅助进程，用来管理磁盘中的内容缓存。



### 架构为什么重要？

任何 Unix 程序的基础都是线程或进程。从 Linux 操作系统的角度来看，线程和进程基本是一回事，主要区别在于是否共享内存。

线程或进程是独立自足的一套指令，操作系统可以安排其在 CPU 核心上运行。大多数复杂的应用都会同时运行多个线程或进程，主要原因为：

* 可以同时使用更多的计算核心
* 更易于实现并行操作

进程和线程会消耗资源，它们会占用内存和其它操作系统的资源，而且需要交付、脱离核心，该操作称为上下文切换，即 context switch。现在的服务器大多能同时处理几百个小的、激活的线程或进程，但一旦内存耗尽，或高 I/O 负载带来大量的上下文切换时，性能会急剧下降。

>上下文切换：指 CPU 从一个进程或线程切换到另一个进程或线程。需要先保存当前进程的状态并恢复另一个进程的状态。
>
>切换时，CPU 会停止处理当前运行的程序，保存当前程序运行的具体位置，以便之后继续运行。当前运行的任务转为就绪、挂起或删除状态，任务的运行环境被保存；另一个任务成为当前任务，其运行环境被恢复。进程上下文用进程的 PCB 来表示，它包括进程状态、CPU 寄存器的值等。
>
>在三种情况下可能会发生上下文切换：中断处理、多任务处理、用户太切换。
>
>

在设计网络应用时，通常的做法是为每个连接分配一个线程或进程，这种架构比较简单，而且容易部署，但当应用需要应付几千个并发连接时，没有足够的可扩展性。



























## 与 Apache 的区别

Apache 1995 年就开始被广泛使用，支撑了最多的网站，其次就是微软的 IIS。

开源的 Apache 这么多年来如此广泛地应用，拥有如此多的用户，因此产生了很多的模块来扩展其功能，这些模块大多也是开源的。

但 Apache 在高负载下会变得缓慢，因为它总是要产生新的进程，会消耗更多的内存。它创建的新的线程还会与其它线程争夺内存与 CPU 资源。当流量达到进程限制时，Apache 会拒绝新的连接。

Nginx 是一个开源的网页服务器，它的开发是为了解决 Apache **性能** 和 **可扩展性** 的问题。Nginx 是开源、免费的，但同样提供收费的版本 Nginx Plus。

Nginx 是基于事件的，因此其架构为事件驱动，而且是异步的。而 Apache 依赖于进程和线程。







### Apache 的工作原理及其局限性

Apache 通过 **创建进程和线程** 来管理额外的连接，管理员通过配置服务器来控制最大进程数。

最大进程的数量取决于主机可用的内存数量，太多的进程会耗尽内存，最终会促进主机把内存中的数据交换到磁盘，对性能的损害非常大。不仅如此，一旦达到进程上限，Apache 会开始拒绝新的连接。

Apache 有两种运行模式，即 pre-forked 和工人模式（多进程，MPM）运行，无论哪种方式，针对传入的新连接，它都会创建新的进程。

这两种模式的区别：

* pre-forked 模式为每个进程创建 **一个线程**，每个 **进程** 处理一个请求。
* 工人模式也会产生新进程，但每个进程有 **多个线程**，每个 **线程** 处理一个请求。

因此，一个工人模式的进程可以处理多个连接，而一个 pre-forked 模式的进程只能处理一个连接。

工人模式使用的内存更少，因为进程比线程要消耗更多的内存。

在优化 Apache 过程中，受限的因素主要是内存，以及潜在的、争夺相同 CPU 和内存的死锁线程。如果一个线程被暂停了，用户就只能一直等待，直到其它进程把资源让出来，网页才会显示出来。如果线程被死锁，它就无从知晓如何重启了，于是会一直卡在那里。












### Nginx

Nginx 使用是完全不同的架构，更适合非线性扩展，无论是针对并发连接数还是每秒请求数。它是基于事件的，其代码流是基于系统返回的真实的 I/O 事件的。

它不会为每个新连接创建新进程。即使在负载增加时，内存和 CPU 的使用也始终可控。在通常的硬件配置下，Nginx 在一台服务器上可以同时处理上万个并发连接。

Nginx 的主要优势在于 **以高性能处理高并发**，以及其工作的 **高效**。它通过模块提供多个功能，可以很便捷地处理并发、延迟、SSL、静态内容、压缩、缓存、连接、请求控制、流媒体等，还可以直接与 memcached 或 Redis 整合，在面对大量并发用户时，实现性能的大幅提升。

Nginx 与 Apache 的工作方式的区别，主要体现在处理线程的方式上。

Nginx 不会为每个网页请求创建新的进程，而是通过配置来指定其主进程允许创建多少个工人进程，根据经验，每个 CPU 可以有一个工人进程。这些工人进程都是 **单线程** 的，每个工人可以处理成千上万的并发连接，它用一个线程通过 **异步** 的方式来实现，从而无需使用多个线程。

Nginx 还会用缓存加载程序和缓存管理器进程从磁盘中读取数据，并将其加载到缓存中，并在用过之后将其从缓存中移除。

Nginx 由一些模块组成，它们是在编译时加入的。因此，用户可以下载源码，根据需要来选择编译哪些模块。有些模块用于连接后端的应用服务器、负载均衡、代理服务器等，没有给 PHP 使用的模块，因为 Nginx 自己就可以编译 PHP 代码。




#### Nginx 与 Apache 2.4 MP 的比较

Apache 2.4 包含了 MPM 事件模块，用来异步处理一些连接类型，但处理的方式与 Nginx 不同。其目的是为了在负载增加时，减小对内破损需求。

Apache 2.4 除了工人模式与 pre-forked 模式之外，还加增加了一个 mpm_event_module，即 MPM 事件模块，用来解决 “线程必须持续等待用户连接以期生成的请求” 的问题。MPM 专门使用一个线程来处理侦听状态及保活状态的套接字。通过减少创建线程和进程的数量，解决了一些旧版本中的内存问题。

Apache MPM 事件模块与 Nginx 是不同的，因为它对于新的请求，仍然需要创建新进程。而 Nginx 不会针对一个用户连接创建多个进程的。Apache 2.4 所带来的改进是：Apache 所创建的进程会比普通的工人模式生成更少的线程，因为一个线程已经可以处理不止一个连接了。




#### Nginx 和 Apache 同时使用

Apache 的功能丰富，而 Nginx 速度更快。这就意味 Nginx 可以更快地提供静态内容，但 Apache 包含多个模块，用来与后端应用服务器协同工作，以及用来运行脚本语言。

Apache 和 Nginx 都可以用作代理服务器，但通常把 Nginx 用作代理服务器，把 Apache 用作后端服务器。Nginx 包含高级的负载均衡和缓存功能。可以部署多个 Apache 服务器，然后用负载均衡器来管理。

>php-fpm：PHP FastCGI Process Manager

另一种配置是部署 Nginx 时，使用单独的 php-fpm 应用，之所以把 php-fpm 称为应用，是因为它不是 .dll 或 .so，它不会像 Apache 的模块一样在执行时被加载。php-fpm 可以与 Nginx 配合使用，使 Nginx 可以解析 php 脚本，这些非静态内容。




#### 更适合 Apache 的场景

Apache 天生支持 PHP、Python、Perl 等语言。例如，mod_python 和 mod_php 模块用来处理 PHP 和 Perl 代码，mod_python 在使用 FastCGI 时更高效，因为 FastCGI 无需为每个请求加载 Python 解释器。mod_rails 和 mod_rack 也是如此，它们用来在 Rails 中运行 Ruby，它们在 Apache 进程中运行会更快。

因此，如果网站内容绝大多数是 Python 或 Ruby，则更适合使用 Apache 来做应用服务器，因为 Apache 无需使用 CGI。如果对于 PHP 来说就无所谓了，因为 Nginx 也天生支持 PHP。





































## 控制 nginx 运行时进程





### 主进程与工人进程

nginx 有一个主进程与一个或多个工人进程。如果启用了缓存，在启动服务时还会运行缓存启动器进程和缓存管理器进程。

主进程的主要任务是读取和验证配置文件，维护工人进程。
{: .notice}

工人进程的任务则是处理请求。nginx 靠的是依赖于操作系统的机制，把请求高效地分配给工人进程。工人进程的数量由配置文件定义，可以是固定的，也可以根据可用 CPU 核心的数量来自动调整。






### nginx 的控制




#### 用信号控制进程

nginx 可以由信号来控制，主进程的 ID 默认被写入 `/run/nginx.pid` 文件。


##### 主进程支持以下信号：

`GERM`,`INT` ：快速关闭

`QUIT` ：优雅关闭

`HUP` ：修改配置，修改了时区，用新配置开启新工人进程，优雅关闭旧工人进程

`USR1` ：重新打开日志文件

`USR2` ：升级可执行文件

`WINCH` ：优雅关闭工人进程


##### 工人进程支持的信号：

单独的工人进程也可以由信号来控制，虽然并不需要这么做。

`TERM`,`INT` ：快速关闭

`QUIT` ：优雅关闭

`USR1` ：重新打开日志文件

`WINCH` ：异常终止，用于调试，需启用 `debug_points`



##### 重载配置

要想重载配置，可以停止或重启 nginx ，或向主进程发送信号。可以用 `nginx -s` 命令来发送信号：

```bash
nginx -s <SIGNAL>
```

`<SIGNAL>` 可以是以下信号：

* `stop` ：快速关闭
* `quit` ：优雅关闭
* `reload` ：重新加载配置文件
* `reopen` ：重新打开日志文件

```shell
nginx -s reload
```


##### 用 `kill` 发信号

还可以用 `kill` 命令直接给主进程发信号，这种情况下会直接把信号发给指定 PID 的进程。

```bash
ps -ax | grep nginx
  3129 ?        Ss     0:00 nginx: master process /usr/sbin/nginx

kill -s QUIT 3129
```




#### 修改配置

为了让 nginx 重新读取配置文件，可以向主进程发送 `HUP` 信号。

主进程首先会检查语法是否正确，然后会尝试应用新的配置，即，打开日志文件及新的侦听套接字。

如果失败，回滚本次所做的修改，继续用旧配置工作。

如果成功，开启新的工人进程，并向旧工人进程发送消息，要求它们优雅关闭。旧工人进程关闭侦听套接字，继续处理之前的请求，处理完毕以后，旧工人进程关闭。





#### 滚动日志文件

滚动日志文件之前，需要先重命名旧日志文件。

之后，应该向主进程发送 `USR1` 信号。主进程会把当前打开的日志文件重新打开，并为其分配一个普通权限的用户，以该用户身份来运行工人进程。

在成功地重新打开之后，主进程关闭所有打开的文件，向工人进程发送消息，要求它们重新打开文件。

工人进程同样地马上打开新文件，关闭旧文件。

此时，旧文件几乎可以立即用于后期处理，如压缩。




#### 在线升级可执行文件

升级可执行文件时，要先用新的可执行文件把旧的替换掉。

之后，向主进程发送 `USR2` 信号。

主进程先是重命名其 PID 文件，在原文件名基础上添加后缀 `.oldbin`，如 `nginx.pid.oldbin`；然后再运行新的可执行文件，随之启动新的工人进程。

之后，所有的新旧工人进程继续接受请求。如果向第一个主进程发送了 `WINCH` 信号，它会向其工人进程发送消息，要求它们优雅关闭，它们会开始退出。

过了一段时间，只有新的工人来处理请求。

要注意的一点是，旧的主进程不会关闭其侦听套接字，需要时可以再次启动其工人进程。

如果新的可执行文件由于某种原因工作不正常，可以选择以下操作之一：

* 向旧主进程发送 `HUP` 信号。旧主进程会启动新的工人进程，不会重新读取配置。然后，向新主进程发送 `QUIT` 信号，其工人进程可被优雅关闭。
* 向新主进程发送 `TERM` 信号。它会发消息给其工人进程，要求它们立即退出，于是这些工人进程几乎会立即退出。如果没能退出，可以向它们发送 `KILL` 信号来强制退出。新主进程退出之后，旧主进程会自动启动新工人进程。

如果新的主进程退出，则旧主进程会丢弃 `.oldbin` 后缀，恢复 PID 文件名。

如果升级成功，应该向旧主进程发送 `QUIT` 信号，最后只留下新进程。































## 创建配置文件

nginx 也是使用文本格式的配置文件，默认文件名为 `/etc/nginx/nginx.conf`。




#### 指令

配置文件由指令及其参数组成。

简单指令以分号结尾。其它指令充当 “容器”，可以把相关的指令放在一起，外面用大括号包围，通常称之为 “块”。




#### 特定功能的配置文件

为了让配置更易于维护，建议把配置文件分割成一组特定功能的文件，保存在`/etc/nginx/conf.d` 目录中，然后在主配置文件中用 `include` 指令来引用。




#### contexts

有几个最高层的指令，被称为 context，它把应用到不同流量类型的指令集中到一起：

`events` ：一般连接的处理

`http` ：HTTP 流量

`mail` ：邮件流量

`stream` ：TCP 和 UDP 流量

置于这些 context 之外的指令被称为处于 main context 之中。


##### 虚拟服务器

在每个用来处理流量的 context 中，可以包含一个或多个 `server` 块来定义虚拟服务器，用它来控制对请求的处理。在 `server` 中可以容纳的指令依流量类型而有所不同。

对于 HTTP 流量来说，每个 `server` 指令是用来控制那些 “对特定域名或 IP 地址中资源的” 请求的。`server` 中，用一个或多个 `location` 来定义如何处理特定的网址。

对于 mail 和 TCP/UDP  流量来说，每个 `server` 指令用来控制 “抵达特定 TCP 端口或 UNIX 套接字的” 流量的处理。


##### 多 context 配置文件范例

```conf
user nobody; # 'main' context 中的一个指令

events {
    # 配置如何处理连接
}

http {
    # 此处配置为 HTTP 专用，并影响所有虚拟服务器  

    server {
        # 1 号 HTTP 虚拟服务器的配置
        location /one {
            # 如何处理以 '/one' 开头的网址
        }
        location /two {
            # 如何处理以 '/two' 开头的网址
        }
    }

    server {
        # 2 号 HTTP 虚拟服务器的配置
    }
}

stream {
    # 此处配置为 TCP/UDP 专用，并影响所有虚拟服务器
    server {
        # 1 号 TCP 虚拟服务器的配置
    }
}
```


##### 继承

一般来说，子 context 会继承上一层级指令的配置。有一些指令可以出现在多个 context 中，此时，子 context 中的指令会覆盖其从上层继承来的对应的指令。




#### 重载配置

要想让配置文件的修改生效，必须将其重载。可以重启 `nginx` 进程，也可以向其发送 `reload` 信号，更新配置的同时，不会打扰对当前请求的处理。
