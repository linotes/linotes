---
toc: true
toc_label: "Linux 的使用 - iptables"
toc_icon: "laptop"
title: "Linux 的使用 - iptables"
tags: linux iptables 防火墙
categories: "tools"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/linux.jpg
  overlay_filter: rgba(0, 0, 0, 0.6)
---






## 简介




### netfilter

在 Linux 2.4.x 以后的版本中，netfilter 是一款用于进行数据包过滤的框架，该框架中的软件有以下功能：

* 网络地址转换
* 数据包内容修改
* 数据包过滤

netfilter 是 Linux **内核** 中的一系列的 **钩子**，内核模块可以通过它们与协议栈注册回调函数，然后为每一个穿越对应钩子的数据包回调函数。iptables 通过与 netfilter 框架中的各种钩子进行交互，来实现防火墙的各种功能。

每个进入网络系统的数据包，无论出站还是入站，都会触发这些钩子，注册了这些钩子的程序，会在关键点上与数据流量进行交互。与 iptables 相关的内核模块，在这些钩子上注册，以确保流量符合防火墙规则所规定的条件。


#### netfilter 钩子

有 5 个 netfilter 的钩子可以让程序注册。当数据包通过堆栈时，它们会触发已在这些钩子上注册的内核模块。数据包会触发的钩子取决于数据包是入站的还是出站的，数据包的目标以及数据包在上一个点是否被丢弃或拒绝。

以下的钩子代表各个预定义的协议栈中的关键点：

* `NF_IP_PRE_ROUTING`: 入站流量进入协议栈之后，会触发这个钩子，该钩子会在进行任何路由决策之前进行处理。
* `NF_IP_LOCAL_IN`: 入站数据包被路由之后，如果它的目标是本机，就会触发这个钩子。
* `NF_IP_FORWARD`: 入站数据包被路由之后，如果它的目标是另一台主机，就会触发这个钩子。
* `NF_IP_LOCAL_OUT`: 本地产生的出站流量到达协议栈时，会触发这个钩子。
* `NF_IP_POST_ROUTING`: 出站或转发流量被路由后，从本地发出之前，会触发这个钩子。

希望在这些钩子上注册的内核模块必须提供一个优先级编号，以帮助确定在触发挂钩时它们将被调用的顺序。这为多个模块 (或同一模块的多个实例) 提供了以特定顺序连接到每个挂钩的方法。每个模块会被依次调用，并将在处理后向 netfilter 框架返回一个决定，即应该如何处理该数据包。




### iptables

iptables 是一个通用的 **表格** 结构，用于定义一系列的 **规则**。表格中的每条规则由若干个 **匹配** 和一个 **关联动作** 组成。

“netfilter，ip_tables（内核中的数据包过滤器），连接追踪，网络地址转换” 共同组成了 netfilter 框架的主要部分。

`iptables` 一词通常是指 Linux **内核** 中的防火墙，该防火墙是 netfilter 的一部分。iptables 是一个 **用户空间** 的程序，用来配置内核防火墙。因此，我们平时所说的 iptables 实际上指的是 netfilter/iptables，即框架中防火墙部分与前端的组合。
{: .notice}

针对不同的协议使用不同的内核模块。如 IPv4 使用 iptables，IPv6 使用 ip6tables，ARP 使用 arptables，以太帧使用 ebtables。

iptables 需要 root 权限来运行。通常安装于 `/usr/sbin/iptables` 目录。

虽然可以使用 `service iptables start` 启动，但准确的来说，iptables 没有守护进程，因此不是真正意义上的服务，只是内核提供的功能。

iptables 的继任者为 nftables，在内核版本 3.13 之后合并到 mainline。


























## IP 过滤器

IP Filter

iptables 是一个 IP 过滤器。

根据定义，IP 过滤器主要工作于 TCP/IP 协议栈的二层，不过 IP 过滤器是有能力在三层工作的，当今的大多数 IP 过滤器也大多工作于三层。在对定义实现的范围，不会严格遵守定义。

iptables 的工作是基于网络层与传输层的包头。iptables 和 netfilter 主要工作于网络层和传输层，它们所关注的协议主要为 IP、TCP、UDP、ICMP。








### 连接追踪

IP 过滤器不会跟随数据流，这样做太耗费 CPU 和内存，它只会 **追踪大量的数据包，观察它们是否属于同一个数据流**，这个行为称为连接追踪。就是因为有了连接追踪，我们才得以实现地址转换以及数据包状态匹配。

iptables 没有能力把不同的数据包中的数据连到一起，因此它任何时候都无从知道数据的真实内容。它更没有能力针对数据包中的内容进行匹配和过滤。








### IP 过滤相关名词



#### 丢弃

Drop/Deny

丢弃数据包。

如果数据包被 Drop 或 Deny，其实就是被 **删除** 了，**不会采取别的操作**。

没人会告诉发送端的主机数据包被丢弃了，接收端也不会知道。数据包就直接 **消失** 了。



#### 拒绝

Reject

拒绝数据包。

也是被 **删除** 了，但会 **告知发送端**。

拒绝数据包之后，会给发送端回复一条消息告知。



#### 接受

Accept

接受数据包，允许其穿越防火墙规则。



#### 数据包状态

State

某个数据包与整个数据流相比，它属于什么状态。数据包的状态是通过连接追踪系统获取的。

如果某数据包是防火墙看到的第一个包，如 TCP 连接中的 SYN 数据包，则认为其状态为 `new`。

如果某数据包属于一个已建立的连接，防火墙已经认识这个连接了，则该数据包的状态为 `established`。



#### 规则链

Chain

规则链包含一系列的规则，应用于那些穿越该链的数据包。

每个规则链都有其专门的目的及适用的范围。

* 目的：它应该连接到哪个表格，也就决定了该链的用途。
* 范围：只针对转发的数据包，还是只针对入站的数据包。



#### 表格

Table

每个表有着专门的用途，共有 4 张表：raw，nat，mangle，filter。

filter 表格专门用于过滤数据包，nat 表格专用于为数据包进行地址转换。



#### 匹配

该词通常有两个不同的意思：

* 一个具体的匹配：如源地址匹配某网段或网址。
* 一条规则整体的匹配：如果数据包匹配整条规则，会对其执行相应的操作，即 jump 或 target 指令。

因为一条规则可以有多个具体的匹配，所以整体的匹配可能意味着同时匹配多个条件。



#### 目标

Target

通常每条规则都会配置一个目标，即如果数据包完全满足该条规则时，应该对其进行什么 **操作**。

如，目标可以是丢弃、接受、地址转换等。



#### 规则

Rule

规则由一个或多个 **匹配** 和一个 **目标** 组成。



#### 规则集

Ruleset

规则集是指在 filter，nat，raw，mangle 表格中的所有规则的集合，以及之后产生的规则链中的规则。

大多数时间，规则集是写在一个配置文件中的。



#### 跳转

Jump

跳转指令与 **目标** 是紧密相关的。跳转指令的书写方式与目标是一样的，唯一的区别是，跳转指令使用的不是目标的名称，而是另一条规则链的名称。

如果匹配规则，数据包会被 **发送到另一条规则链来处理**。



#### 连接追踪

Connection Tracking

防火墙如果具有连接追踪功能，它就有能力追踪连接或数据流。但是，连接追踪会消耗一定的 CPU 与内存资源。



#### 策略

Policy

如果没有规则能匹配数据包，防火墙应该采取的 **默认行为**。












### IP 过滤器的部署

在使用防火墙时，我们通常会按两种方式来部署，即黑名单与白名单。



#### 白名单

默认丢弃所有数据包，只有匹配规则的允许通过。



#### 黑名单

默认接受所有数据包，只有匹配规则的会被丢弃。

白名单相对来说更加安全，但需要更多的。



























## 网络地址转换

NAT：Network Address Translation

要想使用 NAT 功能，无需 Cisco PIX ，iptables 就可以实现。







### NAT 简介

通过 NAT 可以让一台或多台主机共享同一个 IP 地址。

NAT 服务器可以把数据包的源地址、目的地址转换成其它的地址。


#### SNAT

Source Network Address Translation

在实际生产中，公共 IP 地址资源极其有限。因此，在本地网中的多个主机可以使用不同的私网地址。为本地网络打开 SNAT 服务之后，SNAT 会把所有的私有地址转换成公司自己的公共 IP 地址。


#### DNAT

Destination Network Address Translation

DNAT 更适用于多个服务器。

一方面，节省了公共 IP 资源；另一方面，可以在代理服务器与后端服务器中间，很容易地建立起一个难以穿透的防火墙。也可以让多个服务器共享一个公共 IP 地址。



























## 穿越表格和规则链

数据包是是以什么样的顺序、如何穿越不同的表格和规则链的？一个数据包首次抵达防火墙时，网络设备收到并它传递给内核中对应的设备驱动程序。数据包开始一系列的穿越，最后，它要么是被发送给适当的本地应用程序，要么被转发给其它主机。

规则的类别：iptables 使用表格来组织规则。根据所用来制定决策的类型，这些表格把规则分为不同的类别。

例如，如果某条规则是用来处理网络地址转换的，它会被放置于 nat 表格。如果规则是用来决定是否允许数据包继续向目标传递的，可能会置于 filter 表格。

规则链：在每个 iptables 表格中，所有的规则又进一步被置于独立的规则链中。每个表格所承载的规则都有不同的用途，正是该用途定义了表格。内置的规则链代表了触发它们的 netfilter 钩子。规则链基本上决定了规则将在何时被评估。







### iptables 内置表格


#### Mangle 表格

mangle 表格主要用于修改数据包的 IP 头，如 TOS、TTL 等。

该表格还可以在数据包上做一个内核内部的标记，用于在其它表格中做进一步的处理。这个标记不会触及到真正的数据。

以下目标仅适用于 mangle 表格，不能在 mangle 表格之外使用：

* TOS
* TTL
* MARK
* SECMARK
* CONNSECMARK


#### Nat 表格

该表格只用于 NAT。

当数据包进入协议栈时，该表格中的规则会判断是否需要 NAT，以及如何进行，从而影响数据包及所在流量的路由。通常用于把数据包路由到无法直接访问的网络中。

只有数据流的 **第一个数据包** 才会进入这张表，对其后面的数据包会自动采取同样的地址转换操作。

真正完成这些工作的目标为：

* DNAT
* SNAT
* MASQUERADE
* REDIRECT


#### Raw 表格

raw 表格的功能特别单一，即标记数据包，使其不会被连接追踪系统处理。该功能是由 NOTRACK 目标实现的。

如果连接撞到 NOTRACK 目标，就不会对其进行追踪。

该表中只有 PREROUTING 和 OUTPUT 链。

iptables 防火墙是区分状态的，意味着评估数据包时会考量它与之前数据包的关系。连接追踪是建立在 netfilter 框架上的，iptables 会把数据包做为当前连接或会话的一部分来看待，并不会将其视为离散的、不相关的数据包。连接追踪的逻辑在数据包抵达网络接口之后不久就开始应用了。


#### Filter 表格

过滤表主要用于过滤数据包。它是使用最多的表格。

该表格用于判断是否允许数据包继续向其目标前行。可以对匹配的数据包进行过滤。在这里可以查看数据包里包含什么内容，根据需要决定丢弃还是接受。平时我们所讨论的防火墙的功能，大部分由该表格实现。

几乎所有的目标在此表格都能使用。

>有些内核还有第五张表格，即 Security 表格，用于由 SELinux 部署安全策略。









### iptables 规则链

通过使用规则链，可以控制在数据包的传递路径中，应该从 **哪个位置** 开始评估规则。因为每张表都有多条链，所以表格的影响力可以在处理过程中的多个位置呈现。由于特定类型的决策只有在协议栈的特定位置才有意义，因此，不是每张表中都有所有的规则链。


#### 内置规则链

内置的规则链其名称实际上反映了它们对应的 netfilter 钩子的名称：

* `PREROUTING`: 由勾子 `NF_IP_PRE_ROUTING` 触发。路由决策之前，数据包会进入该链。不要在此链进行过滤，有些情况会被绕过。
* `INPUT`: 由勾子 `NF_IP_LOCAL_IN` 触发。进入该链的数据包会传递给本机来处理。这与开着 socket 的进程无关，本地的数据传递是由 `local-delivery` 路由表控制的。
* `FORWARD`: 由勾子 `NF_IP_FORWARD` 触发。已被路由的数据包，如果目的地不是本机，则走该链
* `OUTPUT`: 由勾子 `NF_IP_LOCAL_OUT` 触发。从本机产生的数据包走该链
* `POSTROUTING`: 由勾子 `NF_IP_POST_ROUTING` 触发。路由决策已经完成，在交给网络设备之前，数据包进入该链

只有五种 netfilter 内核钩子，因此，来自不同表格的链是注册在每个钩子上的。例如，三张表格中有 `PREROUTING` 链，当这些链在对应的 `NF_IP_PRE_ROUTING` 钩子上注册时，它们会设定一个优先级，以决定这些表格中的 `PREROUTING` 链应该以什么 **顺序** 执行，优先级最高的 `PREROUTING` 链最先执行。


#### 自定义规则链

如果数据包从过滤表中进入一条规则链，如 INPUT，我们可以指定一个跳转的规则，以跳转同一张表中的另一条链上。跳转的链必须是用户自定义的，不能是系统内置的链。

![image-center](/assets/images/table_subtraverse.jpg){: .align-center}

用户自定义的规则链无法在链尾定义默认策略，只有系统内置的链才可以。解决的办法是在自定义链的结尾加一条规则，针对所有不匹配的数据包，它就可以当作默认策略来使用了。自定义规则链如果没有任何匹配，默认是会跳转返回源链的。









### 表格与链的关系

如果三个表格中都有 `PREROUTING` 链，它们以什么顺序进行评估呢？

下表展示了每张表中包含的各条规则链，从左至右。例如，raw 表格有 `PREROUTING` 和 `OUTPUT` 链。从上到下观察，展示了每条链是以怎样的顺序调用的。

下表中的 NAT 表被拆分为 DNAT 和 SNAT，以便于更清晰地定位其顺序。同时还加入了路由决策以及启用连接追踪的行，用以代表对应的点。

表格↓ / 链→               | PREROUTING | INPUT | FORWARD | OUTPUT | POSTROUTING
----------------------------- |:----------:|:-----:|:-------:|:------:|:-----------:
(路由决策)            |            |       |         |   ✓    |            
**raw**                       |     ✓      |       |         |   ✓    |            
(启用连接追踪) |     ✓      |       |         |   ✓    |            
**mangle**                    |     ✓      |   ✓   |    ✓    |   ✓    |      ✓     
**nat** (DNAT)                |     ✓      |       |         |   ✓    |            
(路由决策)            |     ✓      |       |         |   ✓    |            
**filter**                    |            |   ✓   |    ✓    |   ✓    |            
**nat** (SNAT)                |            |   ✓   |         |        |      ✓     

数据包触发一个钩子时，相关的规则链开始处理，就按照上表中的顺序，从上至下。

钩子对应的是每一列，数据包会触发哪个钩子决定于它是入站还是出站的、路由决策是什么、数据包是否通过了过滤规则。

某些事件会导致表格中的某个链被跳过。例如，只有连接中的第一个数据包才会用 NAT 规则来评估，对第一个数据包做出的任何决策都会应用于连接中随后的数据包，不会对它们进行额外的评估。对于经 NAT 处理过的连接，它们会自动拥有反向 NAT 规则，以便正确路由。


#### 规则链的穿越顺序

假设服务器了解如何路由一个数据包，而且防火墙的规则也允许其传输，以下的流程则不同情况下数据包所穿越的路径：

* 入站数据包 ：`PREROUTING` -> `INPUT`
* 转发数据包 ：`PREROUTING` -> `FORWARD` -> `POSTROUTING`
* 本地生成的数据包 ： `OUTPUT` -> `POSTROUTING`

将这些信息与上表联系起来，就得到了各种数据包所穿越的不同节点。

![image-center](/assets/images/iptables.travering.png){: .align-center}


##### 入站数据包

入站的数据包会经历如下的步骤，最后才会真正被传递给接收它的应用程序：

数据包的目的地为本地主机。

步骤 | 表格 | 规则链 | 说明   
---- | ------ | ------ | -----------
1    |        |            | 在互联网上传输
2    |        |            | 从网络设备接口进入主机
3    | raw    | PREROUTING | 该链用于连接追踪开始之前对数据包的处理，例如可以设定一个连接，让其不会被连接追踪。
4    |        |            | 连接追踪开始
5    | mangle | PREROUTING | 该链通常用于修改数据包，即修改 TOS、TTL 等
6    | nat    | PREROUTING | 该链主要用于 DNAT，不要在此链进行过滤，有些情况会被绕过
7    |        |            | 路由决策，本地处理还是转发
8    | mangle | INPUT      | 使用该链修改数据包的 TOS、TTL
9    | filter | INPUT      | 目的为本机的数据包在此进入该链，开始接受过滤，无论从哪个接口、哪个方向进来的，
10   |        |            | 把数据包交由本机处理，或发送给对应的应用程序

上表中的数据包只是穿越了 INPUT 规则链，并没有穿越 FORWARD 链。


##### 出站数据包

数据包从本地主机发出。

步骤 | 表格 | 规则链 | 说明   
---- | ------ | ------ | -----------
1    |        |             | 本地处理，或应用程序
2    |        |             | 路由决策。应使用哪个源地址，从哪个接口出站，及其它信息
3    | raw    | OUTPUT      | 在连接追踪开始之前，对本地生成的数据包进行处理，可标记连接，对其不进行连接追踪
4    |        |             | 连接追踪开始
5    | mangle | OUTPUT      | 修改数据包。建议不要过滤该链，会有副作用
6    | nat    | OUTPUT      | 该链用于从防火墙自身 NAT 出站数据包
7    |        |             | 路由决策。因为上面的 mangle 和 nat 可能改变了数据包的路由
8    | filter | OUTPUT      | 对出站数据包进行过滤
9    | mangle | POSTROUTING | 数据包确定路由之后、出站之前，可以再次修改。穿越至防火墙的数据包和防火墙自身产生的数据包都会撞到该链。
10   | nat    | POSTROUTING | SNAT 开始，建议不要过滤，因为有些数据包有可能会溜出去，即使默认策略为丢弃也没用。
11   |        |             | 从某网络接口出站
12   |        |             | 飞到互联网上

##### 转发数据包

数据包是奔向另一主机或另一网络的：

步骤 | 表格 | 规则链 | 说明   
---- | ------ | ------ | -----------
1    |        |        | 在互联网上传输
2    |        |        | 从网络设备接口进入主机                                       
3    | raw    | PREROUTING | 可以设定一个连接，让其不会被连接追踪。
4    |        |         | 连接追踪开始
5    | mangle | PREROUTING  | 修改 TOS、TTL
6    | nat    | PREROUTING  | 该链主要用于 DNAT，不要在此链进行过滤，有些情况会被绕过
7    |        |             | 路由决策，本地处理还是转发
8    | mangle | FORWARD     | 使用该链修改数据包的 TOS、TTL
9    | filter | FORWARD     | 对数据包进行过滤
10   | mangle | POSTROUTING | 使用该链修改数据包的 TOS、TTL
11   | nat    | POSTROUTING | SNAT 开始，建议不要过滤，有些数据包有可能会溜出去。伪装也是在这一步进行。
12   |        |             | 从某网络接口出站
13   |        |             | 飞到互联网上

虽然规则链很多，但是没有专门针对特定网络接口的。

































## iptables 规则

规则被置于链中，链置于表中。每个链被调用时，会用其中的规则依次对数据包进行检查。

每条规则都有一个 **匹配** 组件和一个 **动作** 组件。




### 匹配

规则中的匹配部分，用于指定数据包必须满足的条件，以便最终执行相关的动作（或目标）。

匹配的系统非常灵活，可以用系统中可用的 iptables 扩展来实施更强大的匹配。

构建规则时可以使用协议类型、目标地址、源地址、目标端口、源端口、目标网络、源网络、输入接口、输出接口、包头、连接状态等。可以把多个要素组合起来，创建相当复杂的规则集，用来区分不同的流量。




### 目标

目标，是数据包满足规则中匹配的条件时，所触发的动作。

目标主要分为两类：


#### 中止型目标

中止型目标，它所进行的操作会中止对规则链的评估，将控制返还给 netfilter 钩子。根据返回值，钩子丢弃或允许数据包进入下一步流程。


#### 非中止型目标

非中止型目标完成操作以后，会继续对规则链的评估。
























## 跳转至自定义链

有一种特殊类型的非中止型目标：跳转目标，jump target。

跳转目标就是在评估后跳转到另一个链，进行其它的处理。

除了系统内置的链，用户还可以根据需要创建自己的链，在链中放置自定义的规则。区别在于，用户创建的链只能通过跳转来使用，因为它们没有注册自己的 netfilter 钩子。

用户自定义的链就是对调用它的链的单纯的扩展。例如，在自定义链中，如果到达规则列表结尾，或匹配的规则激活了 RETURN 目标，评估会被传回给调用它的链。当然，如果需要，还可以再次跳转到其它的自定义链上。

这种跳转的结构可以实现更加丰富的功能，并为框架提供更强健的分支。



















## 连接追踪

借助连接追踪，iptables 可以对所追踪的连接的数据包进行决策。连接追踪系统为 iptables 带来它所需要的 **状态化** 的操作。

数据包进入协议栈不久就会应用连接追踪，先对数据包应用 raw 表格中的链，进行一些基本的健康检查，然后才能将其与某个连接关联到一起。

追踪系统会检查每个数据包，将其与已知的连接相比对。需要时，它会更新其仓库中连接的状态，并向系统中增加新的连接。raw 链中被标记了 NOTRACK 目标的数据包不会被追踪。



### 可用的状态

被追踪的连接其状态有以下几种：

#### `NEW`
