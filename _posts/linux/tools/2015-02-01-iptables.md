---
toc: true
toc_label: "Linux 的使用 - iptables"
toc_icon: "laptop"
title: "Linux 的使用 - iptables"
tags: linux iptables 防火墙
categories: "tools"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/linux.jpg
  overlay_filter: rgba(0, 0, 0, 0.6)
---






## 简介




### netfilter

在 Linux 2.4.x 以后的版本中，netfilter 是一款用于进行数据包过滤的框架，该框架中的软件有以下功能：

* 网络地址转换
* 数据包内容修改
* 数据包过滤

netfilter 是 Linux **内核** 中的一系列的 **钩子**，内核模块可以通过它们与协议栈注册回调函数，然后为每一个穿越对应钩子的数据包回调函数。iptables 通过与 netfilter 框架中的各种钩子进行交互，来实现防火墙的各种功能。

每个进入网络系统的数据包，无论出站还是入站，都会触发这些钩子，注册了这些钩子的程序，会在关键点上与数据流量进行交互。与 iptables 相关的内核模块，在这些钩子上注册，以确保流量符合防火墙规则所规定的条件。


#### netfilter 钩子

有 5 个 netfilter 的钩子可以让程序注册。当数据包通过堆栈时，它们会触发已在这些钩子上注册的内核模块。数据包会触发的钩子取决于数据包是入站的还是出站的，数据包的目标以及数据包在上一个点是否被丢弃或拒绝。

以下的钩子代表各个预定义的协议栈中的关键点：

* `NF_IP_PRE_ROUTING`: 入站流量进入协议栈之后，会触发这个钩子，该钩子会在进行任何路由决策之前进行处理。
* `NF_IP_LOCAL_IN`: 入站数据包被路由之后，如果它的目标是本机，就会触发这个钩子。
* `NF_IP_FORWARD`: 入站数据包被路由之后，如果它的目标是另一台主机，就会触发这个钩子。
* `NF_IP_LOCAL_OUT`: 本地产生的出站流量到达协议栈时，会触发这个钩子。
* `NF_IP_POST_ROUTING`: 出站或转发流量被路由后，从本地发出之前，会触发这个钩子。

希望在这些钩子上注册的内核模块必须提供一个优先级编号，以帮助确定在触发挂钩时它们将被调用的顺序。这为多个模块 (或同一模块的多个实例) 提供了以特定顺序连接到每个挂钩的方法。每个模块会被依次调用，并将在处理后向 netfilter 框架返回一个决定，即应该如何处理该数据包。




### iptables

iptables 是一个通用的 **表格** 结构，用于定义一系列的 **规则**。表格中的每条规则由若干个 **匹配** 和一个 **关联动作** 组成。

“netfilter，ip_tables（内核中的数据包过滤器），连接追踪，网络地址转换” 共同组成了 netfilter 框架的主要部分。

`iptables` 一词通常是指 Linux **内核** 中的防火墙，该防火墙是 netfilter 的一部分。iptables 是一个 **用户空间** 的程序，用来配置内核防火墙。因此，我们平时所说的 iptables 实际上指的是 netfilter/iptables，即框架中防火墙部分与前端的组合。
{: .notice}

针对不同的协议使用不同的内核模块。如 IPv4 使用 iptables，IPv6 使用 ip6tables，ARP 使用 arptables，以太帧使用 ebtables。

iptables 需要 root 权限来运行。通常安装于 `/usr/sbin/iptables` 目录。

虽然可以使用 `service iptables start` 启动，但准确的来说，iptables 没有守护进程，因此不是真正意义上的服务，只是内核提供的功能。

iptables 的继任者为 nftables，在内核版本 3.13 之后合并到 mainline。


























## IP 过滤器

IP Filter

iptables 是一个 IP 过滤器。

根据定义，IP 过滤器主要工作于 TCP/IP 协议栈的二层，不过 IP 过滤器是有能力在三层工作的，当今的大多数 IP 过滤器也大多工作于三层。在对定义实现的范围，不会严格遵守定义。

iptables 的工作是基于网络层与传输层的包头。iptables 和 netfilter 主要工作于网络层和传输层，它们所关注的协议主要为 IP、TCP、UDP、ICMP。








### 连接追踪

IP 过滤器不会跟随数据流，这样做太耗费 CPU 和内存，它只会 **追踪大量的数据包，观察它们是否属于同一个数据流**，这个行为称为连接追踪。就是因为有了连接追踪，我们才得以实现地址转换以及数据包状态匹配。

iptables 没有能力把不同的数据包中的数据连到一起，因此它任何时候都无从知道数据的真实内容。它更没有能力针对数据包中的内容进行匹配和过滤。








### IP 过滤相关名词



#### 丢弃

Drop/Deny

丢弃数据包。

如果数据包被 Drop 或 Deny，其实就是被 **删除** 了，**不会采取别的操作**。

没人会告诉发送端的主机数据包被丢弃了，接收端也不会知道。数据包就直接 **消失** 了。



#### 拒绝

Reject

拒绝数据包。

也是被 **删除** 了，但会 **告知发送端**。

拒绝数据包之后，会给发送端回复一条消息告知。



#### 接受

Accept

接受数据包，允许其穿越防火墙规则。



#### 数据包状态

State

某个数据包与整个数据流相比，它属于什么状态。数据包的状态是通过连接追踪系统获取的。

如果某数据包是防火墙看到的第一个包，如 TCP 连接中的 SYN 数据包，则认为其状态为 `new`。

如果某数据包属于一个已建立的连接，防火墙已经认识这个连接了，则该数据包的状态为 `established`。



#### 规则链

Chain

规则链包含一系列的规则，应用于那些穿越该链的数据包。

每个规则链都有其专门的目的及适用的范围。

* 目的：它应该连接到哪个表格，也就决定了该链的用途。
* 范围：只针对转发的数据包，还是只针对入站的数据包。



#### 表格

Table

每个表有着专门的用途，共有 4 张表：raw，nat，mangle，filter。

filter 表格专门用于过滤数据包，nat 表格专用于为数据包进行地址转换。



#### 匹配

该词通常有两个不同的意思：

* 一个具体的匹配：如源地址匹配某网段或网址。
* 一条规则整体的匹配：如果数据包匹配整条规则，会对其执行相应的操作，即 jump 或 target 指令。

因为一条规则可以有多个具体的匹配，所以整体的匹配可能意味着同时匹配多个条件。



#### 目标

Target

通常每条规则都会配置一个目标，即如果数据包完全满足该条规则时，应该对其进行什么 **操作**。

如，目标可以是丢弃、接受、地址转换等。



#### 规则

Rule

规则由一个或多个 **匹配** 和一个 **目标** 组成。



#### 规则集

Ruleset

规则集是指在 filter，nat，raw，mangle 表格中的所有规则的集合，以及之后产生的规则链中的规则。

大多数时间，规则集是写在一个配置文件中的。



#### 跳转

Jump

跳转指令与 **目标** 是紧密相关的。跳转指令的书写方式与目标是一样的，唯一的区别是，跳转指令使用的不是目标的名称，而是另一条规则链的名称。

如果匹配规则，数据包会被 **发送到另一条规则链来处理**。



#### 连接追踪

Connection Tracking

防火墙如果具有连接追踪功能，它就有能力追踪连接或数据流。但是，连接追踪会消耗一定的 CPU 与内存资源。



#### 策略

Policy

如果没有规则能匹配数据包，防火墙应该采取的 **默认行为**。












### IP 过滤器的部署

在使用防火墙时，我们通常会按两种方式来部署，即黑名单与白名单。



#### 白名单

默认丢弃所有数据包，只有匹配规则的允许通过。



#### 黑名单

默认接受所有数据包，只有匹配规则的会被丢弃。

白名单相对来说更加安全，但需要更多的。



























## 网络地址转换

NAT：Network Address Translation

要想使用 NAT 功能，无需 Cisco PIX ，iptables 就可以实现。







### NAT 简介

通过 NAT 可以让一台或多台主机共享同一个 IP 地址。

NAT 服务器可以把数据包的源地址、目的地址转换成其它的地址。


#### SNAT

Source Network Address Translation

在实际生产中，公共 IP 地址资源极其有限。因此，在本地网中的多个主机可以使用不同的私网地址。为本地网络打开 SNAT 服务之后，SNAT 会把所有的私有地址转换成公司自己的公共 IP 地址。


#### DNAT

Destination Network Address Translation

DNAT 更适用于多个服务器。

一方面，节省了公共 IP 资源；另一方面，可以在代理服务器与后端服务器中间，很容易地建立起一个难以穿透的防火墙。也可以让多个服务器共享一个公共 IP 地址。



























## 穿越表格和规则链

数据包是是以什么样的顺序、如何穿越不同的表格和规则链的？一个数据包首次抵达防火墙时，网络设备收到并它传递给内核中对应的设备驱动程序。数据包开始一系列的穿越，最后，它要么是被发送给适当的本地应用程序，要么被转发给其它主机。

规则的类别：iptables 使用表格来组织规则。根据所用来制定决策的类型，这些表格把规则分为不同的类别。

例如，如果某条规则是用来处理网络地址转换的，它会被放置于 nat 表格。如果规则是用来决定是否允许数据包继续向目标传递的，可能会置于 filter 表格。

规则链：在每个 iptables 表格中，所有的规则又进一步被置于独立的规则链中。每个表格所承载的规则都有不同的用途，正是该用途定义了表格。内置的规则链代表了触发它们的 netfilter 钩子。规则链基本上决定了规则将在何时被评估。







### iptables 内置表格


#### Mangle 表格

mangle 表格主要用于修改数据包的 IP 头，如 TOS、TTL 等。

该表格还可以在数据包上做一个内核内部的标记，用于在其它表格中做进一步的处理。这个标记不会触及到真正的数据。

以下目标仅适用于 mangle 表格，不能在 mangle 表格之外使用：

* TOS
* TTL
* MARK
* SECMARK
* CONNSECMARK


#### Nat 表格

该表格只用于 NAT。

当数据包进入协议栈时，该表格中的规则会判断是否需要 NAT，以及如何进行，从而影响数据包及所在流量的路由。通常用于把数据包路由到无法直接访问的网络中。

只有数据流的 **第一个数据包** 才会进入这张表，对其后面的数据包会自动采取同样的地址转换操作。

真正完成这些工作的目标为：

* DNAT
* SNAT
* MASQUERADE
* REDIRECT


#### Raw 表格

raw 表格的功能特别单一，即标记数据包，使其不会被连接追踪系统处理。该功能是由 NOTRACK 目标实现的。

如果连接撞到 NOTRACK 目标，就不会对其进行追踪。

该表中只有 PREROUTING 和 OUTPUT 链。

iptables 防火墙是区分状态的，意味着评估数据包时会考量它与之前数据包的关系。连接追踪是建立在 netfilter 框架上的，iptables 会把数据包做为当前连接或会话的一部分来看待，并不会将其视为离散的、不相关的数据包。连接追踪的逻辑在数据包抵达网络接口之后不久就开始应用了。


#### Filter 表格

过滤表主要用于过滤数据包。它是使用最多的表格。

该表格用于判断是否允许数据包继续向其目标前行。可以对匹配的数据包进行过滤。在这里可以查看数据包里包含什么内容，根据需要决定丢弃还是接受。平时我们所讨论的防火墙的功能，大部分由该表格实现。

几乎所有的目标在此表格都能使用。

>有些内核还有第五张表格，即 Security 表格，用于由 SELinux 部署安全策略。









### iptables 规则链

通过使用规则链，可以控制在数据包的传递路径中，应该从 **哪个位置** 开始评估规则。因为每张表都有多条链，所以表格的影响力可以在处理过程中的多个位置呈现。由于特定类型的决策只有在协议栈的特定位置才有意义，因此，不是每张表中都有所有的规则链。


#### 内置规则链

内置的规则链其名称实际上反映了它们对应的 netfilter 钩子的名称：

* `PREROUTING`: 由勾子 `NF_IP_PRE_ROUTING` 触发。路由决策之前，数据包会进入该链。不要在此链进行过滤，有些情况会被绕过。
* `INPUT`: 由勾子 `NF_IP_LOCAL_IN` 触发。进入该链的数据包会传递给本机来处理。这与开着 socket 的进程无关，本地的数据传递是由 `local-delivery` 路由表控制的。
* `FORWARD`: 由勾子 `NF_IP_FORWARD` 触发。已被路由的数据包，如果目的地不是本机，则走该链
* `OUTPUT`: 由勾子 `NF_IP_LOCAL_OUT` 触发。从本机产生的数据包走该链
* `POSTROUTING`: 由勾子 `NF_IP_POST_ROUTING` 触发。路由决策已经完成，在交给网络设备之前，数据包进入该链

只有五种 netfilter 内核钩子，因此，来自不同表格的链是注册在每个钩子上的。例如，三张表格中有 `PREROUTING` 链，当这些链在对应的 `NF_IP_PRE_ROUTING` 钩子上注册时，它们会设定一个优先级，以决定这些表格中的 `PREROUTING` 链应该以什么 **顺序** 执行，优先级最高的 `PREROUTING` 链最先执行。


#### 自定义规则链

如果数据包从过滤表中进入一条规则链，如 INPUT，我们可以指定一个跳转的规则，以跳转同一张表中的另一条链上。跳转的链必须是用户自定义的，不能是系统内置的链。

![image-center](/assets/images/table_subtraverse.jpg){: .align-center}

用户自定义的规则链无法在链尾定义默认策略，只有系统内置的链才可以。解决的办法是在自定义链的结尾加一条规则，针对所有不匹配的数据包，它就可以当作默认策略来使用了。自定义规则链如果没有任何匹配，默认是会跳转返回源链的。









### 表格与链的关系

如果三个表格中都有 `PREROUTING` 链，它们以什么顺序进行评估呢？

下表展示了每张表中包含的各条规则链，从左至右。例如，raw 表格有 `PREROUTING` 和 `OUTPUT` 链。从上到下观察，展示了每条链是以怎样的顺序调用的。

下表中的 NAT 表被拆分为 DNAT 和 SNAT，以便于更清晰地定位其顺序。同时还加入了路由决策以及启用连接追踪的行，用以代表对应的点。

表格↓ / 链→               | PREROUTING | INPUT | FORWARD | OUTPUT | POSTROUTING
----------------------------- |:----------:|:-----:|:-------:|:------:|:-----------:
(路由决策)            |            |       |         |   ✓    |            
**raw**                       |     ✓      |       |         |   ✓    |            
(启用连接追踪) |     ✓      |       |         |   ✓    |            
**mangle**                    |     ✓      |   ✓   |    ✓    |   ✓    |      ✓     
**nat** (DNAT)                |     ✓      |       |         |   ✓    |            
(路由决策)            |     ✓      |       |         |   ✓    |            
**filter**                    |            |   ✓   |    ✓    |   ✓    |            
**nat** (SNAT)                |            |   ✓   |         |        |      ✓     

数据包触发一个钩子时，相关的规则链开始处理，就按照上表中的顺序，从上至下。

钩子对应的是每一列，数据包会触发哪个钩子决定于它是入站还是出站的、路由决策是什么、数据包是否通过了过滤规则。

某些事件会导致表格中的某个链被跳过。例如，只有连接中的第一个数据包才会用 NAT 规则来评估，对第一个数据包做出的任何决策都会应用于连接中随后的数据包，不会对它们进行额外的评估。对于经 NAT 处理过的连接，它们会自动拥有反向 NAT 规则，以便正确路由。


#### 规则链的穿越顺序

假设服务器了解如何路由一个数据包，而且防火墙的规则也允许其传输，以下的流程则不同情况下数据包所穿越的路径：

* 入站数据包 ：`PREROUTING` -> `INPUT`
* 转发数据包 ：`PREROUTING` -> `FORWARD` -> `POSTROUTING`
* 本地生成的数据包 ： `OUTPUT` -> `POSTROUTING`

将这些信息与上表联系起来，就得到了各种数据包所穿越的不同节点。

![image-center](/assets/images/iptables.travering.png){: .align-center}


##### 入站数据包

入站的数据包会经历如下的步骤，最后才会真正被传递给接收它的应用程序：

数据包的目的地为本地主机。

步骤 | 表格 | 规则链 | 说明   
---- | ------ | ------ | -----------
1    |        |            | 在互联网上传输
2    |        |            | 从网络设备接口进入主机
3    | raw    | PREROUTING | 该链用于连接追踪开始之前对数据包的处理，例如可以设定一个连接，让其不会被连接追踪。
4    |        |            | 连接追踪开始
5    | mangle | PREROUTING | 该链通常用于修改数据包，即修改 TOS、TTL 等
6    | nat    | PREROUTING | 该链主要用于 DNAT，不要在此链进行过滤，有些情况会被绕过
7    |        |            | 路由决策，本地处理还是转发
8    | mangle | INPUT      | 使用该链修改数据包的 TOS、TTL
9    | filter | INPUT      | 目的为本机的数据包在此进入该链，开始接受过滤，无论从哪个接口、哪个方向进来的，
10   |        |            | 把数据包交由本机处理，或发送给对应的应用程序

上表中的数据包只是穿越了 INPUT 规则链，并没有穿越 FORWARD 链。


##### 出站数据包

数据包从本地主机发出。

步骤 | 表格 | 规则链 | 说明   
---- | ------ | ------ | -----------
1    |        |             | 本地处理，或应用程序
2    |        |             | 路由决策。应使用哪个源地址，从哪个接口出站，及其它信息
3    | raw    | OUTPUT      | 在连接追踪开始之前，对本地生成的数据包进行处理，可标记连接，对其不进行连接追踪
4    |        |             | 连接追踪开始
5    | mangle | OUTPUT      | 修改数据包。建议不要过滤该链，会有副作用
6    | nat    | OUTPUT      | 该链用于从防火墙自身 NAT 出站数据包
7    |        |             | 路由决策。因为上面的 mangle 和 nat 可能改变了数据包的路由
8    | filter | OUTPUT      | 对出站数据包进行过滤
9    | mangle | POSTROUTING | 数据包确定路由之后、出站之前，可以再次修改。穿越至防火墙的数据包和防火墙自身产生的数据包都会撞到该链。
10   | nat    | POSTROUTING | SNAT 开始，建议不要过滤，因为有些数据包有可能会溜出去，即使默认策略为丢弃也没用。
11   |        |             | 从某网络接口出站
12   |        |             | 飞到互联网上

##### 转发数据包

数据包是奔向另一主机或另一网络的：

步骤 | 表格 | 规则链 | 说明   
---- | ------ | ------ | -----------
1    |        |        | 在互联网上传输
2    |        |        | 从网络设备接口进入主机                                       
3    | raw    | PREROUTING | 可以设定一个连接，让其不会被连接追踪。
4    |        |         | 连接追踪开始
5    | mangle | PREROUTING  | 修改 TOS、TTL
6    | nat    | PREROUTING  | 该链主要用于 DNAT，不要在此链进行过滤，有些情况会被绕过
7    |        |             | 路由决策，本地处理还是转发
8    | mangle | FORWARD     | 使用该链修改数据包的 TOS、TTL
9    | filter | FORWARD     | 对数据包进行过滤
10   | mangle | POSTROUTING | 使用该链修改数据包的 TOS、TTL
11   | nat    | POSTROUTING | SNAT 开始，建议不要过滤，有些数据包有可能会溜出去。伪装也是在这一步进行。
12   |        |             | 从某网络接口出站
13   |        |             | 飞到互联网上

虽然规则链很多，但是没有专门针对特定网络接口的。

























## 跳转至自定义链

有一种特殊类型的非中止型目标：跳转目标，jump target。

跳转目标就是在评估后跳转到另一个链，进行其它的处理。

除了系统内置的链，用户还可以根据需要创建自己的链，在链中放置自定义的规则。区别在于，用户创建的链只能通过跳转来使用，因为它们没有注册自己的 netfilter 钩子。

用户自定义的链就是对调用它的链的单纯的扩展。例如，在自定义链中，如果到达规则列表结尾，或匹配的规则激活了 RETURN 目标，评估会被传回给调用它的链。当然，如果需要，还可以再次跳转到其它的自定义链上。

这种跳转的结构可以实现更加丰富的功能，并为框架提供更强健的分支。



















## 连接追踪

借助连接追踪，iptables 可以对所追踪的连接的数据包进行决策。连接追踪系统为 iptables 带来它所需要的 **状态化** 的操作。

数据包进入协议栈不久就会应用连接追踪，先对数据包应用 raw 表格中的链，进行一些基本的健康检查，然后才能将其与某个连接关联到一起。

追踪系统会检查每个数据包，将其与已知的连接相比对。需要时，它会更新其仓库中连接的状态，并向系统中增加新的连接。raw 链中被标记了 NOTRACK 目标的数据包不会被追踪。



### 可用的状态

被追踪的连接其状态有以下几种：

#### `NEW`

如果收到的数据包与现有的连接均无关联，但做为第一个数据包，它不是无效的，会使用 `NEW` 标签向系统添加一个新的连接。无论是连接感知型协议如 TCP，还是非连接协议如 UDP，都会如此。

#### `ESTABLISHED`

当某个连接收到对端的一个有效的应答时，其状态由 `NEW` 变为 `ESTABLISHED`。对于 TCP 连接来说，意味着 SYN/ACK，对于 UDP 和 ICMP 流量来说，意味着一个应答，其中源与目标应该被互换了。

#### `RELATED`

如果数据包不属于现有的连接，但与系统中的某个连接有关联，其状态为 `RELATED`。这种有可能是一个辅助连接，例如 FTP 的数据传输连接，或其它协议尝试连接时收到的 ICMP 应答。

#### `INVALID`

如果数据包与现有连接无关，而且也不属于新连接，如果数据包无法被识别，或如果数据包无法路由，则标记为 `INVALID`。

#### `UNTRACKED`

如果在 raw 表链中已经被指定绕过追踪，数据包就可以标记为 `UNTRACKED`。

#### `SNAT`

如果源地址被 NAT 操作修改，则数据包为这种虚拟状态 `SNAT`。使用该状态是为了在应答数据包中，追踪系统会记得把源地址再改回来。

#### `DNAT`

如果目标地址被 NAT 操作修改，则数据包为这种虚拟状态 `DNAT`。使用该状态是为了在应答数据包中，追踪系统会记得把目标地址再改回来。

有了这些状态，就可以在连接的生存周期内制定针对特定点的规则。这样才能生成更加细致、安全的规则。


































## iptables 规则






### 规则的构成

规则被置于链中，链置于表中。每个链被调用时，会用其中的规则依次对数据包进行检查。

每条规则都有一个 **匹配** 组件和一个 **动作** 组件。



#### 匹配

规则中的匹配部分，用于指定数据包必须满足的条件，以便最终执行相关的动作（或目标）。

匹配的系统非常灵活，可以用系统中可用的 iptables 扩展来实施更强大的匹配。

构建规则时可以使用协议类型、目标地址、源地址、目标端口、源端口、目标网络、源网络、输入接口、输出接口、包头、连接状态等。可以把多个要素组合起来，创建相当复杂的规则集，用来区分不同的流量。



#### 目标

目标，是数据包满足规则中匹配的条件时，所触发的动作。

目标主要分为两类：


##### 中止型目标

中止型目标，它所进行的操作会中止对规则链的评估，将控制返还给 netfilter 钩子。根据返回值，钩子丢弃或允许数据包进入下一步流程。


##### 非中止型目标

非中止型目标完成操作以后，会继续对规则链的评估。









### 创建规则的语法

```
iptables [-t table] command [match] [target/jump]
```

`[-t table]` ：要想使用非标准表格，可以使用该选项。然而，一般都无需显式声明用哪个表，因为 iptables 默认使用 filter 表来执行部署所有的命令。

`command` ：记住，命令放在最前面。我们用命令来告诉 iptables 做什么。例如在某位置插入一条规则，或加到链的末尾，或删除一条规则。

`[match]` ：此处详细描述数据包的特点，是什么使其与众不同。比如在此可以描述数据包的源地址、入站网络接口、目标地址、端口、协议等。

`[target/jump]` ：如果所有条件均匹配，就可以告诉内核做什么了。比如，告诉内核把数据包发给同表中另一条自定义链，或是不加任何处理丢弃数据包，或向发送方回复特定的消息等。











### 表格

`iptables -t nat`

有效值为 raw，mangle，nat，filter 这四张内置表格。如果不显式声明表格，**默认使用 filter**。









### 命令

语句中的命令用于告诉 iptables 要如何操作后面的规则，如在表中添加、删除规则。

##### `-A`

`--append` 向链尾 **追加规则**。

例： `iptables -A INPUT`

##### `-D`

`--delete`

**删除** 链中的规则。

有两种方式：

* 键入整条规则来匹配：

例： `iptables -D INPUT --dport 80 -j DROP`

必须把整条规则一字不差地打出来。

* 使用规则编号来匹配：

`iptables -D INPUT 1`

规则编号从 1 开始。

##### `-R`

`--replace`

**替换** 指定行的规则。

例： `iptables -R INPUT 1 -s 192.168.0.1 -j DROP`

##### `-I`

`--insert`

在链的某处 **插入** 一条规则。

例： `iptables -I INPUT 1 --dport 80 -j ACCEPT`

##### `-F`

`--flush`

**清除** 指定链中的所有规则：

例： `iptables -F INPUT`

如果不使用任何选项，则清除特定表中所有链中的所有规则：

`iptables -F`

##### `-Z`

`--zero`

将指定链中所有的 **计数器清零**。

例： `iptables -Z INPUT`

##### `-N`

`--new-chain`

告诉内核在特定表格中 **创建** 一个指定名称的 **新链**。

例： `iptables -t nat -N BT`

在 nat 表中创建一个名为 BT 的链。

##### `-X`

`--delete-chain`

从表中 **删除某链**。删除之前，必须确认没有任何规则引用该链。

例： `iptables -X BT`

如果不使用任何选项，会删除所有非内置链。

`iptables -X`

##### `-P`

`--policy`

为某链设定默认的目标或策略。可接受的取值为 DROP 和 ACCEPT。

所有不匹配任何规则的数据包最后会被强制使用该链的默认策略。
{: .notice}

##### `-E`

`--rename-chain`

**重命名** 某链。

例： `iptables -E BT BTdownload`

把 BT 重命名为 BTdownload。









### 选项

##### `-v`

`--verbose`

显示更详细的信息。

通常与 `-L` 配合使用，以便额外显示接口地址、规则选项、TOS 掩码、计数器等。

如果 `-v` 与 `-A`、`-I`、`-D`、`-R` 配合使用，会显示额外的信息，以告知用户规则是如何被解释的，是否正确插入了等等。

例： `iptables -L -v`

##### `-n`

`--numeric`

尽量以数字格式输出。不显示主机名，显示 IP 地址与端口号。

只能与 `-L` 配合使用。

例： `iptables -L -n`

##### `--line-numbers`

与 `-L` 配合使用，显示行号。

每条规则前面都会显示行号，便于使用行号对特定规则进行操作。

例： `iptables -L --line-numbers`










### 匹配

关于匹配的内容实在是过于复杂，仅列出常用的几个。




#### 通用匹配

使用通用匹配时，无需附加额外的特殊参数。

##### `-p`

`--protocol`

检测特定的协议。常用的协议为 TCP、UDP、ICMP。

* 协议也可取自 `/etc/protocols` 中的协议，还可以使用其中的 **数字编号** 来代表，如 TCP 为 6，UDP 为 17。
* 取值也可以用 `ALL` ，代表仅匹配 TCP、UDP、ICMP。
* 如果取值为 0，则代表匹配所有协议。也是该选项的默认值，即不使用 `-p` 则代表匹配所有协议。
* 取值时前面加 `!` 可用来取反。如 `-p !tcp` 代表所有非 TCP 的协议。

例： `iptables -A INPUT -p tcp`

###### `-s`

`--source`

用于匹配数据包的 **源 IP 地址**。

例： `iptables -A INPUT -s 192.168.1.1`

* 可匹配单一地址：`-s 192.168.1.1`
* 可匹配网段：`-s 192.168.1.0/24` 或 `-s 192.168.1.0/255.255.255.0`
* 使用 `!` 可取反：`-s ! 192.168.0.0/24`

默认为匹配所有 IP 地址。

###### `-d`

`--destination`

用于匹配数据包的 **目标 IP 地址**。用法同 `-s`

例： `iptables -A INPUT -d 192.168.1.1`

###### `-i`

`--in-interface`

用于匹配数据包 **入站** 的网络 **接口**。

例： `iptables -A INPUT -i eth0`

只能用在 INPUT、FOWWARD、PREROUTING 链中。

如果没有指定接口，该匹配的默认行为是假设为其指定的字符串为 `+`。该值会匹配由字母和数字组成的字符串。实际上等于告诉内核匹配所有的数据包，不管它是从哪个接口来的。

`-i eth+` 匹配所有的以太网设备。

`-i ! eth0` 匹配所有非 eth0 的接口。

###### `-o`

`--out-interface`

用于匹配数据包 **出站** 的网络 **接口**。

例： `iptables -A FORWARD -o eth0`

只能用在 OUTPUT、FORWARD、POSTROUTING 链中。

其它用法同 `-i`。

###### `-f`

`--fragment`

该匹配专门用来匹配分片数据包的第二个和第三个片。

例： `iptables -A INPUT -f`

使用该选项的原因是：当数据包发生分片时，无法区分片的源端口和目标端口，以及 ICMP 类型。而且分片数据包经常被用来进行网络攻击。匹配的切片不会再被其它规则匹配。

虽然也可以使用 `!` 来取反，但比较特殊的是，必须放在选项之前，即 `! -f`。取反之后的含义是，只匹配第一个片。也匹配所有没有被分片的数据包。

内核中有更好的反分片选项。如果使用了连接追踪，就不会看到任何分片的数据包，因为在它们遇到任何链或表之前就已经被处理了。




#### 隐式匹配

隐式匹配是指默认就自动匹配的内容。也就是说即使在语句中没有，默认也是匹配的。


##### TCP 匹配

这些匹配都是针对特定协议的，只适用于 TCP 流量。

要想使用 TCP 匹配，必须在语句中先使用 `-p tcp`。
{: .notice}

###### `--sport`

`--source-port`

匹配数据包的 **源端口**。可以指定端口号，也可以使用 `/etc/services` 中的服务名称来指定。

例 ：`iptables -A INPUT -p tcp --sport 22`

如果不指定，则默认匹配所有源端口号。这就是隐式匹配。

如果直接指定端口号，规则加载起来会稍微快一些，因为 iptables 不用再去解析服务名称。规则越多，越应该使用端口号，以减少解析服务名称所浪费的时间。

可以匹配一定范围的端口号：

`iptables -A INPUT -p tcp -sport 22:80`

使用 `!` 取反：

`iptables -A INPUT -p tcp ! 22`

`iptables -A INPUT -p tcp ! 22:80`

###### `--dport`

`--destination-port`

匹配数据包的 **目标端口**。

例 ：`iptables -A INPUT -p udp --dport 53`

用法同 `--sport`。


##### UDP 匹配

###### `--sport`

`--source-port`

匹配数据包的 **源端口**。

###### `--dport`

`--destination-port`

匹配数据包的 **目标端口**。

例 ：`iptables -A INPUT -p udp --dport 53`




#### 显式匹配

显式匹配必须使用 `-m` 或 `--match` 选项来显式指定，否则默认不会匹配。

##### IP 范围匹配

`-m iprange --src-range`

`-m iprange --dst-range`

用于匹配 IP 地址范围。`--src-range` 指定源地址范围，`--dst-range` 指定目标地址范围。

例：

`iptables -A INPUT -p tcp -m iprange --src-range 192.168.1.13-192.168.2.19`

取反：

`iptables -A INPUT -p tcp -m iprange ! --dst-range 192.168.1.13-192.168.2.19`

##### 长度匹配

`-m length --length`

匹配数据包的长度。

例 ：

`iptables -A INPUT -p tcp -m length --length 1400`

`iptables -A INPUT -p tcp -m length --length 1400:1500`

`iptables -A INPUT -p tcp -m length ! --length 1400:1500`
