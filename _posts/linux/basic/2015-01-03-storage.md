---
toc: true
toc_label: "3. 存储"
toc_icon: "audible"
title: "Linux 基础 - 3. 存储"
tags: 分区 分区表 linux fdisk gdisk raid
categories: "linux"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/linux.jpg
  overlay_filter: rgba(0, 0, 0, 0.6)
---





## 3.1 磁盘

磁盘是一个物理概念。磁盘的种类和分区的类型，直接影响 I/O 性能。







### 3.1.1 磁盘的物理结构

盘片，机械手臂，磁头，主轴马达







### 3.1.2 盘片的物理组成

* 磁道：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道

* 扇区：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区。它是最小的物理存储单位

* 柱面：不同盘片、同一磁道组成的圆柱

{% include figure image_path="/assets/images/2.2.disk.jpg" %}

{% include figure image_path="/assets/images/2.2.disk2.jpg" %}







### 3.1.3 设备文件名

系统按照检测到的磁盘顺序来决定设备文件名，与插槽号无关。

USB 磁盘：`/dev/sdc`

实体磁盘	`/dev/sd[a-p]`

分区	`/dev/sda[1-128]`

虚拟机	`/dev/vd[a-p]`

软RAID	`/dev/md[0-128]`

LVM	`/dev/VGNAME/LVNAME`








### 3.1.4 引导区

Boot Sector，引导区，是数据存储设备的一个区域，其中包含机器代码，会被固件加载到内存中。

引导区的目的：引导计算机来加载存储设备中的程序或操作系统。

主要分两类：MBR、VBR



#### MBR

Master Boot Record

主引导记录，是 **已分区** 储存设备的 **第一个扇区**。

它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。

* MBR 是由分区程序（如 gdisk）生成 的，不依赖任何操作系统。

* 在深入讨论主引导扇区内部结构的时候，**MBR** 也特指其开头的 **446 字节**。

	因此，在谈及 MBR 时，需根据具体情况判断其到底是指整个 **主引导扇区**，还是主引导扇区的 **前446字节**。

* 早期的 Linux 系统为了兼容 Windows 的磁盘，使用 MBR 的方式来处理引导程序与分区表。

* MBR 通常为 512 字节，包括：

	* MBR：446 字节

	* 分区表：记录硬盘整体分区信息，64 字节

	* 结束标志：55，AA，是检验主引导记录是否有效的标志，2 字节




#### VBR

Volume Boot Record

卷引导记录，**尚未分区** 的存储设备的第一个扇区，或存储设备的某一 **分区** 的第一个扇区。

VBR 可以包含引导代码。






























## 3.2 分区

分区是一个 **逻辑** 概念，把磁盘空间在逻辑上划分成若干 **连续** 的磁盘空间。

早期分区的最小单位是柱面，现在是 **扇区**。







### 3.2.1 分区的目的

* 数据安全

* 提高系统的性能









### 3.2.2 分区类型




#### 主分区

在 MBR 型磁盘上直接划分的分区，可以安装操作系统。主分区最多四个。




#### 扩展分区

扩展分区也属于主分区，是一种特殊的 **主分区**。

为了应对 MBR 的分区数量限制，可以在 MBR 型磁盘上划分出一个，最多一个，扩展分区。

与主分区的区别：理论上可以划分为无数个逻辑分区。

扩展分区使用额外的扇区来记录分区信息，从而实现使用更多的分区，**扩展分区不能被格式化**。

>Windows系统默认情况下，一般都是只划分一个主分区给系统，剩余的部分全部划入扩展分区。




#### 逻辑分区

在 MBR 的扩展分区中 **连续划分** 出来的分区，可以直接安装操作系统。

逻辑分区的数量依操作系统而不同，在 Linux 中， SATA 硬盘可以使用 63 个以上的分区。












### 3.2.3 分区设备文件

不同分区的文件名用数字区分，数字越小，越靠近磁盘外侧。

{% include figure image_path="/assets/images/2.2.exten.part.png" alt="扩展分区" %}


* 上图分区的设备文件名如下：

	* P1: /dev/sda1

	* P2:  /dev/sda2

	* L1:  /dev/sda5

	* L2:  /dev/sda6

	* L3:  /dev/sda7

	* L4:  /dev/sda8

	* L5:  /dev/sda9

文件名之所以缺少 `/dev/sda3` 与 `/dev/sda4`，是因为前 4 个号码保留给 **主分区或扩展分区**，所以 **逻辑分区** 的设备号码从 **5** 号开始。









### 3.2.4 创建分区




#### 分区之前

1. 用 `lsblk` 查看磁盘的 **设备文件名**

2. 用 `parted` 命令查看 **分区表类型**

3. MBR 分区表使用 **fdisk**，GPT 分区表使用 **gdisk**。





#### GDISK

gdisk 只有 root 有权执行

gdisk 不会即时生效，按下 “q”，期间所有的操作 “取消”。按下 “**w**” 使操作立即生效。

gdisk 要接 **磁盘名**，非分区名


##### 新增分区

0. 按 l 查看分区类型对应的 **Hex code** 并记录

1. 按 **n** 新增分区

2. Partition number，分区号，默认

3. First sector，起始扇区，默认

4. Last sector，结束扇区：+1G、+500M、+100K

5. Hex code or GUID：Linux **8300**，Linux LVM **8e00**，Windows **0700**

6. 按 p 验证结果，仔细检查分区大小及文件系统类型

7. 没问题，按 w 确认执行分区操作


##### 更新分区表

`cat /proc/partitions` 会看到系统并未立即更新

通过 `partprobe` 命令 **手动更新分区表**：

`partprobe -s`　　\# -s 屏幕会显示信息

`/dev/vda: gpt partitions 1 2 3 4 5 6`


##### 删除分区

如果要删除正在使用中的分区， 必须先将其卸载。




#### FDISK

fdisk 跟 gdisk 使用的方式几乎一样。

与 gdisk 区别：

fdisk 有时会使用 **柱面** 作为分区的最小单位

分区是有限制的 （Primary, Extended, Logical...）





#### PARTED

若想用脚本来 **自动化** 分区全过程，而无需人工干预，可使用 parted 来分区。

parted 可以用 **一行命令完成分区**，不需要与用户交互：

`parted [设备] [命令 [参数]]`

`parted mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始块 结束块`

`parted mkpart xfs 开始块 结束块`	新增分区  

`parted print`	查看分区，起始块、大小、文件系统

`parted rm /dev/sda6`	删除分区


































## 3.3 分区表

分区表用于 **描述磁盘各分区的起始位置**。

磁盘分区表两种类型：MBR ， GPT








### 3.3.1 MBR 型分区表

MBR 分区表共 **64字节**，里面又分成 4 项，每项 16 个字节。所以，一个硬盘最多只能分四个主分区。

每个主分区的 16 个字节，由 6 个部分组成：

* 分区标签：1 字节，如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
* 分区起始位置：3 字节，主分区第一个扇区的物理位置（CHS）。
* 主分区类型：1 字节，。
* 分区结束位置：3 字节，主分区最后一个扇区的物理位置。
* 起始扇区：4 字节，该主分区第一个扇区的逻辑地址。
* 扇区总数：4 字节，主分区的扇区总数，决定了主分区的长度，即一个主分区的扇区总数最多不超过2<sup>32</sup>。

如果每个扇区为 512 字节，则单个分区最大不超过 2 TB。再考虑到扇区的逻辑地址也是 32 位，所以单个硬盘可利用的空间最大也不超过 2 TB。

要想使用更大的硬盘，要么提高每扇区的字节数，要么增加扇区总数。




#### EBR

Extended boot record

扩展引导记录，仅仅是 **逻辑分区** 专用的 **描述符**，与 MBR 和 VBR 本质上不同，它不含程序代码。

每一个逻辑分区都有一个 EBR，其结构与 MBR 类似。


##### EBR 结构

{% include figure image_path="/assets/images/2.2.ebr.png" alt="EBR的结构" %}

EBR 大小为 512 字节

| 内容 | 字节数 |
| --- | --- |
| 通常不用，用 0 填充，可以保存 VBR 等另一个引导程序 | 446 |
| 分区表第一条  | 16  |
| 分区表第二条  | 16  |
| 不用，用 0 填充  | 16  |
| 不用，用 0 填充  | 16  |
| 55AAh 签名，同 0xAA55  | 2  |


##### EBR 中的分区表

EBR 分区表的 **第一项** 指向该逻辑分区 **自身** 的引导扇区，**第二项** 指向 **下一个** 逻辑驱动器的 EBR，分区表第三、第四项没有用到。




#### MBR 分区表的缺陷

* 操作系统无法读取超过 **2.2T** 的磁盘空间

>MBR 分区表中，用来定义磁盘大小的位置只有 **4 字节**，即最多可以用 4 * 8 = 32 位来表示磁盘总扇区的数量，最多管理 2<sup>32</sup> 个扇区 。如扇区大小为 **512 字节**，其最大值即为 **2.2 T**；如扇区大小为 **4 KB**，最大值为 **17.6 T** 。

* MBR **无备份** 措施，被破坏以后，很难修复。

* MBR 内保存引导程序的块仅 446 字节，**无法容纳较多的程序代码**。









### 3.3.2 GPT 型分区表

GPT 分区表支持的 **分区数量** 和 **磁盘容量** 更多。




#### GPT

GUID Partition Table

GUID，Globally Unique IDentifier，是一种由算法生成的唯一标识，通常为 **32个** 16 进制数字组成的字符串，本质上是一个 128 位长的二进制整数。

GUID 一词有时也专指微软对 UUID 标准的实现。

GUID 的主要目的是产生完全 **唯一的数字**。




#### GPT 特点

* 为了兼容所有的磁盘，在定义扇区时，多使用逻辑块地址（**LBA**，Logical Block Address）。

* LBA 默认大小为 512 字节，GPT 把磁盘所有的块以 LBA 来规划，从 0 开始编号，第一个 LBA 称为 LBA0。

GPT 使用前 34 个 LBA 块（0~33）来记录分区信息，另外，整个磁盘的最后 33 个 LBA （-1 ~ -33）也拿来作为另一个 **备份**。




#### GPT 分区表结构

{% include figure image_path="/assets/images/2.2.gpt_partition.jpg" alt="GPT 分区表结构" %}

上述图示说明：

* LBA0 （**MBR 兼容块**）

在原 MBR 位置保存一级引导程序。

原分区表位置仅保存一个 **特殊标志**，用来声明 GPT 格式。

>之所以设置这样的MBR兼容块，是因为**BIOS无法识别GPT的分区表**，在BIOS看来，它以为LBA0就是普通的MBR。

* LBA1 （GPT 表头记录）

包括：分区表本身的位置与大小，备份GPT的分区位置，分区表的校验码。

>操作系统可以根据校验码来判断GPT 是否正确。如有错误，还可以通过这个记录区来读取备份GPT来恢复GPT 的正常运行。

* LBA2-33 （实际分区记录）

每个 LBA 可以记录 4 个分区，共可记录 4\*32 = 128 个分区。每分区最大容量为 1840 TB。

GPT 分区没有主、扩展、逻辑分区的概念，每个分区都可以格式化。













### 3.3.3 查看分区表




#### LSBLK

查看块设备的 **文件名**、加载点、磁盘大小、**文件系统** 等信息

`lsblk [option] [device]`

`-d`		只查看磁盘，不显示分区

`-f`		显示文件系统类型

`-i`		用 ASCII 输出，防止乱码

`-m`		显示设备文件权限

`-p`		查看完整设备文件名

`-t`		显示块设备的详细数据，包括磁盘队列机制、预读写的数据量大小等




#### BLKID

blkid 命令可以查看所有块设备的 **文件名**、 **卷标**、**UUID** 及 **文件系统类型**。

UUID，Universally Unique IDentifier，全域单一识别码，Linux 将系统内所有设备分配一个独一无二的识别码。




#### PARTED

parted 是一款功能强大的磁盘分区工具，与 fdisk 不同，它 **支持调整分区的大小**。

也可以用于查看磁盘的 **分区表类型** 与 **分区** 信息。

`parted device_name print`

parted 后面接的是 **磁盘** 的文件名，如 `/dev/sda` 。

```
parted /dev/vda print

Model: Virtio Block Device （virtblk）　　# 磁盘的模块名称（厂商）

Disk /dev/vda: 42.9GB　　　# 磁盘的总容量

Sector size （logical/physical）: 512B/512B　　# 磁盘的单个逻辑/物理扇区容量

Partition Table: gpt　　　　# 分区表的格式 （MBR/GPT）

Disk Flags: pmbr_boot

Number Start End Size File system Name Flags 　　# 以下三行为分区数据

1 1049kB 3146kB 2097kB bios_grub

2 3146kB 1077MB 1074MB xfs

3 1077MB 33.3GB 32.2GB lvm
```































## 3.4 RAID






### 3.4.1 RAID 简介

独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。

RAID 是一种 **数据存储虚拟化** 技术，它把多个物理磁盘合并成为一个或多个逻辑单元，以实现数据冗余及性能的提升。

数据会以多种方式分布于各驱动器中，表现为各种 RAID 级别，




#### RAID 优势

增强 **数据集成度**，增强 **容错** 功能，提升 **数据吞吐量**，提升 **容量**。




#### RAID 常用技术


##### 数据分割

Data Striping

是一种对逻辑顺序数据（如文件）进行 **分段** 的技术，以便 **把连续段存储在不同的物理存储设备上**。

组成 RAID 0 时，每块磁盘先被分隔成 `chunk`，4K~1M。写入时，数据会按区块大小切割，然后依次保存到不同的磁盘中。

当进程请求数据的速度比单个存储设备所能提供的读取速度更快时，数据分割变得非常有用。把数据分割后有序保存到多个设备中，这些设备可以被同时读取，这样一来，总的数据处理量就大大提升了。同时它也是平衡磁盘阵列 I/O 读取的有效手段。

数据分割广泛应用于 RAID、网络接口控制、集群文件系统中的不同计算机、某些文件系统中的 RAM。


##### 奇偶校验位

Parity Bit

奇偶校验位是一个二进制数字，用于表示在给定位数的二进制数中，**`1` 的个数** 是奇数还是偶数。

奇偶校验位是最简单的 **错误检测码**。

奇偶校验位有两种类型：偶校验位与奇校验位。

* 如果一组给定数据位中 1 的个数是奇数，那么偶校验位就置为 1，从而使得 1 的个数是偶数。
* 如果给定一组数据位中 1 的个数是偶数，那么奇校验位就置为 1，使得总的 1 的个数是奇数。

###### 在 RAID 中使用奇偶校验位

某些 RAID 会使用奇偶校验块实现 **冗余**。如果阵列中的一块磁盘出现故障，工作磁盘中的数据块与奇偶校验块一起来重建丢失的数据。

假设由三块磁盘组成 RAID，分别为 A1 = 00000111、A2 = 00000101、A3 = 00000000。

A1、A2、A3 **异或**（XOR） 得到的 Ap = 00000010。如果第二个磁盘出现故障，A2 将不能被访问，但是可以通过 A1、A3 与 Ap 的异或进行重建：

A1 XOR A3 XOR Ap = 00000101

      冗余磁盘阵列
 A1        A2        A3
------------------------
 Ap        B1        B2
 Bp        C1        C2
 C3        C4        Cp


##### 磁盘镜像

Disk Mirroring

磁盘镜像是把磁盘的逻辑卷复制到单独的物理磁盘中，以保证数据的连续可用。

常用于 RAID1。

镜像卷是独立卷副本的完整逻辑表示形式。










### 3.4.2 RAID 分类

分为 RAID 0，RAID 1，RAID 1E，RAID 5，RAID-6，RAID-7，RAID 10，RAID 50，RAID-60。

| 项目 | RAID 0 | RAID 1 | RAID 10 | RAID 5 | RAID 6 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 最少磁盘数 | 2 | 2 | 4 | 3 | 4 |
| 最大容错磁盘数 | 无 | n-1 | n/2 | 1 | 2 |
| 数据安全性 | 完全没有 | 最佳 | 最佳 | 好 | 比 RAID 5 好 |
| 理论写入性能 | n | 1 | n/2 | &lt;n-1 | &lt;n-2 |
| 理论读出性能 | n | n | n | &lt;n-1 | &lt;n-2 |
| 可用容量 | n | 1 | n/2 | n-1 | n-2 |
| 用途 | 高性能，低可靠性 | 数据与备份 | 服务器、云系统 | 数据与备份 | 数据与备份 |
| 应用范例 | 



#### RAID 0

{% include figure image_path="/assets/images/raid0.png" alt="RAID 0 工作原理" %}

RAID 0 包含 **数据分割**，无镜像，无校验。

多个磁盘组成磁盘组。

* 容量：RAID 0 的容量是阵列中所有磁盘的总和。
* 容错、冗余：无，无法容错。
* 保存：数据几乎平均分配在各磁盘中，所有磁盘可以同时保存，保存速度成倍提升
* 读取：并行读写多个磁盘，读取速度成倍提升，
* 吞吐量：单个磁盘吞吐量乘以磁盘数量


##### 特点

读写速度快，可靠性低。

只要组中有一个磁盘损坏，所有数据丢失。




#### RAID 1

{% include figure image_path="/assets/images/raid1.png" alt="RAID 1 工作原理" %}

RAID 1 包含 **数据镜像**，无校验和分块。

多个磁盘为一组，典型的为两个磁盘一组。

* 容量：组中容量最小的磁盘
* 冗余：镜像磁盘，容错一块硬盘
* 保存：数据完全一致地、同时保存在所有驱动器中，因此保存速度决定于组中最慢的磁盘。
* 读取：读取请求可以由任一磁盘来完成。如果该请求被广播到磁盘组中的所有磁盘，哪个磁盘能最先访问到数据，则由谁来读取。
* 吞吐量：持续的读取吞吐量，如果控制器或软件经过优化，总吞吐量可以达到所有驱动器的总和，与 RAID 0 相同。但实际上，RAID 1 的读取吞吐量要小于组中最快的驱动器。写入的吞吐量总是很慢，因为所有磁盘都要更新，组中最慢的磁盘限制了写入的性能。


##### 特点

读取性能高，可靠性好，写性能差，容量低。

只要组中尚有一块磁盘完好，阵列就可以正常工作。






#### RAID 1/0 混用


##### RAID 1+0

{% include figure image_path="/assets/images/raid10.png" alt="RAID 1+0" %}

RAID 1+0 ：两块磁盘 **先组成 RAID 1**，两组 RAID 1 **再组成 RAID 0**。

利用 RAID 0 的 **并行高速** 优势，及 RAID 1 的 **冗余备份** 优势。

有一个硬盘损坏时，其余硬盘会 **继续运作**。

因此 RAID 1+0 的可靠性更高。


##### RAID 0+1

{% include figure image_path="/assets/images/raid01.png" alt="RAID 0+1" %}

两块磁盘 **先组成 RAID 0**，两组 RAID 0 **再组成 RAID 1**。

RAID 0+1 只要有一个硬盘受损，同组 RAID 0 的所有硬盘就会停止工作，只剩下其他组的硬盘，可靠性较低。






#### RAID 5

{% include figure image_path="/assets/images/raid5.png" alt="RAID 5 工作原理" %}

RAID 5 包含块级别的数据分割，及分布式保存的校验。

* 容量：总磁盘数减一
* 冗余：分布保存在所有磁盘中，容错一块磁盘，超过一块则数据损坏
* 保存：写入性能提升，所有磁盘都均响应写入请求


RAID 5 **至少需要三块硬盘**，RAID 5 会把数据和相对应的奇偶校验信息保存到各个磁盘中，并且 **奇偶校验信息和相对应的数据分别保存在不同的磁盘上**。当 RAID 5 的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。

RAID 5 具有和 RAID 0 相近似的数据读取速度，只是因为多了一个奇偶校验信息，写入数据的速度相对单独写入一块硬盘的速度略慢，若使用 `回写缓存` 可以让性能改善不少。

同时由于多个数据对应一个奇偶校验信息，RAID 5 的磁盘空间利用率要比 RAID 1 高，存储成本相对较便宜。

用同样的方法设计了另一种类似的模式 RAID 6，最多可以允许两块硬盘损坏。
{: .notice--info}

##### 特点

RAID 5 是一种 **写入性能**、**数据安全** 和 **存储成本** 兼顾的存储解决方案。










### 3.4.3 热备盘

Hot Spare Disk

热备盘是一块或一组磁盘，根据热备策略，当 RAID 磁盘出错时，自动或手动替换上去，使 RAID 恢复正常运行。

通过使用自动热备盘，可以尽可能地缩短恢复时间，从而降低在此期间，发生第二块磁盘出错的风险。








### 3.4.4 RAID 的优点

1. 数据安全与可靠性

2. 读写性能

3. 容量





























## 3.5 LVM

Logical Volume Manager

LVM 是一种可用在 Linux 内核的逻辑分卷管理器；可用于管理磁盘驱动器或其他类似的大容量存储设备。







### 3.5.1 LVM 简介

LVM 利用 Linux 内核的设备映射来实现存储系统的虚拟化（系统分区独立于底层硬件）。 通过 LVM，可以实现存储空间的抽象化，并在上面建立虚拟分区（virtual partitions），可以更简便地扩大和缩小分区，在增删分区时无需担心某个硬盘上没有足够的连续空间，LVM 是用来方便管理的，不提供额外的安全保证。

LVM 需要核心的支持，并需要安装 lvm2 软件。

CentOS 与其他较新的发行版默认支持，并预装了 lvm2。




#### 基本概念

{% include figure image_path="/assets/images/lvm.png" alt="LVM 结构" %}


##### PV

physical volume，**物理卷**。

可以在上面建立卷组的媒介，可以是分区、磁盘或环回文件。

物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）。


##### VG

volume group，**卷组**。

将一组物理卷组成一个存储设备，可以看作普通意义上的硬盘。每个卷组可以被划分为多个 LV 。


##### LV

logical volume，**逻辑卷**。

由卷组划分出来的虚拟分区，可以看作普通意义上分区，由 physical extents 组成。


##### PE

physical extent，物理区域。

硬盘可供指派给逻辑卷的最小单位（通常为 4MB）。

通过 “交换 PE ”来进行数据转换，在不同的 LV 之间 **转移 PE**，以实现弹性空间调整。




#### LVM 工作模式

* 线性模式（linear）：在同一个卷组中，只有前一个逻辑卷的空间用完，才会开始使用下一个逻辑卷。
* 交错模式（triped）：同时使用同一个卷组中的多个逻辑卷空间来保存数据，类似 RAID 0 的 striping，读写性能较好。

LVM 主要的优势在于实现文件系统容量的弹性调整，因此 **默认** 的读写模式为 **线性模式**。




#### LVM 优点

比起正常的硬盘分区管理，LVM 更富于弹性：

* 使用卷组，使众多硬盘空间看起来像一个大硬盘。
* 使用逻辑卷，可以创建跨越众多硬盘空间的分区。
* 可以创建小的逻辑卷，在空间不足时再动态调整它的大小。
* 在调整逻辑卷大小时，无需考虑逻辑卷在硬盘上的位置，不用担心没有可用的连续空间。
* 可以在线对逻辑卷和卷组进行创建、删除、调整大小等操作。LVM 上的文件系统也需要重新调整大小，某些文件系统也支持这样的在线操作。
* 无需重新启动服务，可以将服务中用到的逻辑卷在线、实时迁移到别的硬盘上。
* 允许创建快照，可以保存文件系统的备份，同时使服务的下线时间（downtime）降到最小。













### 3.5.2 LVM 精简卷

LVM thin Volume

thin logical volume 精简逻辑卷

thin pool 存储池

可以创建比实际可用的 extents 大的逻辑卷，通过精简预处理，可以管理一个 **可用空间** 的 **存储池**。无论应用程序需要分配多少设备文件都能满足，可以创建一个绑定到存储池的设备，以便在应用程序实际写入逻辑卷时进行后期分配。存储池可以 **动态扩展**，以满足高性价比的空间分配。











### 3.5.3 逻辑卷磁盘快照

LVM 可以给系统创建一个快照，由于使用了写入时复制（copy-on-write）策略，相比传统的备份更有效率。 初始的快照只包含实际数据的 inode 的硬链接。只要实际的数据没有改变，快照就仅仅包含指向数据 inode 的指针，而非数据本身。一旦更改了快照对应的文件或目录，LVM 就会自动拷贝相应的数据，包括快照所对应的旧数据的拷贝和当前系统所对应的新数据的拷贝。这样的话，只要被修改的数据（包括原始的和快照的）不超过 2G，就可以只使用 2G 的空间对一个有 35G 数据的系统创建快照。

要想创建快照，卷组中必须有未分配的空间，像其它卷一样，快照也会占用磁盘空间。因此必须为其预留足够的空间。

快照区与原逻辑卷共享很多物理 extents，因此快照区与逻辑卷必须在 **同一个卷组** 中。




#### 恢复快照

要恢复的数据量不能大于快照区所能负载的实际容量。由于原始数据会被搬移到快照区，若原始数据被修改的实际数据量比快照区大，快照区就容纳不了，快照功能会失效。




#### 快照用于测试

把原逻辑卷当作备份，把快照区用于实际运行，任何测试都在快照区进行。测试完毕只需将快照区删除即可。要想复制一个原逻辑卷的系统，只需再做另一个快照区。
