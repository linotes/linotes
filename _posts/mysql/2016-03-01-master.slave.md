---
toc: true
toc_label: "MySQL 主从复制"
toc_icon: "copy"
title: "MySQL 主从复制"
tags: mysql 主从 同步 复制
categories: "database"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/mysql.jpg
  overlay_filter: rgba(0, 0, 0, 0.8)
---







## MySQL 的复制功能

MySQL 的 主从 复制来源于其特有的词汇：复制，即 **Replication**。因此在 MySQL 的语境中，提到的复制主要是指这个复制，而不是通常意义的 copy。
{: .notice--success}

通过复制，可以让数据从一个 MySQL 数据库服务器被复制到另一个或多个 MySQL 数据库服务器中，前者称为 **主服务器**，即 Master，后者称为 **从服务器**，即 Slaves，政治正确的说法是 Replica。这就是所谓的*主从*。

为了叙述方便，本文中经常会把主服务器简称为 “**主**”，把从服务器简称为 “**从**”，颜色加深。
{: .notice--primary}

复制默认是 **单向**、 **异步** 进行的，因此，从服务器无需为了收到更新而一直保持连接。这就意味着更新是可以在远距离连接上进行的，甚至可以在临时的或间断性的连接上进行，如拨号连接。根据配置，可以复制全部数据库、部分数据库、或库中指定的表。








### 复制的优点

MySQL 内置的复制功能，配合使用这种可扩展的架构，是建设大型、高性能应用的基础。这种 主从 复制不仅仅有利于高性能的应用程序，它还是许多策略的基石，包括：高可用、可扩展性、灾难恢复、备份、数据分析、数据仓库等任务。

* 可扩展解决方案：把负载分摊到多个从服务器上，从而提升性能。在该环境下，所有的 **写** 和 **更新** 操作必须发生于 **主** 服务器上，即主服务器专用于更新。而 **读** 操作，可以发生在一个或多个 **从** 服务器上。这种模式一方面会提升写的性能，另一方面，不断增长的从服务器还会大大提升读的速度。

* 数据安全：因为数据被复制到从服务器，而且从服务器可以暂停复制的进程，因此，可以做到在从服务器上运行 **备份** 服务，同时还不会破坏对应的主服务器上的数据。

* 数据分析：可以在主服务器上创建实时数据，而对信息的分析可以发生在从服务器，不会影响主服务器的性能。

* 远距离数据分布：如果由于工作需要，公司在远方的分部门需要主数据的一个副本，可以利用复制在本地创建一个副本，而无需与主服务器保持持续的连接。







### 复制的分类

在两个服务器之间配置复制有很多种办法，但最好的办法取决于使用的数据以及引擎的类别。

MySQL 复制的格式有两个核心的类别：

* 基于 **语句** 的复制：SBR，Statement Based Replication。也称逻辑复制，它会复制全部 SQL 语句。启用于 MySQL 3.23 版本。
* 基于 **行** 的复制：RBR，Row Based Replication。只复制发生修改的行。启用于 MySQL 5.1 版本。

为了叙述的简便和阅读的方便，下文经常把 “基于行的复制” 简称为 “**行复制**”，把 “基于语句的复制” 称为 “**逻辑复制**”，仅限本篇文章。
{: .notice--primary}

#### 传统的 基于二进制日志的复制

早期的复制是基于主服务器的二进制日志，其中保存了主服务器对数据库所做的修改，从服务器读取这些日志，据此来在自己本地进行同样的操作，实现更新。以上所述的 SBR 和 RBR 均属于这种，均是异步完成的，意味着有可能 主从 之间会存在数据同步延迟。

主服务器将更新写入 **二进制日志文件**，并维护文件的一个索引，以跟踪日志循环。当从服务器连接主服务器时，它会把自己在日志中读取的最后一次成功更新的位置告知主服务器。从服务器接收该位置之后发生的任何更新，然后封锁，等待主服务器通知新的更新。

#### 较新的 基于 GITD 的复制

在 MySQL 5.6.5 开始及之后的版本中，支持事务复制，是基于全局事务标识符，即 **GITD**，Global Transaction IDentifier。使用这类的复制时，无需直接处理日志文件或其偏移量，极大简化了许多日常的复制任务。因为使用 GTID 进行复制是完全事务性的，只要在主服务器上提交的所有事务都已应用于从服务器，则可以保证 主从 的一致性。









### 复制所解决的问题

复制通常用于以下方面：



#### 数据分布

MySQL 的复制通常对带宽不算敏感，因此可以用来远距离维护数据的副本，例如在不同的数据中心之间同步数据。

#### 负载平衡

MySQL 的复制有助于把读请求分配到多个服务器上，这一点对于读敏感的应用来说特别好用。对代码做简单的修改就可以实现基本的负载平衡。无论是简单的轮询 DNS，还是更复杂的方法，都可以在 MySQL 服务器上很好地工作。

#### 备份

主从 分开非常有利于备份的稳定进行。

#### 高可用 与 失效切换

复制还有助于避免单点失效的发生，失效切换系统如果使用复制，可以大幅减小当机时间。

#### MySQL 升级前测试

通常会在从服务器上进行新版本 MySQL 的测试，以确保所有查询都能正常工作，之后再升级所有实例。








### 复制的工作原理



#### MySQL 是如何复制数据的

从高层级来看，复制的进程包含三部分：

1. 主服务器把修改保存到二进制日志中，这些记录称为二进制日志事件。
2. 从服务器把主服务器的日志事件复制进自己的中继日志，即 relay log。
3. 从服务器重现中继日志中的事件，把修改应用到自己的数据中。

![image-center](/assets/images/mysql.replication.png){: .align-center}

##### 主服务器保存二进制日志

主服务器上，MySQL 在每个更新数据的事务开始之前，会 **提前** 把即将发生的修改记录到二进制日志里。写入日志的操作是 **串行** 的，即使如果事务中的语句在执行过程中是交错进行的。写完以后，主服务器会告诉存储引擎去提交事务。

##### 从服务器拷贝二进制日志

从服务器启动一个工人线程，**I/O slave**，它会与主服务器打开一个普通的客户端连接，然后在主服务器上启动一个特殊的线程，**binlog dump** 线程，它会从主服务器的二进制日志中 **读取事件**。它并不会对事件进行轮询。如果发现已经同步，它会进入休眠，等待产生新事件时，主服务器向其发送信号。然后，I/O 线程把读取到的事件写入从服务器的中继日志。

##### 事件重演

**SQL slave** 线程从中继日志中读取并重演事件，从而更新从服务器的数据，与主服务器完全匹配。只要 SQL slave 线程能与 I/O 线程保持同步，中继日志通常会保持在操作系统的缓存中，因此其开销很少。如果有需要，可以把 SQL 线程所执行的事件保存到从服务器自己的二进制日志中。

在从服务器上，这种复制的架构 **拆分** 了获取与重演事件的过程，从而可以实现二者的 **异步**。即，I/O 线程可以独立于 SQL 线程运行。同时，复制的进程也受到一定的约束，其中最重要的约束就是：**复制在从服务器上是串行的**。这就意味着即使在主服务器上可以并行用多个线程同时更新，在从服务器上却无法实现并行，因为所有更新都是在一个线程中执行的。这一点对于许多工作负载来说是个瓶颈，需要另外解决，不过对于大多数用户来说，一个线程就够用了。
{: .notice}





























## 复制的配置

虽然复制的配置相当简单，但在基本步骤上还有很多变化，取决于具体的实施场景。最基本的场景是新安装的 主从 服务器。从高层级来看，可以分为以下步骤：

1. 在每个服务器上配置复制的帐户
2. 配置 主从 服务器
3. 从服务器连接到主服务器进行复制


这是在假设默认配置就能满足工作的基础上的，事实也是如此。新安装了 主从 服务器时，它们拥有相同的数据，即默认的 mysql 数据库。






### 创建复制帐户

MySQL 有几个特殊的权限是用于复制进程的，从服务器上的 I/O 线程会与主服务器创建一个 TCP/IP 连接。因此，必须在主服务器上 **创建** 一个用户帐户，**赋予** 适当 **权限**，这样，I/O 线程才可以用该用户的身份连接过去，读取二进制日志。

创建帐户 repl，并为其赋予权限：

```sql
mysql> CREATE USER 'repl'@'192.168.0.%' IDENTIFIED BY 'password';
mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
-> TO 'repl'@'192.168.0.%';
```

在 主从 服务器上都要创建同样的用户。









### 配置主从


#### 主服务器

需要在主服务器上 **启用二进制日志**，并 **指定服务器 ID**。

```bash
$ cat /etc/my.cnf

log_bin=/var/log/mysql/mysql-bin.log
server_id=10
```

`server_id` 必须是唯一的，通常避免用 1，因为 1 是默认值，避免混淆。通常会使用该服务器 IP 地址的最后一段。

配置好以后需要 **重启 mysqld**，然后登陆进去，查看以 **确认** 二进制日志已经生成：

```sql
mysql> SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      634 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```


#### 从服务器

从服务器上需要进行类似的配置，同样也需要重启 mysqld。

```bash
$ cat /etc/my.cnf

log_bin=/var/log/mysql/mysql-bin.log
server_id=2
relay_log=/var/log/mysql/mysql-relay.log
log_slave_updates=1
````

其中 `log_slave_updates` 表示把复制过来的事件也更新到自己的二进制日志中。









### 启动从服务器

下一步就是告诉从服务器如何连接到主服务器，并开始对二进制日志进行重演。


#### 指定主服务器

此时不要使用配置文件来做，而需要使用 `CHANGE MASTER TO` 语句，它会覆盖配置文件中对应的设置。

运行以下命令，**启动复制**：

```sql
mysql> CHANGE MASTER TO MASTER_HOST='server1',
    -> MASTER_USER='repl',
    -> MASTER_PASSWORD='password',
    -> MASTER_LOG_FILE='mysql-bin.000001',
    -> MASTER_LOG_POS=0;
```

`server1` 为主服务器的主机名

`MASTER_LOG_POS=0` 因为这是日志的开头


#### 查看从服务器状态

运行以上命令以后，就可以查看从服务器的状态了，从而确认配置是否正确：

```sql
mysql> SHOW SLAVE STATUS\G
*************************** 1. row ***********
Slave_IO_State:
Master_Host: server1
Master_User: repl
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: mysql-bin.000001
Read_Master_Log_Pos: 4
Relay_Log_File: mysql-relay-bin.000001
Relay_Log_Pos: 4
Relay_Master_Log_File: mysql-bin.000001
Slave_IO_Running: No
Slave_SQL_Running: No
...omitted...
Seconds_Behind_Master: NULL
```

注意，此时 I/O 和 SQL 线程都尚未启动，其运行状态均为 NO。`Seconds_Behind_Master` 此时是 NULL，意味着不知道自己与主服务器的数据的更新是否有延迟。



#### 启动复制

```sql
mysql> START SLAVE;
```


#### 再次查看状态

```sql
mysql> SHOW SLAVE STATUS\G
*************************** 1. row ******************
Slave_IO_State: Waiting for master to send event
Master_Host: server1
Master_User: repl
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: mysql-bin.000001
Read_Master_Log_Pos: 164
Relay_Log_File: mysql-relay-bin.000001
Relay_Log_Pos: 164
Relay_Master_Log_File: mysql-bin.000001
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
...omitted...
Seconds_Behind_Master: 0
```

此时，I/O 和 SQL 线程均已启动，`Seconds_Behind_Master` 不再是 NULL，I/O 线程等待主服务器的事件，意味着从服务器已经同步了主服务器的二进制日志。日志的位置已经增加，表明取回了一些事件并执行了。如果在主服务器上发生了修改，在从服务器上也会看到相应的变化。

##### 在主服务器上查看 Binlog Dump 线程

在主服务器上，可以看到由 I/O 线程创建的连接，即 Binlog Dump 线程：

```sql
mysql> SHOW PROCESSLIST\G
*************************** 1. row ***************************
Id: 55
User: repl
Host: replica1.webcluster_1:54813
db: NULL
Command: Binlog Dump
Time: 610237
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
```

##### 在从服务器上查看 I/O 线程 和 SQL 线程

```sql
mysql> SHOW PROCESSLIST\G
*************************** 1. row ***************************
Id: 1
User: system user
Host:
db: NULL
Command: Connect
Time: 611116
State: Waiting for master to send event
Info: NULL
*************************** 2. row ***************************
Id: 2
User: system user
Host:
db: NULL
Command: Connect
Time: 33
State: Has read all relay log; waiting for the slave I/O thread to update it
Info: NULL
```

从服务器上的 I/O 和 SQL 这两个线程始终是用 system user 帐户来运行的。当 SQL 线程重演事件时，`Info` 字段会显示当前执行的查询内容。











### 在另一个服务器上初始化从服务器

实际生产中往往不会使用新装的服务器来配置，往往是运行了好久的服务器，通常在 主从 服务器上的数据，一开始也不会同步。

初始时把数据从主服务器复制到从服务器有很多方法：直接复制，从另一个从服务器复制，用最近的备份开始复制。

总之，要想在初始化时让从服务器的数据与主服务器同步，需要三样东西：

* 主服务器某个时间点的快照
* 主服务器当前的日志文件，以及在所采用快照其时间点上该日志的偏移量，用 log file coordinates 来表示这两个值，它们标识了二进制日志中的一个具体的位置。可以用 `SHOW MASTER STATUS` 来查看这两个值。
* 主服务器的二进制日志文件，从快照时间点一直到现在的内容



#### 从其它服务器复制数据的方法

##### 离线复制

生成从服务器最基本的方法：

* 关闭主服务器，把其中的文件复制到从服务器
* 重启主服务器，开始一个新的二进制日志
* 在从服务器上配置 `CHANGE MASTER TO`，从二进制日志的开头开始复制

##### 在线复制

如果只使用 MyISAM 表，可以用 `mysqlhotcopy` 或 `rsync` 来在线复制文件，无需关闭主服务器。

##### 使用 `mysqldump`

如果只使用 InnoDB 表，可以用以下命令从主服务器上复制所有内容，将其加载到从服务器中，并把从服务器的坐标修改到主服务器二进制日志的对应位置上：

```bash
$ mysqldump --single-transaction --all-databases --master-data=1--host=server1 \
| mysql --host=server2
```

`--single-transaction` 选项会让复制进程以数据在事务开始时的状态来读取它们，如果没有使用事务性表，则可以使用 `--lock-all-tables` 选项来锁定，从而得到所有表的一致的复本。

##### 使用快照或备份

只要知道对应的二进制日志的坐标，就可以使用快照或备份从主服务器中初始化复制。直接把备份或快照恢复到从服务器上，然后在 `CHANGE MASTER TO` 中使用适当的二进制日志坐标。

##### 从其它从服务器

还可以用上面提到的快照及其它方法，从另一台从服务器上来复制数据。但是，如果使用 `mysqldump`，`--master-data` 选项是不起作用的。

另外，需要使用 `SHOW SLAVE STATUS` 来查看具体的位置，即该快照建立时，从服务器正在执行哪些事件。

从另一个从服务器复制数据的最大缺点：如果这个从服务器没有完成同步，则再次生成的从服务器得到的数据一样是没有同步的。

绝对不要使用 `LOAD DATA FROM MASTER` 或 `LOAD TABLE FROM MASTER`，这些语句已经淘汰了，经们不仅运行缓慢，还非常危险，而且只适用于 MyISAM。













### 推荐的复制配置


#### 强制同步日志到磁盘

在 **主服务器** 上，关于二进制日志最重要的设置是 `sync_binlog`：

```conf
sync_binlog=1
```

该配置让 MySQL 每次提交一个事务时，都会把二进制日志的内容 **强制同步到磁盘** 中，这样可以避免突然的崩溃导致日志事件的丢失。该配置只适用于主服务器，因为该配置在从服务器上会产生不必要的开销。它只适用于二进制日志，不适用中继日志。


#### 使用 InnoDB

如果无法忍受系统崩溃导致表被破坏，还是推荐使用 InnoDB。MyISAM 的表在系统崩溃之后容易出现不一致。如果在一个或多个表中没有执行完语句，那么即使在修复了表之后数据也会不一致，这一可能性是很大的。

如果使用 **InnoDB**，则强烈推荐在 **主服务器** 上使用以下配置：

```conf
innodb_flush_logs_at_trx_commit=1   # 每次提交后均刷新日志
innodb_support_xa=1   # MySQL 5.0 及以后版本适用
innodb_safe_binlog   # 仅 MySQL 4.1 适用
```

这些配置是 MySQL 5.0 及以后版本的默认设置。


#### 指定统一的日志文件名

建议显式指定二进制日志文件的 **基准名**，以便在 **所有服务器** 上创建 **统一的** 二进制日志文件名。

```conf
log_bin=/var/log/mysql/mysql-bin.log
```


#### 指定从服务器的中继日志

在从服务器中配置以下参数，建议用绝对路径指定中继日志。

```conf
relay_log=/path/to/logs/relay-bin
skip_slave_start
read_only
```

`relay_log` 选项目的是为了避免默认使用主机名做中继日志的文件名。

`skip_slave_start` 是为了避免从服务器在经历崩溃后自动启动，以便给管理员修复的机会。

`read_only` 选项可以避免大多数用户修改非临时表。只允许 SQL 线程修改，以及少数具有 SUPER 权限的用户。因此要尽量避免给普通帐户分配 SUPER 权限。


#### 把中继日志和 `master.info` 强制同步到磁盘

即使启用了以上所有配置，从服务器在经历崩溃后还是容易发生损坏，因为中继日志和 `master.info` 文件无法抵御崩溃。它们甚至默认不会被同步到磁盘，直到 MySQL 5.5 版本才有对应的配置选项来控制该刷新行为。

如果使用的是 MySQL 5.5 以后的版本，而且不在意额外的 `fsync()` 调用所产生的性能开销，则建议以下配置：

```conf
sync_master_info = 1
sync_relay_log = 1
sync_relay_log_info = 1
```






























## 深入了解复制







### 基于语句的复制

MySQL 5.0 及较早版本只支持逻辑复制。

在主服务器上，把导致数据变化的 **查询** 保存到日志中。



#### 优点

* 部署简单：本地保存日志，异地重演，即完成同步。
* 日志事件比较简洁：相对来说，不会占用太多带宽。
* 日志文件包含更改相关的所有语句，可以用来审核数据库。

当 主从 服务器的 **数据格局有所不同** 时，逻辑复制更加适用。例如， 主从 服务器上的表格不同，但数据类型是兼容的，或者字段的顺序也有所不同等等。逻辑复制使得在从服务器上对数据格局的修改更加容易，减少当机时间。逻辑复制在操作上有更大的灵活性。

逻辑复制中，重演的过程大体上是普通的 SQL 操作，所有的变化是以一个容易理解的机制发生的，更容易检查和判断当下发生了什么。



#### 缺点

##### 某些语句无法复制

在实际使用中，逻辑复制并没有看起来那么简单。除了查询文本之外，主服务器上的许多变化还决定于其它因素。例如，这些语句在主服务器和从服务器上可能执行的次数会不同，结果就是，MySQL 二进制日志的格式中除了查询文本之外，还会包括几位元数据，如当前的时间戳。即便如此，仍然有 **一些语句是 MySQL 无法正确复制的**，比如使用 `CURRENT_USER()` 函数的查询，以及 **预储程序** 和 **触发器**。

底线：如果要使用触发器或预储程序，就不要使用逻辑复制。


##### 修改必须是序列化的

逻辑复制要求对数据的修改必须是序列化的，即线性的。这就会 **需要更多的锁定**，有时简直是太多了。不是所有的存储引擎都能与逻辑复制配合使用的。










### 基于行的复制

从 MySQL 5.1 开始支持行复制，在二进制日志中记录数据的真实修改，更像大多数其它数据库产品的复制手段。


#### 优点

##### 所有的修改都能正确复制，更加安全

有些修改还可以复制的更加高效，因为从服务器 **不必重演** 在主服务器上引起行变化的那个 **查询**。

很少有行复制不能胜任的情况，所有的 SQL 结构、触发器、预储程序等，它都能正确处理。只有在进行一些很智能化的操作时才会有些局促，如修改数据格局。

##### 主从服务器上只需要很少的锁定，因此有更高的并发

行复制不需要特别强的序列化就可以完成重演。

##### 日志记录更加直接

行复制在日志中所记录的是 **发生变化的数据本身**，因此二进制日志中的记录就是在主服务器上真实发生的变化内容。不需要根据语句来猜测它修改了什么数据。因此，用行复制能够 **更加了解哪些数据发生了变化**，对变化的记录也更好。

##### 可以记录历史数据

另外，在某些情况下，行复制的二进制日志还会记录 **历史数据**，对于数据的恢复特别有帮助。

##### 对 CPU 的需求不大

在很多情况下，行复制对 CPU 的需求不大，因为它不需要像逻辑复制那样计划和执行查询。

##### 有助于解决数据不一致

在某些情况下，行复制有助于更快地查找并解决数据不一致的问题。

例如，如果在主服务器上更新了一行，但从服务器上根本就没有这一行，此时逻辑复制不会失败，而行复制就会 **报错并停止**。


##### 范例

**对查询的重演有时会引起很大的开销**。例如，以下这个查询是从一个巨大的表中读取一些统计信息，保存到一个小表里：

```sql
mysql> INSERT INTO summary_table(col1, col2, sum_col3)
	-> SELECT col1, col2, sum(col3)
	-> FROM enormous_table
	-> GROUP BY col1, col2;
```

假设在 `enormous_table` 表中，`col1` 和 `col2` 的组合只有三种，该查询会扫描源表中的许多行，而在目标表中保存的结果却只有三行。把该事件做为语句复制会使从服务器重复所有这些操作，而目的只是为了生成三行数据，而如果使用行复制就要简单的多了，更加高效。

😈 从上例可以看出，是哪些语句使用行复制才会更加高效呢？当然是从数据修改的结果出发来看了，只要是使用语句大张旗鼓地进行查询，得到的结果却只是对少数的几行数据进行修改，此时用行复制就更高效。
{: .notice--success}





#### 缺点

因为日志事件中不包含语句，因此 **很难了解执行了哪些 SQL 语句**，有时候这很重要。

复制来的变化在从服务器中应用时，是以完全不同的方式进行的，它执行的根本不是 SQL 语句。事实上，行复制应用修改的过程是在 **黑箱** 中进行的，谁都看不到服务器做了什么，这方面的文档也不够详细。

在使用多级从服务器时，如果它们使用相同的配置的行复制。假设在会话级变量 `binlog_format` 为 STATEMENT 的情况下，执行了一条语句，会在发起该语句的服务器上，以语句的形式记录在日志中。但是，第一级从服务器会把该事件以行复制的格式中继下来，传递给复制链上的其它从服务器。这样，用户本来希望在日志中以语句的格式记录，可是该事件穿越复制拓扑时，还是被 **强行切换** 成了行复制。

有些操作，逻辑复制应付的来，但行复制不行，比如在从服务器上修改数据格局。
















### 哪种复制方法更好？

因为每种复制的方法都有最适合自己的具体情况，MySQL 可以在逻辑复制和行复制这两种方法之间 **动态切换**。默认是使用逻辑复制，当发现某个事件无法用语句正确复制时，它会切换成行复制。当然，在需要时，也可以手动控制使用哪种方法，通过配置会话变量 `binlog_format` 来实现。

理论上，行复制可能整体来说更好一些，而且在实际生产中对于大多数人来说工作的比较好。
















### 复制会用到的文件

除了二进制日志和中继日志，还有一些文件是在复制过程中会用到的。MySQL 会根据当前的配置来处理这些文件。不同版本的 MySQL，放置这些文件的默认位置可能所有不同。



#### `mysql-bin.index`

启用了二进制日志以后，服务器中还会存在与其同名的文件，但加了 `.index` 后缀。该文件会跟踪磁盘中的二进制日志。它与表格索引不同，文件中的每一行包含了一个 **二进制日志文件名**。

MySQL 依赖这个索引文件来定位二进制日志，所以不要手动干预它。

```bash
$ sudo cat /var/log/mysqld/mysql-bin.index
/var/log/mysqld/mysql-bin.000001
/var/log/mysqld/mysql-bin.000002
/var/log/mysqld/mysql-bin.000003
/var/log/mysqld/mysql-bin.000004
/var/log/mysqld/mysql-bin.000005
```



#### `mysql-relay-bin.index`

MySQL 依赖这个索引文件来定位中继日志。

```bash
$ sudo cat /var/log/mysql/mysql-relay-bin.index
/var/log/mysql/mysql-relay-bin.000005
```



#### `master.info`

该文件保存的是 **主服务器的详细信息**，从服务器根据该文件中的信息来连接到主服务器。MySQL 依赖它来连接主服务器。

该文件中包含从服务器用户的密码，是明文保存的，因此有必要对权限加以限制。



#### `relay-log.info`

该文件包含了从服务器中在二进制日志和中继日志中的 **坐标**。MySQL 依赖它来了解记起之前复制到什么位置。




>用这些文件来记录复制和日志的状态，这是一个比较粗糙的办法。而且不幸的是，它们还不是同步写入的，所以如果赶上服务器突然断电，这些文件还没有被刷新到磁盘中，服务器重启时，这些文件的内容可能就不是正确的。在 MySQL 5.5 之后已经有所改进，即前面提到的对 `sync_*` 的配置。
>
>`.index` 文件会与另一个配置交互，即 `expire_logs_days`，该参数用于定义 MySQL 应该如何删除过期的二进制日志。如果 `mysql-bin.index` 文件中所指定的文件在磁盘上不存在，自动删除在某些版本的 MySQL 中就会不管用。事实上，即使用 `PURGE MASTER LOGS` 语句都无法删除。解决办法通常是用 MySQL 服务器来管理二进制日志。总之不要手动 `rm` 删除这些文件，以免影响它们的正常运行。
>
>要想实现自动删除日志，必须显式指定删除策略。可以使用 `expire_logs_days` 或其它办法，同时要有针对性地设置备份策略。















### 把复制事件发送给其它从服务器

启用 `log_slave_updates` 选项，可以使当前的从服务器成为其它从服务器的主服务器。SQL 线程执行的那些事件会被写入从服务器自己的二进制日志中，然后它自己的从服务器再来读取。

![image-center](/assets/images/mysql.replication.2salves.png){: .align-center}



#### 启用 `log_slave_updates`

因为启用了 `log_slave_updates`，slave1 在重演事件后，会将其写入自己的二进制日志，slave2 就可以把 slave1 的事件放到自己的中继日志，然后执行。于是，master 中发生的改变会一路传播到 slave2。因此，通常建议默认就开启 `log_salve_updates` 选项，这样，在需要创建下一级从服务器时，可以直接连接，无需重启。



#### 同一事件的日志坐标在各服务器上是不同的

slave1 写入自己的二进制日志时，同一个事件在日志中所处的位置与 master 中它所处的位置一定是不同的。因此：

即使两个服务器其复制是处于相同的 **逻辑点** 上，也无法保证它们处于相同的 **日志坐标**。
{: .notice--info}

这一点让某些任务处理起来特别复杂，比如让一个从指向新的 主，或把从改为 主。



#### 唯一的 Server ID 很重要

如果不为服务器仔细分配唯一的 server ID，这样配置就容易出现细微的错误，甚至会导致复制失败。

唯一的 server ID 有助于防止复制陷入 **死循环**。SQL 线程在读取中继日志时，会忽略掉 Server ID 为自己的事件，就是通过该行为来防止死循环的。











### 复制的过滤器

使用复制过滤器可以实现只复制服务器的 **部分数据**，实际上不是什么好事。使用复制过滤器经常会产生一些问题。

有两类复制过滤器：针对二进制日志的过滤器，以及针对中继日志的过滤器。

![image-center](/assets/images/mysql.repl.filter.png){: .align-center}

在从服务器中启用 `replicate_*` 这些选项以后，当 SQL 线程从中继日志中读取事件时，会针对事件进行过滤，可以 **复制** 或 **忽略** 一个、多个数据库，把一个数据库重写成另一个，基于 `LIKE` 模板的匹配来复制或忽略特定的表格。



#### 不要轻易使用过滤器

无论在主服务器还是从服务器上，`*_do_db` 和 `*_ignore_db` 这两类选项工作起来并不总能如人愿。它们并不是针对数据库名称进行过滤，而是针对 **当前默认的数据库** 进行过滤。
{: .notice}   

如果在主服务器上执行以下语句：

```sql
mysql> USE test;
mysql> DELETE FROM sakila.film;
```

因为当前使用的数据库是 test，`*_do_db` 和 `*_ignore_db` 参数只会针对数据库 test 进行过滤，而不会过滤其它数据库的语句，所以第二条的 DELETE 语句就不会被过滤，因为它是针对数据库 sakila 的。`*_do_db` 和 `*_ignore_db` 参数虽然有用，但是比较有限，而且使用的比较少，必须特别谨慎地使用。稍有错误，就很容易导致复制发生同步错误或失败。

不仅如此，使用了这些参数以后，就无法实现 “从备份中进行针对特定时间点的数据恢复” 了。对于绝大多数情况，都不应该使用。











### 复制通道

Replication Channels

从 MySQL 5.7.6 开始，引入了复制通道的概念。

复制通道用来表示由*主*流动到*从*的事务的路径。

为了兼容旧版本，MySQL Server 在启动时会自动创建一个 **默认通道**，名称为空字符串 `""`。该通道会始终存在，它无法被用户创建或破坏。如果没有其他的非空名称的通道被创建，复制语句会只在默认通道上进行，以保证低版本的*从*中的复制语句能正常执行。


#### 通道独立工作

复制通道中包含了由*主*到*从*的事务的路径，在多源复制中，一个*从*会打开多个通道，每个*主*用一个，每个通道都有其 **自己的中继日志和 SQL 线程**。

复制通道的 I/O 线程接收到事务以后，将其加入通道的中继日志，并交给 I/O 线程。这样，通道就可以独立工作了。


* 一个复制通道与一个主机名和端口号相关联。
* 可以给同一组主机名/端口号的组合分配多个通道。
* 在 MySQL 5.7 的多源复制中，可以为一个*从*增加的通道的最大数量为 256 个。
* 每个复制通道必须拥有一个唯一的、非空的名称。
* 每个通道可以被单独配置。
























## 复制的拓扑

组建复制拓扑期间的基本准则：

* 一个 MySQL 复制实例只能有一个 主
* 每个*从*必须有一个唯一的 Server ID
* 一个*主*可以有多个从服务器
* 一个*从*可以把*主*的修改传播下去，自己可以做为其它*从*的 主











### 一主多从

一主多从的拓扑中，每个*从*只和*主*进行通信。

![image-center](/assets/images/sql.repl.topo.msss.png){: .align-center}

该拓扑适合 **写少读多** 的情况。可以把读取的压力分散到任意数量的从服务器上，直到数量多到从服务器产生的 **负载** 太大，或占用了过多的 **带宽** 为止。可以一次性配置多个从服务器，也可以需要时再加。



#### 用途

虽然这个拓扑很简单，但它的灵活性已经满足许多需求了：

* 把不同的*从*用作 **不同的角色**：如，增加不同的索引或使用不同的存储引擎
* 把其中的一个*从*配置成为 **候补主服务器**，只允许走复制流量
* 把其中的一个*从*放到远程数据中心，用于 **灾难恢复**
* 延迟复制一或多个*从*，用于灾难恢复
* 把其中的一个*从*用于备份、培训、开发、平台



#### 特点

该拓扑使用简单，拿二进制日志的位置来横向比较各个从服务器，这一点非常方便。因为它们都是一样的。

如果把所有的从服务器在相同的逻辑复制点停掉，会发现它们都在读取*主*日志的同一个物理位置，这是一个非常好的特性，简化了许多管理任务，比如把*从*提升为 主。

该特性只存在于这些兄弟从服务器之间，即同一级别的 从。












### 静态主主

两个服务器，每个都配置成既是 主，又是 从，**互为主从**，同时都可以写入。

两个服务器不分主次，每个都是主动做另一个的主服务器，同时还是另一个的从服务器。

![image-center](/assets/images/mysql.repl.topo.mm.png){: .align-center}

这种互为 主从 的拓扑只有在非常特殊的情况下才会使用，比如地理位置比较远的两个办公室，每个办公室都需要在本地有一个数据的可写副本。


#### 缺点

该拓扑最大的问题是 **如何管理相互冲突的修改**。

例如，两端的服务器可能会尝试 **同时修改同一行的数据**，或者，两个服务器同时向某个表格中插入一个 `AUTO_INCREMENT` 字段。

两个服务器上 **以不同顺序发生的更新** 也会迫使数据无法同步。

如果复制因为错误而停止了，但某些程序却仍然向这两个服务器写入数据，两端不同的数据会越来越多，产生的差异几乎是无法同步的。













### 动态主主

静态主主的问题这么多，两个服务器都想当老大。于是产生了一个变体：

![image-center](/assets/images/mysql.repl.topo.ms.png){: .align-center}

与静态主主的区别在于，同一时刻，一个是主动，一个是被动。

>所谓被动，就是指该服务器在当前状态是 **只读** 的。

使用该配置，主动和被动服务器可以很轻松地互换，因为它们的配置是对称的，这让失效切换和自动恢复变得更容易。无需离线就可以进行维护、优化表格、升级操作系统、升级应用程序、升级硬件。




#### 工作原理

![image-center](/assets/images/mysql.repl.dyn.mm.png){: .align-center}

以执行 `ALTER TABLE` 为例，说明该拓扑工作原理。

因为服务器在运行 `ALTER TABLE` 语句时，会锁定整个的表格，禁止对其读取和写入，这个过程有可能持续较长时间，会影响其它服务。但在该拓扑中，**只在被动服务器上** 运行该语句，可以保证不影响其它服务的运行，同时也不受其它因素的影响。

* 处于主动模式的 server1 停止自身的复制线程，以保证自己不会复制、处理 server2 的更新
* 处于被动模式的 server2 开始执行 `ALTER TABLE` 语句
* 二者互换角色
* 处于被动模式的 server1 恢复复制线程，server1*从*server2 中复制其更新
* server1 读取本地中继日志，执行同样的 `ALTER TABLE` 语句

利用这种拓扑可以避免很多问题，也可以规避一些 MySQL 的限制。




#### 配置方法

在双方服务器上都执行以下步骤，以便得到对称的配置：

1. 确保双方拥有相同的数据
2. 启用二进制日志，选择唯一的 Server ID，增加复制帐户
3. 启用复制更新的日志
4. 配置被动服务器为只读，以防止产生与主动服务器冲突的修改
5. 启动每个服务器的 MySQL 实例
6. 把每个服务器都配置为对方的 从，从新建的二进制日志开始




#### 复制的流程

![image-center](/assets/images/mysql.repl.dyn.mm2.png){: .align-center}

当主动模式的 server1 从 server2 的二进制日志中读取到自己的事件时，会忽略，因为事件的 Server ID 是它自己。

>使用这种拓扑有点像创建了一个热备，只不过还可以用这个热备来提升性能。可以用来读取查询、备份、离线维护、升级等等，这些事在真的热备上却是无法完成的。但是该拓扑没有带来更好的写入性能。
> 这是一个非常重要、非常常用的复制拓扑。















### 带从的主主

![image-center](/assets/images/mysql.repl.topo.mmss.png){: .align-center}

该拓扑的优势是额外的冗余，在每一侧都消除了单点失效。同时，也可以用*从*缓解读取压力。

可用于本地失效切换，主 失效时可以把*从*提升为 主，只是做起来有些复杂。












### 环状复制

双主的配置实际上只是环状复制的一个特殊案例。环状拓扑可以有三个或多个主服务器，每个都是它前面的 从，它后面的 主。环状拓扑也称圆形复制。

这种拓扑没有主主的那些关键优势，比如对称配置以及便捷的失效切换。复制特别依赖于拓扑中的每个节点一直可用，大大增加了整个系统失效的风险。如果从中拿掉一个，从该节点产生的所有复制事件就会进入一个死循环：这些事件会在剩下的复制链中永远循环下去，因为能够过滤掉该事件的只有它自己。

通常来说，环状复制是很脆弱的，应该避免使用。












### 主 - 分主 - 从

![image-center](/assets/images/mysql.repl.topo.mdmsss.png){: .align-center}

当从服务器足够多的时候，它们会给主服务器带来很大的负载，每个从服务器都会在主服务器上创建一个新的线程，用它来执行 `binlog dump` 命令。该命令会从二进制日志中读取数据，将其发送给从服务器。这个操作需要为每个从服务器都重复进行，它们并不会共享所需的资源。

如果有许多从服务器，产生了一个特别巨大的二进制日志事件，如 `LOAD DATA INFILE` 这样的语句，主服务器的负载会急剧增加。主服务器甚至可能耗尽内存以致崩溃，因为所有从服务器同时在请求同一个巨大的事件。另一方面，如果从服务器全都请求不同的事件，而且这些事件都已经不在缓存中了，这会引起大量的磁盘寻道操作，同样会干扰主服务器的性能，产生互斥连接。

基于这个原因，如果确实需要大量从服务器，最好把主服务器的负载分摊给*分主*服务器，即 distribution master，下文简称*分主*。*分主*本身也是一个从服务器，它唯一的目的就是读取主服务器的二进制日志，然后提供给其它从服务器读取。相当于在主与从之间做了个缓冲区。可以把所有的从服务器连接到*分主*上，由*分主*来隔离负载。为了避免*分主*真的执行那么多的查询操作，可以把它的表格改为黑洞存储引擎。

很难说一个主服务器管理超过多少从服务器才需要一个*分主*，粗略地推算，如果一个主服务器接近满负荷运转时，它下面不建议超过 10 个从服务器。如果写入操作特别少，或者只需要复制表格的一小片断，主服务器也许可以管理更多的从服务器。

另外，不一定限制只使用一个*分主*，需要时可以用多个。有时候，配置 `salve_compressed_protocol` 有助于在主服务器上节省一部分带宽，这一点对跨数据中心的复制尤其有用。

*分主*还要以用于其它目的，比如应用过滤器，向二进制日志事件中重写规则。这样做比从服务器上传统的重演、重写、过滤更高效。

如果在*分主*上使用黑洞表格，会比平时能承担更多的从服务器。虽然 *分主* 会执行查询，但这些查询的开销会非常小，因为黑洞表格不会含有任何数据。



#### 缺点

这种方法存在一些 BUG，比如在某些情况下会忘记向其二进制日志中添加自增的 ID，所以使用时要特别小心。

如何确保*分主*中的所有表格都使用黑洞存储引擎，这是一个问题。

如果有人在主服务器上创建了一个新表格，使用的是其它存储引擎，虽然可以通过指定其 `storage_engine` 选项来解决：

```conf
storage_engine=blackhole
```

但该选项只会影响那些没有显式指定存储引擎的 `CREATE TABLE` 语句。如果现有的程序是无法控制的，该拓扑就会变得脆弱。

另外，要想用从服务器之一来替换主服务器是非常困难的，因为*分主*始终认为，所有的从服务器其二进制日志坐标与主服务器应该始终不同。















### 树状拓扑

![image-center](/assets/images/mysql.topo.tree.png){: .align-center}

树状拓扑适合远距离同步数据，或用于提升读取能力，这种拓扑更容易管理。



#### 优点

树状拓扑缓解了主服务器的负载


#### 缺点

中间层的任何失效都会影响到多个服务器，中间层越多，处理失效就越复杂、越困难。














### 自定义复制拓扑

MySQL 的复制是非常灵活的，完全可以按照自己的需求来单独设置一个解决方案。通常需要把过滤器、分布式、复制的组合应用到不同的存储引擎。还可以用一些特殊的处理，比如前面提到的使用黑洞存储引擎。可以设计的特别精密，最大的限制只是你是否有能力做好监控和管理，以及网络带宽、CPU 等资源是否足够。




#### 选择性地复制

为了充分利用本地读取的高效，并且能尽可能地把要处理的数据放在内存中快速读取，每次都应该只复制 **少量** 的数据给*从*。如果每个*从*上都有一小块*主*的数据，然后在需要时直接去读取这些*从*，这样可以充分地利用它们的内存，明显提升读取的性能。每个*从*也可以为*主*分担一小块写入的压力，这样一来，提升了*主*的写入能力的同时，还不会拖累*从*。

与其它方法相比，这种拓扑的好处是，主服务器依然保存着 **所有** 数据。这意味着：

* 一个写入查询所需的数据，在一个服务器上一次都能获取，无需在多个服务器上查找。
* 对于读取的查询，如果每个*从*上都没有该查询所需的完整数据，还可以读取*主*。

即使*从*无法分担全部的读取压力，它们毕竟还是可以分担许多的。

##### 以数据库为单位 分散复制

最简单的办法是，在主服务器上，把数据分区存放在不同的数据库中，然后把每个数据库分别复制到不同的*从*。

例如，把公司不同部门的数据分别存放到不同的*从*，每个*从*都应该使用 `replicate_wild_do_table` 选项把复制限制在特定的表格上：

```conf
replicate_wild_do_table = sales.%
```

##### 使用分主

可以用*分主*对要复制的数据进行过滤。

例如，想要从负载严重的服务器上仅仅复制一部分数据，然后穿越一个缓慢或昂贵的网络，可以在本地设立一个*分主*，上面使用黑洞和过滤规则。借助过滤规则，*分主*可以从其日志中去掉无用的条目，一方面有助于去掉*主*中危险的日志设置，另一方面还不需要把整个日志扔到网上，传输给远处的*从*。





#### 分离功能

>OLTP：online transaction processing，在线事务处理
>
>OLAP：online analytical processing，在线分析处理

许多应用程序同时包含了这两种处理的查询。

* OLTP 查询通常很**短**，是**事务性**的，
* OLAP 查询通常较**大**、很**慢**，不需要最新的数据

这两类查询带给服务器的压力也是完全不同的，因此，只有在不同的配置、不同的存储引擎、不同的硬件中，它们才能各自发挥最好的性能。

对此，常用的办法是把 OLTP 服务器中的数据，复制到一个专门为 OLAP 负载设计的*从*中。这些*从*可以拥有不同的硬件、配置、索引、存储引擎。如果你肯把一个*从*专门用于 OLAP 查询，你就一定愿意忍受更多的复制间隔，否则会导致该*从*的服务质量的下降。带来的好处是，有些任务如果在非专门*从*上进行会导致不可接受的性能降低，而在专用的上面就可以完成，例如执行非常长时间的查询。

虽然不需要针对复制进行特殊的配置，不过如果确实节省很多资源，你可以选择从*主*滤掉一些，*从* 就不用再保存这些数据了。在中继日志上，即使过滤掉一小部分数据，也会有助于减少 I/O 和缓存的活动。





#### 数据归档

可以在*从*中将数据归档，即该数据保存在*从*中，但会从*主*中删除。

在*主*上运行删除查询，并确保这些查询不会在*从*上执行。
{: .notice}

通常有两种办法：

##### 在主服务器上选择性地禁用二进制日志

这种方法需要运行一个专用来清除主服务器数据的进程，先在进程中执行 `SET SQL_LOG_BIN=0`，然后清除数据。

优点：*从*上不需要特殊配置，而且，因为语句没有保存到二进制日志中，执行起来更有效率。

缺点：无法使用 *主* 上的二进制日志进行审计了，也无法用来进行时间点恢复了，因为日志中不再包含这些修改。同时还需要 `SUPER` 权限。

##### 在从服务器上使用 `replicate_ignore_db` 过滤规则

这种方法是在*主*上执行清除数据语句前，先 `USE` 特定的数据库。

例如，可以在*主*上先创建一个名为 `purge` 的数据库，然后在*从*上的 `my.cnf` 配置文件中使用 `replicate_ignore_db=purge`，重启服务器。*从*就会忽略 `USE` 该数据库的语句。

缺点：*从*会取回一些它不需要的日志事件。有潜在的风险：某些人可能会不小心在 `purge` 数据库上执行了非清除的查询，这些本该复制的事件却不会被 *从* 复制。






#### 只读从服务器

许多企业愿意把从服务器配置成只读，这样的话，复制不会被无意的修改破坏掉。可以用 `read_only` 配置变量来实现，它会把大多数写入操作禁用：除了复制进程、拥有 `SUPER` 权限的用户以及临时表格。






#### 创建一个日志服务器

通过复制可以创建一个日志服务器，其中不保存数据，其唯一目的是为了便于重演、过滤二进制日志事件。这样做非常有利于在崩溃后重启复制，也有助于时间点恢复。

想像一下，你有一组二进制日志或中继日志，也许来自备份，也许来自一个崩溃的服务器，现在你希望能重演其中的事件。可以用 `mysqlbinlog` 来提取事件，但更方便快捷的方法是：配置一个没有任何数据的 MySQL 实例，并让它认为这些二进制日志是它自己的。之所以不需要任何数据，是因为它并不需要执行这些日志，只需要把日志提供给别的服务器。因此它需要一个复制帐户。

如果只是倒计时需要创建一个日志服务器，可以使用 [MySQL Sandbox](http://mysqlsandbox.net) 脚本。
