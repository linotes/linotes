---
toc: true
toc_label: "MySQL 主从复制"
toc_icon: "copy"
title: "MySQL 主从复制"
tags: mysql 主从 同步 复制
categories: "database"
classes: wide
excerpt: ""
header:
  overlay_image: /assets/images/header/mysql.jpg
  overlay_filter: rgba(0, 0, 0, 0.8)
---







## MySQL 的复制功能

MySQL 的主从复制来源于其特有的词汇：复制，即 **Replication**。因此在 MySQL 的语境中，提到的复制主要是指这个复制，而不是通常意义的 copy。
{: .notice--success}

通过复制，可以让数据从一个 MySQL 数据库服务器被复制到另一个或多个 MySQL 数据库服务器中，前者称为 **主服务器**，即 Master，后者称为 **从服务器**，即 Slaves。这就是所谓的主从。

复制默认是 **单向**、 **异步** 进行的，因此，从服务器无需为了收到更新而一直保持连接。这就意味着更新是可以在远距离连接上进行的，甚至可以在临时的或间断性的连接上进行，如拨号连接。根据配置，可以复制全部数据库、部分数据库、或库中指定的表。








### 复制的优点

MySQL 内置的复制功能，配合使用这种可扩展的架构，是建设大型、高性能应用的基础。这种主从复制不仅仅有利于高性能的应用程序，它还是许多策略的基石，包括：高可用、可扩展性、灾难恢复、备份、数据分析、数据仓库等任务。

* 可扩展解决方案：把负载分摊到多个从服务器上，从而提升性能。在该环境下，所有的 **写** 和 **更新** 操作必须发生于 **主** 服务器上，即主服务器专用于更新。而 **读** 操作，可以发生在一个或多个 **从** 服务器上。这种模式一方面会提升写的性能，另一方面，不断增长的从服务器还会大大提升读的速度。

* 数据安全：因为数据被复制到从服务器，而且从服务器可以暂停复制的进程，因此，可以做到在从服务器上运行 **备份** 服务，同时还不会破坏对应的主服务器上的数据。

* 数据分析：可以在主服务器上创建实时数据，而对信息的分析可以发生在从服务器，不会影响主服务器的性能。

* 远距离数据分布：如果由于工作需要，公司在远方的分部门需要主数据的一个副本，可以利用复制在本地创建一个副本，而无需与主服务器保持持续的连接。







### 复制的分类

在两个服务器之间配置复制有很多种办法，但最好的办法取决于使用的数据以及引擎的类别。

MySQL 复制的格式有两个核心的类别：

* 基于 **语句** 的复制：SBR，Statement Based Replication。也称逻辑复制，它会复制全部 SQL 语句。启用于 MySQL 3.23 版本。
* 基于 **行** 的复制：RBR，Row Based Replication。只复制发生修改的行。启用于 MySQL 5.1 版本。


#### 传统的 基于二进制日志的复制

早期的复制是基于主服务器的二进制日志，其中保存了主服务器对数据库所做的修改，从服务器读取这些日志，据此来在自己本地进行同样的操作，实现更新。以上所述的 SBR 和 RBR 均属于这种，均是异步完成的，意味着有可能主从之间会存在数据同步延迟。

主服务器将更新写入 **二进制日志文件**，并维护文件的一个索引，以跟踪日志循环。当从服务器连接主服务器时，它会把自己在日志中读取的最后一次成功更新的位置告知主服务器。从服务器接收该位置之后发生的任何更新，然后封锁，等待主服务器通知新的更新。

#### 较新的 基于 GITD 的复制

在 MySQL 5.6.5 开始及之后的版本中，支持事务复制，是基于全局事务标识符，即 **GITD**，Global Transaction IDentifier。使用这类的复制时，无需直接处理日志文件或其偏移量，极大简化了许多日常的复制任务。因为使用 GTID 进行复制是完全事务性的，只要在主服务器上提交的所有事务都已应用于从服务器，则可以保证主从的一致性。









### 复制所解决的问题

复制通常用于以下方面：



#### 数据分布

MySQL 的复制通常对带宽不算敏感，因此可以用来远距离维护数据的副本，例如在不同的数据中心之间同步数据。

#### 负载平衡

MySQL 的复制有助于把读请求分配到多个服务器上，这一点对于读敏感的应用来说特别好用。对代码做简单的修改就可以实现基本的负载平衡。无论是简单的轮询 DNS，还是更复杂的方法，都可以在 MySQL 服务器上很好地工作。

#### 备份

主从分开非常有利于备份的稳定进行。

#### 高可用 与 失效切换

复制还有助于避免单点失效的发生，失效切换系统如果使用复制，可以大幅减小当机时间。

#### MySQL 升级前测试

通常会在从服务器上进行新版本 MySQL 的测试，以确保所有查询都能正常工作，之后再升级所有实例。








### 复制的工作原理



#### MySQL 是如何复制数据的

从高层级来看，复制的进程包含三部分：

1. 主服务器把修改保存到二进制日志中，这些记录称为二进制日志事件。
2. 从服务器把主服务器的日志事件复制进自己的中继日志，即 relay log。
3. 从服务器重现中继日志中的事件，把修改应用到自己的数据中。

![image-center](/assets/images/mysql.replication.png){: .align-center}

##### 主服务器保存二进制日志

主服务器上，MySQL 在每个更新数据的事务开始之前，会 **提前** 把即将发生的修改记录到二进制日志里。写入日志的操作是 **串行** 的，即使如果事务中的语句在执行过程中是交错进行的。写完以后，主服务器会告诉存储引擎去提交事务。

##### 从服务器拷贝二进制日志

从服务器启动一个工人线程，**I/O slave**，它会与主服务器打开一个普通的客户端连接，然后在主服务器上启动一个特殊的线程，**binlog dump** 线程，它会从主服务器的二进制日志中 **读取事件**。它并不会对事件进行轮询。如果发现已经同步，它会进入休眠，等待产生新事件时，主服务器向其发送信号。然后，I/O 线程把读取到的事件写入从服务器的中继日志。

##### 事件重演

**SQL slave** 线程从中继日志中读取并重演事件，从而更新从服务器的数据，与主服务器完全匹配。只要 SQL slave 线程能与 I/O 线程保持同步，中继日志通常会保持在操作系统的缓存中，因此其开销很少。如果有需要，可以把 SQL 线程所执行的事件保存到从服务器自己的二进制日志中。

在从服务器上，这种复制的架构 **拆分** 了获取与重演事件的过程，从而可以实现二者的 **异步**。即，I/O 线程可以独立于 SQL 线程运行。同时，复制的进程也受到一定的约束，其中最重要的约束就是：**复制在从服务器上是串行的**。这就意味着即使在主服务器上可以并行用多个线程同时更新，在从服务器上却无法实现并行，因为所有更新都是在一个线程中执行的。这一点对于许多工作负载来说是个瓶颈，需要另外解决，不过对于大多数用户来说，一个线程就够用了。
{: .notice}





























## 复制的配置

虽然复制的配置相当简单，但在基本步骤上还有很多变化，取决于具体的实施场景。最基本的场景是新安装的主从服务器。从高层级来看，可以分为以下步骤：

1. 在每个服务器上配置复制的帐户
2. 配置主从服务器
3. 从服务器连接到主服务器进行复制

这是在假设默认配置就能满足工作的基础上的，事实也是如此。新安装了主从服务器时，它们拥有相同的数据，即默认的 mysql 数据库。




### 创建复制帐户

MySQL 有几个特殊的权限是用于复制进程的，从服务器上的 I/O 线程会与主服务器创建一个 TCP/IP 连接。因此，必须在主服务器上 **创建** 一个用户帐户，**授予** 适当 **权限**，这样，I/O 线程才可以用该用户的身份连接过去，读取二进制日志。

创建帐户 repl：

```mysql
mysql> CREATE USER 'repl'@'192.168.0.%' IDENTIFIED BY 'password';
mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
-> TO repl@'192.168.0.%';
```

在主从服务器上都要创建同样的用户。




### 配置主从

需要在主服务器上 **启用二进制日志**，并 **指定服务器 ID**。

```bash
$ cat /etc/my.cnf
log_bin=/var/log/mysql/bin.log
server_id=10
```

`server_id` 必须是唯一的，通常避免用 1，因为 1 是默认值，避免混淆。通常会使用该服务器 IP 地址的最后一段。

配置好以后需要 **重启 mysqld**，然后登陆进去，查看以 **确认** 二进制日志已经生成：

```mysql
mysql> SHOW MASTER STATUS;
+------------+----------+--------------+------------------+-------------------+
| File       | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------+----------+--------------+------------------+-------------------+
| bin.000002 |      634 |              |                  |                   |
+------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```
