---
toc: true
toc_label: "InnoDB 简介"
toc_icon: "copy"
title: "InnoDB 简介"
tags: InnoDB
categories: "mysql"
classes: wide
excerpt: ""
published: false
header:
  overlay_image: /assets/images/header/mysql.jpg
  overlay_filter: rgba(0, 0, 0, 0.8)
---




## MySQL 基本概念

在研究 InnoDB 存储引擎之前，有必要复习几个 MySQL 的基本概念。







### 主键

Primary Key

主键是指一列或一组列，其值能 **唯一区分** 表中的每一行数据，而且其值不能为空。

主键是一个 **逻辑对象**。

每个表格都有一个主键，如果 `CREATE TABLE` 语句没有指定主键，MySQL 会使用第一个非空唯一键做为主键，假如失败，则会在表格中自动生成一个隐藏的 `Row ID` 字段，将其做为主键。

**一定要指定一个主键**，隐藏的这个对你不仅没用，还会在每行占用 6 个字节。
{: .notice}

MySQL 对主键会自动生成唯一索引，所以主键也是一个特殊的索引。













### 索引

Index

索引是帮助 MySQL **高效获取数据** 的数据结构。
{: .notice}

索引是由表格或视图创建而来的，它与书本中的目录非常相似，可以大大缩短找到特定数据所需的时间。

索引用于快速查找包含特定字段值的行。如果没有索引，MySQL 必须从第一行开始逐行对整个表格进行彻底的检查，表格越大，开销越大。如果表格有一个这个字段的索引，就可以快速地判定这一行的位置，而无需查看所有的数据。这种方法要比逐行查看整行数据要快的多。

大部分 MySQL 索引是以 B-Tree 的形式保存的。

在数据库中创建索引时，会在磁盘中创建一个 **物理对象**。




#### 索引的种类

* Clustered
* Non-Clustered
* Unique
* Filtered
* XML
* Full Text
* Spatial
* Columnstore
* Index with included columns
* Index on computed columns





#### 聚集索引 与 非聚集索引

Clustered Index / Non-Clustered Index

每个 InnoDB 表格都有一个特殊的索引，称为聚集索引。

一般情况下，**聚集索引** 与 **主键** 是同义词。

* 为表格定义主键时，InnoDB 会将其做为聚集索引使用。一定要给每个表格都定义一个主键，如果没有逻辑唯一且非空的字段，可以单独添加一个自增字段，字段值会自动填充。
* 


聚集索引决定了表格中数据的物理顺序，因此，每个表格只能有一个聚集索引。




#### 唯一索引 与 非唯一索引

默认情况下，一个 **主键约束** 会创建一个唯一的 **聚集索引**，而一个 **唯一性约束** 会创建一个唯一的 **非聚集索引**。这些默认设置可以自行修改。










### 约束

Constraint

MySQL 中，约束是指对表格中的字段如何取值定义一些规则。

按照这个规则，允许或限制特定的值保存到该字段中。

* 引入约束的目的在于保证数据库的完整性
* 约束用来限制向表格中插入数据的类型

约束分为两类：字段级 和 表格级。字段级约束保能应用于一个字段，表格级应用于整个表格。




#### 约束的种类


##### `NOT NULL`

非空约束。

使用该约束以后，该字段的值不能为空，即 NULL，必须是具体的数据。

该约束可以在创建、修改表格时使用。

```sql
mysql> create table t_user(
    -> id int(10),
    -> name varchar(32) not null
    -> );
```

向表格插入记录时，如果该字段没赋值，会报错。


##### `UNIQUE`

唯一性约束。

使用该约束以后，MySQL 会禁止向该字段插入重复的值。


##### `PRIMARY KEY`

主键约束。

一张表只能有一个主键约束。

使用该约束以后，指定的字段将被作为该表格的主键，因此不允许为空，也不允许重复。

* 单一主键：给一个字段添加主键约束
* 复合主键：给多个字段联合添加一个主键约束（只能用表级约束）


##### `FOREIGN KEY`

外键约束。

MySQL 会通过两个表格中都存在的某个字段，在两个表格之间创建一个链接。该字段在一个表格中必须是主键，相对的，在另一个表格中，该字段就称为外键。

一张表可以有多个外键字段。

* 单一外键：给一个字段添加外键约束
* 复合外键：给多个字段联合添加一个外键约束


##### `CHECK`

检查约束。

启用该约束时，可以用逻辑表达式来限制该字段的值的有效模板。

但 MySQL 直到 8.0 版本仍未支持该功能，虽然它能够解析该子句，却会忽略掉。

>The CHECK clause is parsed but ignored by all storage engines.

在需要使用检查约束的场景下，通常会使用触发器来实现。

```sql
USE office
CREATE TRIGGER staff-check
	BEFORE INSERT ON Staff
	FOR EACH ROW
BEGIN
	IF NEW.id<0 THEN
	NEW.id=0
	END IF;
END
```


##### `DEFAULT`

默认约束。为字段指定默认值。

使用该约束以后，该字段必须包含有效的值，包括 NULL。

向表格插入数据时，如果没有为该字段提供有效值，该字段就会使用默认约束所指定的值。































## InnoDB 的优点

InnoDB 是一个通用的存储引擎，它在高可用与高性能之间有着比较好的平衡。在 MySQL 8.0 中，它是默认的存储引擎。


* 其 DML 操作遵循 ACID 模型，具有 **事务性** 的提交、回滚和故障恢复功能，便于保护用户数据。
* **精细到行的锁定**，Oracle 风格的一致读取，提升了多用户 **并发数** 及 **性能**。
* InnoDB 的表格可以 **管理磁盘中的数据**，以优化基于主键的查询。每个表格都有一个主键索引，称为集群索引，用它来组织数据，以减小用于寻找主键的 I/O。
* 为了保持数据的一致性，InnoDB 支持 `FOREIGN KEY` 约束，即 **外键约束**。使用外键以后，会检查插入、更新和删除的操作， 以确保它们不会导致不同表之间的不一致。
* 它有 **崩溃恢复功能** ：如果服务器由于硬件或软件故障而崩溃，不用考虑当时数据库当时发生了什么，重启数据库后不需要做任何特殊的操作。InnoDB 的会自动完成崩溃之前所提交的修改，回退尚未提交却当时正在进行的修改。
* InnoDB 存储引擎会维护其自己的 **缓冲池**，用于访问数据时，在内存中缓存表格和索引数据。经常使用的数据可以直接在内存中处理。该缓存可以用于多种类型的信息。在专用的数据库服务器上，通常超过 80% 的物理内存都分配给了缓冲池。
* **外键** 保证数据完整性：把相关的信息拆分到不同的表格中以后，可以通过设置外键来实现引用的完整性。更新或删除数据时，其它表格中相关的数据也会随之自动更新或删除。如果试图在第二个表中插入数据，但在第一个表格中没有对应的数据，插入会失败。
* 如果磁盘或内存中的数据被 **损坏**，校验机制会在用户使用数据之前发出 **警告**。
* 为数据库中的每个表格定义主键时，**针对主键的操作会被自动优化**。在 `WHERE`、`ORDER BY`、`GROUP BY` 等子句中，以及在使用连接操作符时，可以非常快速地引用主键字段。
* 插入、更新、删除会被 **自动优化**，该机制称为 **缓冲修改**，即 change buffering。InnoDB 不仅允许 **同时读、写** 同一个表格，还会把发生修改的数据缓存到流水线上的磁盘 I/O 中。
* 不仅是对巨大表格进行长时间的查询得到了性能的提升，当相同的行被反复访问时，会使用 **自适应哈希索引** 来优化，使查询变得更加快速，如同它们是从哈希表格里出来的。
* 可以 **压缩** 表格及相关索引。
* 创建或删除索引时，对性能与可用性的影响更小。
* 清空 `file-per-table` 表空间的速度非常快，并且可以 **直接释放磁盘空间**，而不只是系统表空间。
* 表格数据的存储布局对于 BLOB 类型和 LONGTEXT 类型的字段更加高效，使用 `DYNAMIC` 行格式。
* 可以通过查询 `INFORMATION_SCHEMA` 表格来监测存储引擎内部的工作情况。
* 可以通过查询 `Performance Schema` 表格来监测存储引擎性能细节。
* 可以随意地把 InnoDB 的表格 **与其它 MySQL 存储引擎的表格组合** 到一起，甚至可以用在同一个语句中。例如，可以仅在一个查询中，使用一个连接操作符把 InnoDB 和 MEMORY 表格合并到一起。
* 处理较大的数据时，性能更高，CPU 占用更少。
* 可以应对数量庞大的数据。


>DML：Data Manipulation Language。数据操作语言，是一组 SQL 语句，用于进行 `INSERT`、`UPDATE`、`DELETE` 等操作。

>ACID：Atomicity, Consistency, Isolation, Durability。原子性，一致性，独立性，耐用性。

>BLOB：Binary Large Object，二进制大对象。是数据库中用来存储二进制文件的字段类型，是一个可以存储二进制文件的容器。BLOB 是一个大文件，典型的是图片、音频、视频文件，由于它们的尺寸较大，必须使用特殊的方式来处理。
































## InnoDB 的架构





### 缓冲池

Buffer Pool

缓冲池是内存中的一块，当有数据被访问时，InnoDB 会把表格和索引数据缓存到这里。借助缓冲池可以直接在内存中处理这些频繁使用的数据，大大提升了处理速度。在专用的数据库服务器上，通常超过 80% 的物理内存都分配给了缓冲池。

为了提高大容量读取操作的效率，缓冲池被分为多个 **页面**，每页面可容纳多 **行**。
{: .notice}

为了高效管理缓存，缓冲池做成一个互相链接的页面列表。很少用到的数据会从缓存中过期。










### 变更缓冲区

Change Buffer

变更缓冲区的主要目的是将对二级索引的数据操作缓存下来，以此减少二级索引的随机 I/O，并达到操作合并的效果。

变更缓冲区是一个特殊的数据结构，如果受影响的页面不在缓冲池中，**对二级索引页面的修改** 就会被缓存到变更缓冲区中。

这些被缓冲的变更可能来自 `INSERT`、`UPDATE`、`DELETE` 等操作，当受影响的页面被加载到缓冲池时，变更缓冲区中的这些修改

>在 MySQL 5.5 之前的版本中，由于只支持缓存 insert 操作，所以最初叫做 **Insert Buffer**，只是后来的版本中支持了更多的操作类型缓存，才改叫 Change Buffer，这也是为什么代码中有大量的 ibuf 前缀开头的函数或变量。











##### REDO 日志

redo log，是基于磁盘的数据结构，用于崩溃后的 **自动恢复**。

在 mysqld 启动时，InnoDB 会进行自动恢复，以纠正由不完整的事务写入的数据。在 mysqld 意外关闭前一刻没有完成更新数据文件的事务，会在 mysqld 启动时自动重演。重演时会使用日志序列编号，即 Log Sequence Number，LSN。

如果对数据的修改量很大，会无法快速写入磁盘，因此，它们会先被保存到 REDO 日志中，然后再保存到磁盘上。

在 REDO 日志中，所有发生的修改会被详细记录：行 ID、原字段值、新字段值，会话 ID、时间。

一旦提交成功，数据就安全地保存到磁盘的数据文件中了。
